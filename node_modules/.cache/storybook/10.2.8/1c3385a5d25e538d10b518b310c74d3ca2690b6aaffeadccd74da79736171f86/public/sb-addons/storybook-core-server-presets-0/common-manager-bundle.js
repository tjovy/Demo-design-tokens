try{
(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __require = /* @__PURE__ */ ((x3) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(x3, {
    get: (a3, b3) => (typeof require < "u" ? require : a3)[b3]
  }) : x3)(function(x3) {
    if (typeof require < "u") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x3 + '" is not supported');
  });
  var __esm = (fn2, res) => function() {
    return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: !0 });
  };

  // <define:module>
  var init_define_module = __esm({
    "<define:module>"() {
    }
  });

  // <define:process.env>
  var init_define_process_env = __esm({
    "<define:process.env>"() {
    }
  });

  // <define:process.env.NODE_PATH>
  var init_define_process_env_NODE_PATH = __esm({
    "<define:process.env.NODE_PATH>"() {
    }
  });

  // node_modules/storybook/dist/_browser-chunks/chunk-2FRVAXCZ.js
  var getControlId, getControlSetterButtonId, init_chunk_2FRVAXCZ = __esm({
    "node_modules/storybook/dist/_browser-chunks/chunk-2FRVAXCZ.js"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      getControlId = (value2) => `control-${value2.replace(/\s+/g, "-")}`, getControlSetterButtonId = (value2) => `set-${value2.replace(/\s+/g, "-")}`;
    }
  });

  // node_modules/storybook/dist/_browser-chunks/chunk-A242L54C.js
  var __create, __defProp2, __getOwnPropDesc, __getOwnPropNames2, __getProtoOf, __hasOwnProp, __require2, __commonJS, __export2, __copyProps, __toESM, init_chunk_A242L54C = __esm({
    "node_modules/storybook/dist/_browser-chunks/chunk-A242L54C.js"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      __create = Object.create, __defProp2 = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames2 = Object.getOwnPropertyNames, __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty, __require2 = ((x3) => typeof __require < "u" ? __require : typeof Proxy < "u" ? new Proxy(x3, {
        get: (a3, b3) => (typeof __require < "u" ? __require : a3)[b3]
      }) : x3)(function(x3) {
        if (typeof __require < "u") return __require.apply(this, arguments);
        throw Error('Dynamic require of "' + x3 + '" is not supported');
      }), __commonJS = (cb, mod) => function() {
        return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      }, __export2 = (target, all) => {
        for (var name in all)
          __defProp2(target, name, { get: all[name], enumerable: !0 });
      }, __copyProps = (to, from, except, desc) => {
        if (from && typeof from == "object" || typeof from == "function")
          for (let key of __getOwnPropNames2(from))
            !__hasOwnProp.call(to, key) && key !== except && __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
        return to;
      }, __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
        // If the importer is in node compatibility mode or this is not an ESM
        // file that has been converted to a CommonJS file using a Babel-
        // compatible transform (i.e. "__esModule" has not been set), then set
        // "default" to the CommonJS "module.exports" for node compatibility.
        isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: !0 }) : target,
        mod
      ));
    }
  });

  // global-externals:react
  var react_default, Children, Component, Fragment, Profiler, PureComponent, StrictMode, Suspense, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, act, cloneElement, createContext, createElement, createFactory, createRef, forwardRef, isValidElement, lazy, memo, startTransition, unstable_act, useCallback, useContext, useDebugValue, useDeferredValue, useEffect, useId, useImperativeHandle, useInsertionEffect, useLayoutEffect, useMemo, useReducer, useRef, useState, useSyncExternalStore, useTransition, version, init_react = __esm({
    "global-externals:react"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      react_default = __REACT__, { Children, Component, Fragment, Profiler, PureComponent, StrictMode, Suspense, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, act, cloneElement, createContext, createElement, createFactory, createRef, forwardRef, isValidElement, lazy, memo, startTransition, unstable_act, useCallback, useContext, useDebugValue, useDeferredValue, useEffect, useId, useImperativeHandle, useInsertionEffect, useLayoutEffect, useMemo, useReducer, useRef, useState, useSyncExternalStore, useTransition, version } = __REACT__;
    }
  });

  // global-externals:storybook/internal/components
  var components_default, A, AbstractToolbar, ActionBar, ActionList, AddonPanel, Badge, Bar, Blockquote, Button, Card, ClipboardCode, Code, Collapsible, DL, Div, DocumentWrapper, EmptyTabContent, ErrorFormatter, FlexBar, Form, H1, H2, H3, H4, H5, H6, HR, IconButton, Img, LI, Link, ListItem, Loader, Modal, ModalDecorator, OL, P, Placeholder, Popover, PopoverProvider, Pre, ProgressSpinner, ResetWrapper, ScrollArea, Select, Separator, Spaced, Span, StatelessTab, StatelessTabList, StatelessTabPanel, StatelessTabsView, StorybookIcon, StorybookLogo, SyntaxHighlighter, TT, TabBar, TabButton, TabList, TabPanel, TabWrapper, Table, Tabs, TabsState, TabsView, ToggleButton, Toolbar, Tooltip, TooltipLinkList, TooltipMessage, TooltipNote, TooltipProvider, UL, WithTooltip, WithTooltipPure, Zoom, codeCommon, components, convertToReactAriaPlacement, createCopyToClipboardFunction, getStoryHref, interleaveSeparators, nameSpaceClassNames, resetComponents, useTabsState, withReset, init_components = __esm({
    "global-externals:storybook/internal/components"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      components_default = __STORYBOOK_COMPONENTS__, { A, AbstractToolbar, ActionBar, ActionList, AddonPanel, Badge, Bar, Blockquote, Button, Card, ClipboardCode, Code, Collapsible, DL, Div, DocumentWrapper, EmptyTabContent, ErrorFormatter, FlexBar, Form, H1, H2, H3, H4, H5, H6, HR, IconButton, Img, LI, Link, ListItem, Loader, Modal, ModalDecorator, OL, P, Placeholder, Popover, PopoverProvider, Pre, ProgressSpinner, ResetWrapper, ScrollArea, Select, Separator, Spaced, Span, StatelessTab, StatelessTabList, StatelessTabPanel, StatelessTabsView, StorybookIcon, StorybookLogo, SyntaxHighlighter, TT, TabBar, TabButton, TabList, TabPanel, TabWrapper, Table, Tabs, TabsState, TabsView, ToggleButton, Toolbar, Tooltip, TooltipLinkList, TooltipMessage, TooltipNote, TooltipProvider, UL, WithTooltip, WithTooltipPure, Zoom, codeCommon, components, convertToReactAriaPlacement, createCopyToClipboardFunction, getStoryHref, interleaveSeparators, nameSpaceClassNames, resetComponents, useTabsState, withReset } = __STORYBOOK_COMPONENTS__;
    }
  });

  // global-externals:@storybook/icons
  var icons_default, AccessibilityAltIcon, AccessibilityIcon, AccessibilityIgnoredIcon, AddIcon, AdminIcon, AlertAltIcon, AlertIcon, AlignLeftIcon, AlignRightIcon, AppleIcon, ArrowBottomLeftIcon, ArrowBottomRightIcon, ArrowDownIcon, ArrowLeftIcon, ArrowRightIcon, ArrowSolidDownIcon, ArrowSolidLeftIcon, ArrowSolidRightIcon, ArrowSolidUpIcon, ArrowTopLeftIcon, ArrowTopRightIcon, ArrowUpIcon, AzureDevOpsIcon, BackIcon, BasketIcon, BatchAcceptIcon, BatchDenyIcon, BeakerIcon, BellIcon, BitbucketIcon, BoldIcon, BookIcon, BookmarkHollowIcon, BookmarkIcon, BottomBarIcon, BottomBarToggleIcon, BoxIcon, BranchIcon, BrowserIcon, BugIcon, ButtonIcon, CPUIcon, CalendarIcon, CameraIcon, CameraStabilizeIcon, CategoryIcon, CertificateIcon, ChangedIcon, ChatIcon, CheckIcon, ChevronDownIcon, ChevronLeftIcon, ChevronRightIcon, ChevronSmallDownIcon, ChevronSmallLeftIcon, ChevronSmallRightIcon, ChevronSmallUpIcon, ChevronUpIcon, ChromaticIcon, ChromeIcon, CircleHollowIcon, CircleIcon, ClearIcon, CloseAltIcon, CloseIcon, CloudHollowIcon, CloudIcon, CogIcon, CollapseIcon, CommandIcon, CommentAddIcon, CommentIcon, CommentsIcon, CommitIcon, CompassIcon, ComponentDrivenIcon, ComponentIcon, ContrastIcon, ContrastIgnoredIcon, ControlsIcon, CopyIcon, CreditIcon, CrossIcon, DashboardIcon, DatabaseIcon, DeleteIcon, DiamondIcon, DirectionIcon, DiscordIcon, DocChartIcon, DocListIcon, DocumentIcon, DownloadIcon, DragIcon, EditIcon, EditorIcon, EllipsisIcon, EmailIcon, ExpandAltIcon, ExpandIcon, EyeCloseIcon, EyeIcon, FaceHappyIcon, FaceNeutralIcon, FaceSadIcon, FacebookIcon, FailedIcon, FastForwardIcon, FigmaIcon, FilterIcon, FlagIcon, FolderIcon, FormIcon, GDriveIcon, GiftIcon, GithubIcon, GitlabIcon, GlobeIcon, GoogleIcon, GraphBarIcon, GraphLineIcon, GraphqlIcon, GridAltIcon, GridIcon, GrowIcon, HeartHollowIcon, HeartIcon, HomeIcon, HourglassIcon, InfoIcon, ItalicIcon, JumpToIcon, KeyIcon, LightningIcon, LightningOffIcon, LinkBrokenIcon, LinkIcon, LinkedinIcon, LinuxIcon, ListOrderedIcon, ListUnorderedIcon, LocationIcon, LockIcon, MarkdownIcon, MarkupIcon, MediumIcon, MemoryIcon, MenuIcon, MergeIcon, MirrorIcon, MobileIcon, MoonIcon, NutIcon, OutboxIcon, OutlineIcon, PaintBrushAltIcon, PaintBrushIcon, PaperClipIcon, ParagraphIcon, PassedIcon, PhoneIcon, PhotoDragIcon, PhotoIcon, PhotoStabilizeIcon, PinAltIcon, PinIcon, PlayAllHollowIcon, PlayBackIcon, PlayHollowIcon, PlayIcon, PlayNextIcon, PlusIcon, PointerDefaultIcon, PointerHandIcon, PowerIcon, PrintIcon, ProceedIcon, ProfileIcon, PullRequestIcon, QuestionIcon, RSSIcon, RedirectIcon, ReduxIcon, RefreshIcon, ReplyIcon, RepoIcon, RequestChangeIcon, RewindIcon, RulerIcon, SaveIcon, SearchIcon, ShareAltIcon, ShareIcon, ShieldIcon, SideBySideIcon, SidebarAltIcon, SidebarAltToggleIcon, SidebarIcon, SidebarToggleIcon, SortDownIcon, SortUpIcon, SpeakerIcon, StackedIcon, StarHollowIcon, StarIcon, StatusFailIcon, StatusIcon, StatusPassIcon, StatusWarnIcon, StickerIcon, StopAltHollowIcon, StopAltIcon, StopIcon, StorybookIcon2, StructureIcon, SubtractIcon, SunIcon, SupportIcon, SweepIcon, SwitchAltIcon, SyncIcon, TabletIcon, ThumbsUpIcon, TimeIcon, TimerIcon, TransferIcon, TrashIcon, TwitterIcon, TypeIcon, UbuntuIcon, UndoIcon, UnfoldIcon, UnlockIcon, UnpinIcon, UploadIcon, UserAddIcon, UserAltIcon, UserIcon, UsersIcon, VSCodeIcon, VerifiedIcon, VideoIcon, WandIcon, WatchIcon, WindowsIcon, WrenchIcon, XIcon, YoutubeIcon, ZoomIcon, ZoomOutIcon, ZoomResetIcon, iconList, init_icons = __esm({
    "global-externals:@storybook/icons"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      icons_default = __STORYBOOK_ICONS__, { AccessibilityAltIcon, AccessibilityIcon, AccessibilityIgnoredIcon, AddIcon, AdminIcon, AlertAltIcon, AlertIcon, AlignLeftIcon, AlignRightIcon, AppleIcon, ArrowBottomLeftIcon, ArrowBottomRightIcon, ArrowDownIcon, ArrowLeftIcon, ArrowRightIcon, ArrowSolidDownIcon, ArrowSolidLeftIcon, ArrowSolidRightIcon, ArrowSolidUpIcon, ArrowTopLeftIcon, ArrowTopRightIcon, ArrowUpIcon, AzureDevOpsIcon, BackIcon, BasketIcon, BatchAcceptIcon, BatchDenyIcon, BeakerIcon, BellIcon, BitbucketIcon, BoldIcon, BookIcon, BookmarkHollowIcon, BookmarkIcon, BottomBarIcon, BottomBarToggleIcon, BoxIcon, BranchIcon, BrowserIcon, BugIcon, ButtonIcon, CPUIcon, CalendarIcon, CameraIcon, CameraStabilizeIcon, CategoryIcon, CertificateIcon, ChangedIcon, ChatIcon, CheckIcon, ChevronDownIcon, ChevronLeftIcon, ChevronRightIcon, ChevronSmallDownIcon, ChevronSmallLeftIcon, ChevronSmallRightIcon, ChevronSmallUpIcon, ChevronUpIcon, ChromaticIcon, ChromeIcon, CircleHollowIcon, CircleIcon, ClearIcon, CloseAltIcon, CloseIcon, CloudHollowIcon, CloudIcon, CogIcon, CollapseIcon, CommandIcon, CommentAddIcon, CommentIcon, CommentsIcon, CommitIcon, CompassIcon, ComponentDrivenIcon, ComponentIcon, ContrastIcon, ContrastIgnoredIcon, ControlsIcon, CopyIcon, CreditIcon, CrossIcon, DashboardIcon, DatabaseIcon, DeleteIcon, DiamondIcon, DirectionIcon, DiscordIcon, DocChartIcon, DocListIcon, DocumentIcon, DownloadIcon, DragIcon, EditIcon, EditorIcon, EllipsisIcon, EmailIcon, ExpandAltIcon, ExpandIcon, EyeCloseIcon, EyeIcon, FaceHappyIcon, FaceNeutralIcon, FaceSadIcon, FacebookIcon, FailedIcon, FastForwardIcon, FigmaIcon, FilterIcon, FlagIcon, FolderIcon, FormIcon, GDriveIcon, GiftIcon, GithubIcon, GitlabIcon, GlobeIcon, GoogleIcon, GraphBarIcon, GraphLineIcon, GraphqlIcon, GridAltIcon, GridIcon, GrowIcon, HeartHollowIcon, HeartIcon, HomeIcon, HourglassIcon, InfoIcon, ItalicIcon, JumpToIcon, KeyIcon, LightningIcon, LightningOffIcon, LinkBrokenIcon, LinkIcon, LinkedinIcon, LinuxIcon, ListOrderedIcon, ListUnorderedIcon, LocationIcon, LockIcon, MarkdownIcon, MarkupIcon, MediumIcon, MemoryIcon, MenuIcon, MergeIcon, MirrorIcon, MobileIcon, MoonIcon, NutIcon, OutboxIcon, OutlineIcon, PaintBrushAltIcon, PaintBrushIcon, PaperClipIcon, ParagraphIcon, PassedIcon, PhoneIcon, PhotoDragIcon, PhotoIcon, PhotoStabilizeIcon, PinAltIcon, PinIcon, PlayAllHollowIcon, PlayBackIcon, PlayHollowIcon, PlayIcon, PlayNextIcon, PlusIcon, PointerDefaultIcon, PointerHandIcon, PowerIcon, PrintIcon, ProceedIcon, ProfileIcon, PullRequestIcon, QuestionIcon, RSSIcon, RedirectIcon, ReduxIcon, RefreshIcon, ReplyIcon, RepoIcon, RequestChangeIcon, RewindIcon, RulerIcon, SaveIcon, SearchIcon, ShareAltIcon, ShareIcon, ShieldIcon, SideBySideIcon, SidebarAltIcon, SidebarAltToggleIcon, SidebarIcon, SidebarToggleIcon, SortDownIcon, SortUpIcon, SpeakerIcon, StackedIcon, StarHollowIcon, StarIcon, StatusFailIcon, StatusIcon, StatusPassIcon, StatusWarnIcon, StickerIcon, StopAltHollowIcon, StopAltIcon, StopIcon, StorybookIcon: StorybookIcon2, StructureIcon, SubtractIcon, SunIcon, SupportIcon, SweepIcon, SwitchAltIcon, SyncIcon, TabletIcon, ThumbsUpIcon, TimeIcon, TimerIcon, TransferIcon, TrashIcon, TwitterIcon, TypeIcon, UbuntuIcon, UndoIcon, UnfoldIcon, UnlockIcon, UnpinIcon, UploadIcon, UserAddIcon, UserAltIcon, UserIcon, UsersIcon, VSCodeIcon, VerifiedIcon, VideoIcon, WandIcon, WatchIcon, WindowsIcon, WrenchIcon, XIcon, YoutubeIcon, ZoomIcon, ZoomOutIcon, ZoomResetIcon, iconList } = __STORYBOOK_ICONS__;
    }
  });

  // global-externals:storybook/theming
  var theming_default, CacheProvider, ClassNames, Global, ThemeProvider, background, color, convert, create, createCache, createGlobal, createReset, css, darken2, ensure, getPreferredColorScheme, ignoreSsrWarning, isPropValid, jsx, keyframes, lighten2, styled, themes, tokens, typography, useTheme, withTheme, init_theming = __esm({
    "global-externals:storybook/theming"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      theming_default = __STORYBOOK_THEMING__, { CacheProvider, ClassNames, Global, ThemeProvider, background, color, convert, create, createCache, createGlobal, createReset, css, darken: darken2, ensure, getPreferredColorScheme, ignoreSsrWarning, isPropValid, jsx, keyframes, lighten: lighten2, styled, themes, tokens, typography, useTheme, withTheme } = __STORYBOOK_THEMING__;
    }
  });

  // node_modules/storybook/dist/_browser-chunks/chunk-NZMVUW5T.js
  var init_chunk_NZMVUW5T = __esm({
    "node_modules/storybook/dist/_browser-chunks/chunk-NZMVUW5T.js"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
    }
  });

  // node_modules/storybook/dist/_browser-chunks/chunk-VIJ7SQRO.js
  var require_color_name, require_conversions, require_route, require_color_convert, init_chunk_VIJ7SQRO = __esm({
    "node_modules/storybook/dist/_browser-chunks/chunk-VIJ7SQRO.js"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      init_chunk_A242L54C();
      require_color_name = __commonJS({
        "../../node_modules/color-name/index.js"(exports, module) {
          "use strict";
          module.exports = {
            aliceblue: [240, 248, 255],
            antiquewhite: [250, 235, 215],
            aqua: [0, 255, 255],
            aquamarine: [127, 255, 212],
            azure: [240, 255, 255],
            beige: [245, 245, 220],
            bisque: [255, 228, 196],
            black: [0, 0, 0],
            blanchedalmond: [255, 235, 205],
            blue: [0, 0, 255],
            blueviolet: [138, 43, 226],
            brown: [165, 42, 42],
            burlywood: [222, 184, 135],
            cadetblue: [95, 158, 160],
            chartreuse: [127, 255, 0],
            chocolate: [210, 105, 30],
            coral: [255, 127, 80],
            cornflowerblue: [100, 149, 237],
            cornsilk: [255, 248, 220],
            crimson: [220, 20, 60],
            cyan: [0, 255, 255],
            darkblue: [0, 0, 139],
            darkcyan: [0, 139, 139],
            darkgoldenrod: [184, 134, 11],
            darkgray: [169, 169, 169],
            darkgreen: [0, 100, 0],
            darkgrey: [169, 169, 169],
            darkkhaki: [189, 183, 107],
            darkmagenta: [139, 0, 139],
            darkolivegreen: [85, 107, 47],
            darkorange: [255, 140, 0],
            darkorchid: [153, 50, 204],
            darkred: [139, 0, 0],
            darksalmon: [233, 150, 122],
            darkseagreen: [143, 188, 143],
            darkslateblue: [72, 61, 139],
            darkslategray: [47, 79, 79],
            darkslategrey: [47, 79, 79],
            darkturquoise: [0, 206, 209],
            darkviolet: [148, 0, 211],
            deeppink: [255, 20, 147],
            deepskyblue: [0, 191, 255],
            dimgray: [105, 105, 105],
            dimgrey: [105, 105, 105],
            dodgerblue: [30, 144, 255],
            firebrick: [178, 34, 34],
            floralwhite: [255, 250, 240],
            forestgreen: [34, 139, 34],
            fuchsia: [255, 0, 255],
            gainsboro: [220, 220, 220],
            ghostwhite: [248, 248, 255],
            gold: [255, 215, 0],
            goldenrod: [218, 165, 32],
            gray: [128, 128, 128],
            green: [0, 128, 0],
            greenyellow: [173, 255, 47],
            grey: [128, 128, 128],
            honeydew: [240, 255, 240],
            hotpink: [255, 105, 180],
            indianred: [205, 92, 92],
            indigo: [75, 0, 130],
            ivory: [255, 255, 240],
            khaki: [240, 230, 140],
            lavender: [230, 230, 250],
            lavenderblush: [255, 240, 245],
            lawngreen: [124, 252, 0],
            lemonchiffon: [255, 250, 205],
            lightblue: [173, 216, 230],
            lightcoral: [240, 128, 128],
            lightcyan: [224, 255, 255],
            lightgoldenrodyellow: [250, 250, 210],
            lightgray: [211, 211, 211],
            lightgreen: [144, 238, 144],
            lightgrey: [211, 211, 211],
            lightpink: [255, 182, 193],
            lightsalmon: [255, 160, 122],
            lightseagreen: [32, 178, 170],
            lightskyblue: [135, 206, 250],
            lightslategray: [119, 136, 153],
            lightslategrey: [119, 136, 153],
            lightsteelblue: [176, 196, 222],
            lightyellow: [255, 255, 224],
            lime: [0, 255, 0],
            limegreen: [50, 205, 50],
            linen: [250, 240, 230],
            magenta: [255, 0, 255],
            maroon: [128, 0, 0],
            mediumaquamarine: [102, 205, 170],
            mediumblue: [0, 0, 205],
            mediumorchid: [186, 85, 211],
            mediumpurple: [147, 112, 219],
            mediumseagreen: [60, 179, 113],
            mediumslateblue: [123, 104, 238],
            mediumspringgreen: [0, 250, 154],
            mediumturquoise: [72, 209, 204],
            mediumvioletred: [199, 21, 133],
            midnightblue: [25, 25, 112],
            mintcream: [245, 255, 250],
            mistyrose: [255, 228, 225],
            moccasin: [255, 228, 181],
            navajowhite: [255, 222, 173],
            navy: [0, 0, 128],
            oldlace: [253, 245, 230],
            olive: [128, 128, 0],
            olivedrab: [107, 142, 35],
            orange: [255, 165, 0],
            orangered: [255, 69, 0],
            orchid: [218, 112, 214],
            palegoldenrod: [238, 232, 170],
            palegreen: [152, 251, 152],
            paleturquoise: [175, 238, 238],
            palevioletred: [219, 112, 147],
            papayawhip: [255, 239, 213],
            peachpuff: [255, 218, 185],
            peru: [205, 133, 63],
            pink: [255, 192, 203],
            plum: [221, 160, 221],
            powderblue: [176, 224, 230],
            purple: [128, 0, 128],
            rebeccapurple: [102, 51, 153],
            red: [255, 0, 0],
            rosybrown: [188, 143, 143],
            royalblue: [65, 105, 225],
            saddlebrown: [139, 69, 19],
            salmon: [250, 128, 114],
            sandybrown: [244, 164, 96],
            seagreen: [46, 139, 87],
            seashell: [255, 245, 238],
            sienna: [160, 82, 45],
            silver: [192, 192, 192],
            skyblue: [135, 206, 235],
            slateblue: [106, 90, 205],
            slategray: [112, 128, 144],
            slategrey: [112, 128, 144],
            snow: [255, 250, 250],
            springgreen: [0, 255, 127],
            steelblue: [70, 130, 180],
            tan: [210, 180, 140],
            teal: [0, 128, 128],
            thistle: [216, 191, 216],
            tomato: [255, 99, 71],
            turquoise: [64, 224, 208],
            violet: [238, 130, 238],
            wheat: [245, 222, 179],
            white: [255, 255, 255],
            whitesmoke: [245, 245, 245],
            yellow: [255, 255, 0],
            yellowgreen: [154, 205, 50]
          };
        }
      }), require_conversions = __commonJS({
        "../../node_modules/color-convert/conversions.js"(exports, module) {
          var cssKeywords = require_color_name(), reverseKeywords = {};
          for (let key of Object.keys(cssKeywords))
            reverseKeywords[cssKeywords[key]] = key;
          var convert2 = {
            rgb: { channels: 3, labels: "rgb" },
            hsl: { channels: 3, labels: "hsl" },
            hsv: { channels: 3, labels: "hsv" },
            hwb: { channels: 3, labels: "hwb" },
            cmyk: { channels: 4, labels: "cmyk" },
            xyz: { channels: 3, labels: "xyz" },
            lab: { channels: 3, labels: "lab" },
            lch: { channels: 3, labels: "lch" },
            hex: { channels: 1, labels: ["hex"] },
            keyword: { channels: 1, labels: ["keyword"] },
            ansi16: { channels: 1, labels: ["ansi16"] },
            ansi256: { channels: 1, labels: ["ansi256"] },
            hcg: { channels: 3, labels: ["h", "c", "g"] },
            apple: { channels: 3, labels: ["r16", "g16", "b16"] },
            gray: { channels: 1, labels: ["gray"] }
          };
          module.exports = convert2;
          for (let model of Object.keys(convert2)) {
            if (!("channels" in convert2[model]))
              throw new Error("missing channels property: " + model);
            if (!("labels" in convert2[model]))
              throw new Error("missing channel labels property: " + model);
            if (convert2[model].labels.length !== convert2[model].channels)
              throw new Error("channel and label counts mismatch: " + model);
            let { channels, labels } = convert2[model];
            delete convert2[model].channels, delete convert2[model].labels, Object.defineProperty(convert2[model], "channels", { value: channels }), Object.defineProperty(convert2[model], "labels", { value: labels });
          }
          convert2.rgb.hsl = function(rgb2) {
            let r2 = rgb2[0] / 255, g3 = rgb2[1] / 255, b3 = rgb2[2] / 255, min = Math.min(r2, g3, b3), max = Math.max(r2, g3, b3), delta = max - min, h4, s4;
            max === min ? h4 = 0 : r2 === max ? h4 = (g3 - b3) / delta : g3 === max ? h4 = 2 + (b3 - r2) / delta : b3 === max && (h4 = 4 + (r2 - g3) / delta), h4 = Math.min(h4 * 60, 360), h4 < 0 && (h4 += 360);
            let l2 = (min + max) / 2;
            return max === min ? s4 = 0 : l2 <= 0.5 ? s4 = delta / (max + min) : s4 = delta / (2 - max - min), [h4, s4 * 100, l2 * 100];
          }, convert2.rgb.hsv = function(rgb2) {
            let rdif, gdif, bdif, h4, s4, r2 = rgb2[0] / 255, g3 = rgb2[1] / 255, b3 = rgb2[2] / 255, v3 = Math.max(r2, g3, b3), diff2 = v3 - Math.min(r2, g3, b3), diffc = function(c3) {
              return (v3 - c3) / 6 / diff2 + 1 / 2;
            };
            return diff2 === 0 ? (h4 = 0, s4 = 0) : (s4 = diff2 / v3, rdif = diffc(r2), gdif = diffc(g3), bdif = diffc(b3), r2 === v3 ? h4 = bdif - gdif : g3 === v3 ? h4 = 1 / 3 + rdif - bdif : b3 === v3 && (h4 = 2 / 3 + gdif - rdif), h4 < 0 ? h4 += 1 : h4 > 1 && (h4 -= 1)), [
              h4 * 360,
              s4 * 100,
              v3 * 100
            ];
          }, convert2.rgb.hwb = function(rgb2) {
            let r2 = rgb2[0], g3 = rgb2[1], b3 = rgb2[2], h4 = convert2.rgb.hsl(rgb2)[0], w3 = 1 / 255 * Math.min(r2, Math.min(g3, b3));
            return b3 = 1 - 1 / 255 * Math.max(r2, Math.max(g3, b3)), [h4, w3 * 100, b3 * 100];
          }, convert2.rgb.cmyk = function(rgb2) {
            let r2 = rgb2[0] / 255, g3 = rgb2[1] / 255, b3 = rgb2[2] / 255, k3 = Math.min(1 - r2, 1 - g3, 1 - b3), c3 = (1 - r2 - k3) / (1 - k3) || 0, m3 = (1 - g3 - k3) / (1 - k3) || 0, y3 = (1 - b3 - k3) / (1 - k3) || 0;
            return [c3 * 100, m3 * 100, y3 * 100, k3 * 100];
          };
          function comparativeDistance(x3, y3) {
            return (x3[0] - y3[0]) ** 2 + (x3[1] - y3[1]) ** 2 + (x3[2] - y3[2]) ** 2;
          }
          convert2.rgb.keyword = function(rgb2) {
            let reversed = reverseKeywords[rgb2];
            if (reversed)
              return reversed;
            let currentClosestDistance = 1 / 0, currentClosestKeyword;
            for (let keyword of Object.keys(cssKeywords)) {
              let value2 = cssKeywords[keyword], distance = comparativeDistance(rgb2, value2);
              distance < currentClosestDistance && (currentClosestDistance = distance, currentClosestKeyword = keyword);
            }
            return currentClosestKeyword;
          }, convert2.keyword.rgb = function(keyword) {
            return cssKeywords[keyword];
          }, convert2.rgb.xyz = function(rgb2) {
            let r2 = rgb2[0] / 255, g3 = rgb2[1] / 255, b3 = rgb2[2] / 255;
            r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92, g3 = g3 > 0.04045 ? ((g3 + 0.055) / 1.055) ** 2.4 : g3 / 12.92, b3 = b3 > 0.04045 ? ((b3 + 0.055) / 1.055) ** 2.4 : b3 / 12.92;
            let x3 = r2 * 0.4124 + g3 * 0.3576 + b3 * 0.1805, y3 = r2 * 0.2126 + g3 * 0.7152 + b3 * 0.0722, z3 = r2 * 0.0193 + g3 * 0.1192 + b3 * 0.9505;
            return [x3 * 100, y3 * 100, z3 * 100];
          }, convert2.rgb.lab = function(rgb2) {
            let xyz = convert2.rgb.xyz(rgb2), x3 = xyz[0], y3 = xyz[1], z3 = xyz[2];
            x3 /= 95.047, y3 /= 100, z3 /= 108.883, x3 = x3 > 8856e-6 ? x3 ** (1 / 3) : 7.787 * x3 + 16 / 116, y3 = y3 > 8856e-6 ? y3 ** (1 / 3) : 7.787 * y3 + 16 / 116, z3 = z3 > 8856e-6 ? z3 ** (1 / 3) : 7.787 * z3 + 16 / 116;
            let l2 = 116 * y3 - 16, a3 = 500 * (x3 - y3), b3 = 200 * (y3 - z3);
            return [l2, a3, b3];
          }, convert2.hsl.rgb = function(hsl2) {
            let h4 = hsl2[0] / 360, s4 = hsl2[1] / 100, l2 = hsl2[2] / 100, t2, t3, val;
            if (s4 === 0)
              return val = l2 * 255, [val, val, val];
            l2 < 0.5 ? t2 = l2 * (1 + s4) : t2 = l2 + s4 - l2 * s4;
            let t1 = 2 * l2 - t2, rgb2 = [0, 0, 0];
            for (let i3 = 0; i3 < 3; i3++)
              t3 = h4 + 1 / 3 * -(i3 - 1), t3 < 0 && t3++, t3 > 1 && t3--, 6 * t3 < 1 ? val = t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? val = t2 : 3 * t3 < 2 ? val = t1 + (t2 - t1) * (2 / 3 - t3) * 6 : val = t1, rgb2[i3] = val * 255;
            return rgb2;
          }, convert2.hsl.hsv = function(hsl2) {
            let h4 = hsl2[0], s4 = hsl2[1] / 100, l2 = hsl2[2] / 100, smin = s4, lmin = Math.max(l2, 0.01);
            l2 *= 2, s4 *= l2 <= 1 ? l2 : 2 - l2, smin *= lmin <= 1 ? lmin : 2 - lmin;
            let v3 = (l2 + s4) / 2, sv = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s4 / (l2 + s4);
            return [h4, sv * 100, v3 * 100];
          }, convert2.hsv.rgb = function(hsv) {
            let h4 = hsv[0] / 60, s4 = hsv[1] / 100, v3 = hsv[2] / 100, hi = Math.floor(h4) % 6, f4 = h4 - Math.floor(h4), p4 = 255 * v3 * (1 - s4), q3 = 255 * v3 * (1 - s4 * f4), t = 255 * v3 * (1 - s4 * (1 - f4));
            switch (v3 *= 255, hi) {
              case 0:
                return [v3, t, p4];
              case 1:
                return [q3, v3, p4];
              case 2:
                return [p4, v3, t];
              case 3:
                return [p4, q3, v3];
              case 4:
                return [t, p4, v3];
              case 5:
                return [v3, p4, q3];
            }
          }, convert2.hsv.hsl = function(hsv) {
            let h4 = hsv[0], s4 = hsv[1] / 100, v3 = hsv[2] / 100, vmin = Math.max(v3, 0.01), sl, l2;
            l2 = (2 - s4) * v3;
            let lmin = (2 - s4) * vmin;
            return sl = s4 * vmin, sl /= lmin <= 1 ? lmin : 2 - lmin, sl = sl || 0, l2 /= 2, [h4, sl * 100, l2 * 100];
          }, convert2.hwb.rgb = function(hwb) {
            let h4 = hwb[0] / 360, wh = hwb[1] / 100, bl = hwb[2] / 100, ratio = wh + bl, f4;
            ratio > 1 && (wh /= ratio, bl /= ratio);
            let i3 = Math.floor(6 * h4), v3 = 1 - bl;
            f4 = 6 * h4 - i3, (i3 & 1) !== 0 && (f4 = 1 - f4);
            let n2 = wh + f4 * (v3 - wh), r2, g3, b3;
            switch (i3) {
              default:
              case 6:
              case 0:
                r2 = v3, g3 = n2, b3 = wh;
                break;
              case 1:
                r2 = n2, g3 = v3, b3 = wh;
                break;
              case 2:
                r2 = wh, g3 = v3, b3 = n2;
                break;
              case 3:
                r2 = wh, g3 = n2, b3 = v3;
                break;
              case 4:
                r2 = n2, g3 = wh, b3 = v3;
                break;
              case 5:
                r2 = v3, g3 = wh, b3 = n2;
                break;
            }
            return [r2 * 255, g3 * 255, b3 * 255];
          }, convert2.cmyk.rgb = function(cmyk) {
            let c3 = cmyk[0] / 100, m3 = cmyk[1] / 100, y3 = cmyk[2] / 100, k3 = cmyk[3] / 100, r2 = 1 - Math.min(1, c3 * (1 - k3) + k3), g3 = 1 - Math.min(1, m3 * (1 - k3) + k3), b3 = 1 - Math.min(1, y3 * (1 - k3) + k3);
            return [r2 * 255, g3 * 255, b3 * 255];
          }, convert2.xyz.rgb = function(xyz) {
            let x3 = xyz[0] / 100, y3 = xyz[1] / 100, z3 = xyz[2] / 100, r2, g3, b3;
            return r2 = x3 * 3.2406 + y3 * -1.5372 + z3 * -0.4986, g3 = x3 * -0.9689 + y3 * 1.8758 + z3 * 0.0415, b3 = x3 * 0.0557 + y3 * -0.204 + z3 * 1.057, r2 = r2 > 31308e-7 ? 1.055 * r2 ** (1 / 2.4) - 0.055 : r2 * 12.92, g3 = g3 > 31308e-7 ? 1.055 * g3 ** (1 / 2.4) - 0.055 : g3 * 12.92, b3 = b3 > 31308e-7 ? 1.055 * b3 ** (1 / 2.4) - 0.055 : b3 * 12.92, r2 = Math.min(Math.max(0, r2), 1), g3 = Math.min(Math.max(0, g3), 1), b3 = Math.min(Math.max(0, b3), 1), [r2 * 255, g3 * 255, b3 * 255];
          }, convert2.xyz.lab = function(xyz) {
            let x3 = xyz[0], y3 = xyz[1], z3 = xyz[2];
            x3 /= 95.047, y3 /= 100, z3 /= 108.883, x3 = x3 > 8856e-6 ? x3 ** (1 / 3) : 7.787 * x3 + 16 / 116, y3 = y3 > 8856e-6 ? y3 ** (1 / 3) : 7.787 * y3 + 16 / 116, z3 = z3 > 8856e-6 ? z3 ** (1 / 3) : 7.787 * z3 + 16 / 116;
            let l2 = 116 * y3 - 16, a3 = 500 * (x3 - y3), b3 = 200 * (y3 - z3);
            return [l2, a3, b3];
          }, convert2.lab.xyz = function(lab) {
            let l2 = lab[0], a3 = lab[1], b3 = lab[2], x3, y3, z3;
            y3 = (l2 + 16) / 116, x3 = a3 / 500 + y3, z3 = y3 - b3 / 200;
            let y22 = y3 ** 3, x22 = x3 ** 3, z22 = z3 ** 3;
            return y3 = y22 > 8856e-6 ? y22 : (y3 - 16 / 116) / 7.787, x3 = x22 > 8856e-6 ? x22 : (x3 - 16 / 116) / 7.787, z3 = z22 > 8856e-6 ? z22 : (z3 - 16 / 116) / 7.787, x3 *= 95.047, y3 *= 100, z3 *= 108.883, [x3, y3, z3];
          }, convert2.lab.lch = function(lab) {
            let l2 = lab[0], a3 = lab[1], b3 = lab[2], h4;
            h4 = Math.atan2(b3, a3) * 360 / 2 / Math.PI, h4 < 0 && (h4 += 360);
            let c3 = Math.sqrt(a3 * a3 + b3 * b3);
            return [l2, c3, h4];
          }, convert2.lch.lab = function(lch) {
            let l2 = lch[0], c3 = lch[1], hr = lch[2] / 360 * 2 * Math.PI, a3 = c3 * Math.cos(hr), b3 = c3 * Math.sin(hr);
            return [l2, a3, b3];
          }, convert2.rgb.ansi16 = function(args, saturation = null) {
            let [r2, g3, b3] = args, value2 = saturation === null ? convert2.rgb.hsv(args)[2] : saturation;
            if (value2 = Math.round(value2 / 50), value2 === 0)
              return 30;
            let ansi = 30 + (Math.round(b3 / 255) << 2 | Math.round(g3 / 255) << 1 | Math.round(r2 / 255));
            return value2 === 2 && (ansi += 60), ansi;
          }, convert2.hsv.ansi16 = function(args) {
            return convert2.rgb.ansi16(convert2.hsv.rgb(args), args[2]);
          }, convert2.rgb.ansi256 = function(args) {
            let r2 = args[0], g3 = args[1], b3 = args[2];
            return r2 === g3 && g3 === b3 ? r2 < 8 ? 16 : r2 > 248 ? 231 : Math.round((r2 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g3 / 255 * 5) + Math.round(b3 / 255 * 5);
          }, convert2.ansi16.rgb = function(args) {
            let color2 = args % 10;
            if (color2 === 0 || color2 === 7)
              return args > 50 && (color2 += 3.5), color2 = color2 / 10.5 * 255, [color2, color2, color2];
            let mult = (~~(args > 50) + 1) * 0.5, r2 = (color2 & 1) * mult * 255, g3 = (color2 >> 1 & 1) * mult * 255, b3 = (color2 >> 2 & 1) * mult * 255;
            return [r2, g3, b3];
          }, convert2.ansi256.rgb = function(args) {
            if (args >= 232) {
              let c3 = (args - 232) * 10 + 8;
              return [c3, c3, c3];
            }
            args -= 16;
            let rem2, r2 = Math.floor(args / 36) / 5 * 255, g3 = Math.floor((rem2 = args % 36) / 6) / 5 * 255, b3 = rem2 % 6 / 5 * 255;
            return [r2, g3, b3];
          }, convert2.rgb.hex = function(args) {
            let string = (((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255)).toString(16).toUpperCase();
            return "000000".substring(string.length) + string;
          }, convert2.hex.rgb = function(args) {
            let match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
            if (!match)
              return [0, 0, 0];
            let colorString = match[0];
            match[0].length === 3 && (colorString = colorString.split("").map((char) => char + char).join(""));
            let integer = parseInt(colorString, 16), r2 = integer >> 16 & 255, g3 = integer >> 8 & 255, b3 = integer & 255;
            return [r2, g3, b3];
          }, convert2.rgb.hcg = function(rgb2) {
            let r2 = rgb2[0] / 255, g3 = rgb2[1] / 255, b3 = rgb2[2] / 255, max = Math.max(Math.max(r2, g3), b3), min = Math.min(Math.min(r2, g3), b3), chroma = max - min, grayscale, hue;
            return chroma < 1 ? grayscale = min / (1 - chroma) : grayscale = 0, chroma <= 0 ? hue = 0 : max === r2 ? hue = (g3 - b3) / chroma % 6 : max === g3 ? hue = 2 + (b3 - r2) / chroma : hue = 4 + (r2 - g3) / chroma, hue /= 6, hue %= 1, [hue * 360, chroma * 100, grayscale * 100];
          }, convert2.hsl.hcg = function(hsl2) {
            let s4 = hsl2[1] / 100, l2 = hsl2[2] / 100, c3 = l2 < 0.5 ? 2 * s4 * l2 : 2 * s4 * (1 - l2), f4 = 0;
            return c3 < 1 && (f4 = (l2 - 0.5 * c3) / (1 - c3)), [hsl2[0], c3 * 100, f4 * 100];
          }, convert2.hsv.hcg = function(hsv) {
            let s4 = hsv[1] / 100, v3 = hsv[2] / 100, c3 = s4 * v3, f4 = 0;
            return c3 < 1 && (f4 = (v3 - c3) / (1 - c3)), [hsv[0], c3 * 100, f4 * 100];
          }, convert2.hcg.rgb = function(hcg) {
            let h4 = hcg[0] / 360, c3 = hcg[1] / 100, g3 = hcg[2] / 100;
            if (c3 === 0)
              return [g3 * 255, g3 * 255, g3 * 255];
            let pure = [0, 0, 0], hi = h4 % 1 * 6, v3 = hi % 1, w3 = 1 - v3, mg = 0;
            switch (Math.floor(hi)) {
              case 0:
                pure[0] = 1, pure[1] = v3, pure[2] = 0;
                break;
              case 1:
                pure[0] = w3, pure[1] = 1, pure[2] = 0;
                break;
              case 2:
                pure[0] = 0, pure[1] = 1, pure[2] = v3;
                break;
              case 3:
                pure[0] = 0, pure[1] = w3, pure[2] = 1;
                break;
              case 4:
                pure[0] = v3, pure[1] = 0, pure[2] = 1;
                break;
              default:
                pure[0] = 1, pure[1] = 0, pure[2] = w3;
            }
            return mg = (1 - c3) * g3, [
              (c3 * pure[0] + mg) * 255,
              (c3 * pure[1] + mg) * 255,
              (c3 * pure[2] + mg) * 255
            ];
          }, convert2.hcg.hsv = function(hcg) {
            let c3 = hcg[1] / 100, g3 = hcg[2] / 100, v3 = c3 + g3 * (1 - c3), f4 = 0;
            return v3 > 0 && (f4 = c3 / v3), [hcg[0], f4 * 100, v3 * 100];
          }, convert2.hcg.hsl = function(hcg) {
            let c3 = hcg[1] / 100, l2 = hcg[2] / 100 * (1 - c3) + 0.5 * c3, s4 = 0;
            return l2 > 0 && l2 < 0.5 ? s4 = c3 / (2 * l2) : l2 >= 0.5 && l2 < 1 && (s4 = c3 / (2 * (1 - l2))), [hcg[0], s4 * 100, l2 * 100];
          }, convert2.hcg.hwb = function(hcg) {
            let c3 = hcg[1] / 100, g3 = hcg[2] / 100, v3 = c3 + g3 * (1 - c3);
            return [hcg[0], (v3 - c3) * 100, (1 - v3) * 100];
          }, convert2.hwb.hcg = function(hwb) {
            let w3 = hwb[1] / 100, v3 = 1 - hwb[2] / 100, c3 = v3 - w3, g3 = 0;
            return c3 < 1 && (g3 = (v3 - c3) / (1 - c3)), [hwb[0], c3 * 100, g3 * 100];
          }, convert2.apple.rgb = function(apple) {
            return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
          }, convert2.rgb.apple = function(rgb2) {
            return [rgb2[0] / 255 * 65535, rgb2[1] / 255 * 65535, rgb2[2] / 255 * 65535];
          }, convert2.gray.rgb = function(args) {
            return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
          }, convert2.gray.hsl = function(args) {
            return [0, 0, args[0]];
          }, convert2.gray.hsv = convert2.gray.hsl, convert2.gray.hwb = function(gray) {
            return [0, 100, gray[0]];
          }, convert2.gray.cmyk = function(gray) {
            return [0, 0, 0, gray[0]];
          }, convert2.gray.lab = function(gray) {
            return [gray[0], 0, 0];
          }, convert2.gray.hex = function(gray) {
            let val = Math.round(gray[0] / 100 * 255) & 255, string = ((val << 16) + (val << 8) + val).toString(16).toUpperCase();
            return "000000".substring(string.length) + string;
          }, convert2.rgb.gray = function(rgb2) {
            return [(rgb2[0] + rgb2[1] + rgb2[2]) / 3 / 255 * 100];
          };
        }
      }), require_route = __commonJS({
        "../../node_modules/color-convert/route.js"(exports, module) {
          var conversions = require_conversions();
          function buildGraph() {
            let graph = {}, models = Object.keys(conversions);
            for (let len = models.length, i3 = 0; i3 < len; i3++)
              graph[models[i3]] = {
                // http://jsperf.com/1-vs-infinity
                // micro-opt, but this is simple.
                distance: -1,
                parent: null
              };
            return graph;
          }
          function deriveBFS(fromModel) {
            let graph = buildGraph(), queue = [fromModel];
            for (graph[fromModel].distance = 0; queue.length; ) {
              let current = queue.pop(), adjacents = Object.keys(conversions[current]);
              for (let len = adjacents.length, i3 = 0; i3 < len; i3++) {
                let adjacent = adjacents[i3], node = graph[adjacent];
                node.distance === -1 && (node.distance = graph[current].distance + 1, node.parent = current, queue.unshift(adjacent));
              }
            }
            return graph;
          }
          function link(from, to) {
            return function(args) {
              return to(from(args));
            };
          }
          function wrapConversion(toModel, graph) {
            let path = [graph[toModel].parent, toModel], fn2 = conversions[graph[toModel].parent][toModel], cur = graph[toModel].parent;
            for (; graph[cur].parent; )
              path.unshift(graph[cur].parent), fn2 = link(conversions[graph[cur].parent][cur], fn2), cur = graph[cur].parent;
            return fn2.conversion = path, fn2;
          }
          module.exports = function(fromModel) {
            let graph = deriveBFS(fromModel), conversion = {}, models = Object.keys(graph);
            for (let len = models.length, i3 = 0; i3 < len; i3++) {
              let toModel = models[i3];
              graph[toModel].parent !== null && (conversion[toModel] = wrapConversion(toModel, graph));
            }
            return conversion;
          };
        }
      }), require_color_convert = __commonJS({
        "../../node_modules/color-convert/index.js"(exports, module) {
          var conversions = require_conversions(), route = require_route(), convert2 = {}, models = Object.keys(conversions);
          function wrapRaw(fn2) {
            let wrappedFn = function(...args) {
              let arg0 = args[0];
              return arg0 == null ? arg0 : (arg0.length > 1 && (args = arg0), fn2(args));
            };
            return "conversion" in fn2 && (wrappedFn.conversion = fn2.conversion), wrappedFn;
          }
          function wrapRounded(fn2) {
            let wrappedFn = function(...args) {
              let arg0 = args[0];
              if (arg0 == null)
                return arg0;
              arg0.length > 1 && (args = arg0);
              let result = fn2(args);
              if (typeof result == "object")
                for (let len = result.length, i3 = 0; i3 < len; i3++)
                  result[i3] = Math.round(result[i3]);
              return result;
            };
            return "conversion" in fn2 && (wrappedFn.conversion = fn2.conversion), wrappedFn;
          }
          models.forEach((fromModel) => {
            convert2[fromModel] = {}, Object.defineProperty(convert2[fromModel], "channels", { value: conversions[fromModel].channels }), Object.defineProperty(convert2[fromModel], "labels", { value: conversions[fromModel].labels });
            let routes = route(fromModel);
            Object.keys(routes).forEach((toModel) => {
              let fn2 = routes[toModel];
              convert2[fromModel][toModel] = wrapRounded(fn2), convert2[fromModel][toModel].raw = wrapRaw(fn2);
            });
          }), module.exports = convert2;
        }
      });
    }
  });

  // node_modules/storybook/dist/_browser-chunks/Color-XESOIGZP.js
  var Color_XESOIGZP_exports = {};
  __export(Color_XESOIGZP_exports, {
    ColorControl: () => ColorControl,
    default: () => Color_default
  });
  function debounce(func, debounceMs, { signal, edges } = {}) {
    let pendingThis, pendingArgs = null, leading = edges != null && edges.includes("leading"), trailing = edges == null || edges.includes("trailing"), invoke = () => {
      pendingArgs !== null && (func.apply(pendingThis, pendingArgs), pendingThis = void 0, pendingArgs = null);
    }, onTimerEnd = () => {
      trailing && invoke(), cancel();
    }, timeoutId = null, schedule = () => {
      timeoutId != null && clearTimeout(timeoutId), timeoutId = setTimeout(() => {
        timeoutId = null, onTimerEnd();
      }, debounceMs);
    }, cancelTimer = () => {
      timeoutId !== null && (clearTimeout(timeoutId), timeoutId = null);
    }, cancel = () => {
      cancelTimer(), pendingThis = void 0, pendingArgs = null;
    }, flush = () => {
      invoke();
    }, debounced = function(...args) {
      if (signal?.aborted)
        return;
      pendingThis = this, pendingArgs = args;
      let isFirstCall = timeoutId == null;
      schedule(), leading && isFirstCall && invoke();
    };
    return debounced.schedule = schedule, debounced.cancel = cancel, debounced.flush = flush, signal?.addEventListener("abort", cancel, { once: !0 }), debounced;
  }
  function partial(func, ...partialArgs) {
    return partialImpl(func, placeholderSymbol, ...partialArgs);
  }
  function partialImpl(func, placeholder, ...partialArgs) {
    let partialed = function(...providedArgs) {
      let providedArgsIndex = 0, substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg), remainingArgs = providedArgs.slice(providedArgsIndex);
      return func.apply(this, substitutedArgs.concat(remainingArgs));
    };
    return func.prototype && (partialed.prototype = Object.create(func.prototype)), partialed;
  }
  function partialRight(func, ...partialArgs) {
    return partialRightImpl(func, placeholderSymbol2, ...partialArgs);
  }
  function partialRightImpl(func, placeholder, ...partialArgs) {
    let partialedRight = function(...providedArgs) {
      let placeholderLength = partialArgs.filter((arg) => arg === placeholder).length, rangeLength = Math.max(providedArgs.length - placeholderLength, 0), remainingArgs = providedArgs.slice(0, rangeLength), providedArgsIndex = rangeLength, substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg);
      return func.apply(this, remainingArgs.concat(substitutedArgs));
    };
    return func.prototype && (partialedRight.prototype = Object.create(func.prototype)), partialedRight;
  }
  function u() {
    return (u = Object.assign || function(e2) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = arguments[r2];
        for (var n2 in t2) Object.prototype.hasOwnProperty.call(t2, n2) && (e2[n2] = t2[n2]);
      }
      return e2;
    }).apply(this, arguments);
  }
  function c(e2, r2) {
    if (e2 == null) return {};
    var t2, n2, o2 = {}, a22 = Object.keys(e2);
    for (n2 = 0; n2 < a22.length; n2++) r2.indexOf(t2 = a22[n2]) >= 0 || (o2[t2] = e2[t2]);
    return o2;
  }
  function i(e2) {
    var t2 = useRef(e2), n2 = useRef(function(e3) {
      t2.current && t2.current(e3);
    });
    return t2.current = e2, n2.current;
  }
  function Y(e2, t2, l2) {
    var u22 = i(l2), c22 = useState(function() {
      return e2.toHsva(t2);
    }), s22 = c22[0], f22 = c22[1], v22 = useRef({ color: t2, hsva: s22 });
    useEffect(function() {
      if (!e2.equal(t2, v22.current.color)) {
        var r2 = e2.toHsva(t2);
        v22.current = { hsva: r2, color: t2 }, f22(r2);
      }
    }, [t2, e2]), useEffect(function() {
      var r2;
      F(s22, v22.current.hsva) || e2.equal(r2 = e2.fromHsva(s22), v22.current.color) || (v22.current = { hsva: s22, color: r2 }, u22(r2));
    }, [s22, e2, u22]);
    var d22 = useCallback(function(e3) {
      f22(function(r2) {
        return Object.assign({}, r2, e3);
      });
    }, []);
    return [s22, d22];
  }
  var import_color_convert, placeholderSymbol, placeholderSymbol2, DEFAULT_RETRIES, s2, f2, v, d, h2, m, g, p2, b, _, x, C2, E, H, N, w, y, q, k, I, z, D, K, L, S, T, F, P2, X, R, V, $, J, Q, U, W, Z, ee, re, le, ue, Ee, He, Wrapper, TooltipContent, Swatches, swatchBackground, SwatchColor, Input, PopoverTrigger, CycleColorSpaceButton, ColorSpace, COLOR_SPACES, COLOR_REGEXP, RGB_REGEXP, HSL_REGEXP, HEX_REGEXP, SHORTHEX_REGEXP, ColorPicker, fallbackColor, stringToArgs, parseRgb, parseHsl, parseHexOrKeyword, parseValue, getRealValue, useColorInput, id, usePresets, ColorControl, Color_default, init_Color_XESOIGZP = __esm({
    "node_modules/storybook/dist/_browser-chunks/Color-XESOIGZP.js"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      init_chunk_2FRVAXCZ();
      init_chunk_VIJ7SQRO();
      init_chunk_NZMVUW5T();
      init_chunk_A242L54C();
      init_react();
      init_components();
      init_icons();
      init_react();
      init_theming();
      import_color_convert = __toESM(require_color_convert(), 1);
      placeholderSymbol = /* @__PURE__ */ Symbol("partial.placeholder");
      partial.placeholder = placeholderSymbol;
      placeholderSymbol2 = /* @__PURE__ */ Symbol("partialRight.placeholder");
      partialRight.placeholder = placeholderSymbol2;
      DEFAULT_RETRIES = Number.POSITIVE_INFINITY;
      s2 = function(e2, r2, t2) {
        return r2 === void 0 && (r2 = 0), t2 === void 0 && (t2 = 1), e2 > t2 ? t2 : e2 < r2 ? r2 : e2;
      }, f2 = function(e2) {
        return "touches" in e2;
      }, v = function(e2) {
        return e2 && e2.ownerDocument.defaultView || self;
      }, d = function(e2, r2, t2) {
        var n2 = e2.getBoundingClientRect(), o2 = f2(r2) ? (function(e3, r3) {
          for (var t3 = 0; t3 < e3.length; t3++) if (e3[t3].identifier === r3) return e3[t3];
          return e3[0];
        })(r2.touches, t2) : r2;
        return { left: s2((o2.pageX - (n2.left + v(e2).pageXOffset)) / n2.width), top: s2((o2.pageY - (n2.top + v(e2).pageYOffset)) / n2.height) };
      }, h2 = function(e2) {
        !f2(e2) && e2.preventDefault();
      }, m = react_default.memo(function(o2) {
        var a22 = o2.onMove, l2 = o2.onKey, s22 = c(o2, ["onMove", "onKey"]), m22 = useRef(null), g22 = i(a22), p22 = i(l2), b22 = useRef(null), _22 = useRef(!1), x22 = useMemo(function() {
          var e2 = function(e3) {
            h2(e3), (f2(e3) ? e3.touches.length > 0 : e3.buttons > 0) && m22.current ? g22(d(m22.current, e3, b22.current)) : t2(!1);
          }, r2 = function() {
            return t2(!1);
          };
          function t2(t3) {
            var n2 = _22.current, o3 = v(m22.current), a3 = t3 ? o3.addEventListener : o3.removeEventListener;
            a3(n2 ? "touchmove" : "mousemove", e2), a3(n2 ? "touchend" : "mouseup", r2);
          }
          return [function(e3) {
            var r3 = e3.nativeEvent, n2 = m22.current;
            if (n2 && (h2(r3), !(function(e4, r4) {
              return r4 && !f2(e4);
            })(r3, _22.current) && n2)) {
              if (f2(r3)) {
                _22.current = !0;
                var o3 = r3.changedTouches || [];
                o3.length && (b22.current = o3[0].identifier);
              }
              n2.focus(), g22(d(n2, r3, b22.current)), t2(!0);
            }
          }, function(e3) {
            var r3 = e3.which || e3.keyCode;
            r3 < 37 || r3 > 40 || (e3.preventDefault(), p22({ left: r3 === 39 ? 0.05 : r3 === 37 ? -0.05 : 0, top: r3 === 40 ? 0.05 : r3 === 38 ? -0.05 : 0 }));
          }, t2];
        }, [p22, g22]), C22 = x22[0], E22 = x22[1], H22 = x22[2];
        return useEffect(function() {
          return H22;
        }, [H22]), react_default.createElement("div", u({}, s22, { onTouchStart: C22, onMouseDown: C22, className: "react-colorful__interactive", ref: m22, onKeyDown: E22, tabIndex: 0, role: "slider" }));
      }), g = function(e2) {
        return e2.filter(Boolean).join(" ");
      }, p2 = function(r2) {
        var t2 = r2.color, n2 = r2.left, o2 = r2.top, a22 = o2 === void 0 ? 0.5 : o2, l2 = g(["react-colorful__pointer", r2.className]);
        return react_default.createElement("div", { className: l2, style: { top: 100 * a22 + "%", left: 100 * n2 + "%" } }, react_default.createElement("div", { className: "react-colorful__pointer-fill", style: { backgroundColor: t2 } }));
      }, b = function(e2, r2, t2) {
        return r2 === void 0 && (r2 = 0), t2 === void 0 && (t2 = Math.pow(10, r2)), Math.round(t2 * e2) / t2;
      }, _ = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, x = function(e2) {
        return L(C2(e2));
      }, C2 = function(e2) {
        return e2[0] === "#" && (e2 = e2.substring(1)), e2.length < 6 ? { r: parseInt(e2[0] + e2[0], 16), g: parseInt(e2[1] + e2[1], 16), b: parseInt(e2[2] + e2[2], 16), a: e2.length === 4 ? b(parseInt(e2[3] + e2[3], 16) / 255, 2) : 1 } : { r: parseInt(e2.substring(0, 2), 16), g: parseInt(e2.substring(2, 4), 16), b: parseInt(e2.substring(4, 6), 16), a: e2.length === 8 ? b(parseInt(e2.substring(6, 8), 16) / 255, 2) : 1 };
      }, E = function(e2, r2) {
        return r2 === void 0 && (r2 = "deg"), Number(e2) * (_[r2] || 1);
      }, H = function(e2) {
        var r2 = /hsla?\(?\s*(-?\d*\.?\d+)(deg|rad|grad|turn)?[,\s]+(-?\d*\.?\d+)%?[,\s]+(-?\d*\.?\d+)%?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i.exec(e2);
        return r2 ? N({ h: E(r2[1], r2[2]), s: Number(r2[3]), l: Number(r2[4]), a: r2[5] === void 0 ? 1 : Number(r2[5]) / (r2[6] ? 100 : 1) }) : { h: 0, s: 0, v: 0, a: 1 };
      }, N = function(e2) {
        var r2 = e2.s, t2 = e2.l;
        return { h: e2.h, s: (r2 *= (t2 < 50 ? t2 : 100 - t2) / 100) > 0 ? 2 * r2 / (t2 + r2) * 100 : 0, v: t2 + r2, a: e2.a };
      }, w = function(e2) {
        return K(I(e2));
      }, y = function(e2) {
        var r2 = e2.s, t2 = e2.v, n2 = e2.a, o2 = (200 - r2) * t2 / 100;
        return { h: b(e2.h), s: b(o2 > 0 && o2 < 200 ? r2 * t2 / 100 / (o2 <= 100 ? o2 : 200 - o2) * 100 : 0), l: b(o2 / 2), a: b(n2, 2) };
      }, q = function(e2) {
        var r2 = y(e2);
        return "hsl(" + r2.h + ", " + r2.s + "%, " + r2.l + "%)";
      }, k = function(e2) {
        var r2 = y(e2);
        return "hsla(" + r2.h + ", " + r2.s + "%, " + r2.l + "%, " + r2.a + ")";
      }, I = function(e2) {
        var r2 = e2.h, t2 = e2.s, n2 = e2.v, o2 = e2.a;
        r2 = r2 / 360 * 6, t2 /= 100, n2 /= 100;
        var a22 = Math.floor(r2), l2 = n2 * (1 - t2), u22 = n2 * (1 - (r2 - a22) * t2), c22 = n2 * (1 - (1 - r2 + a22) * t2), i22 = a22 % 6;
        return { r: b(255 * [n2, u22, l2, l2, c22, n2][i22]), g: b(255 * [c22, n2, n2, u22, l2, l2][i22]), b: b(255 * [l2, l2, c22, n2, n2, u22][i22]), a: b(o2, 2) };
      }, z = function(e2) {
        var r2 = /rgba?\(?\s*(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i.exec(e2);
        return r2 ? L({ r: Number(r2[1]) / (r2[2] ? 100 / 255 : 1), g: Number(r2[3]) / (r2[4] ? 100 / 255 : 1), b: Number(r2[5]) / (r2[6] ? 100 / 255 : 1), a: r2[7] === void 0 ? 1 : Number(r2[7]) / (r2[8] ? 100 : 1) }) : { h: 0, s: 0, v: 0, a: 1 };
      }, D = function(e2) {
        var r2 = e2.toString(16);
        return r2.length < 2 ? "0" + r2 : r2;
      }, K = function(e2) {
        var r2 = e2.r, t2 = e2.g, n2 = e2.b, o2 = e2.a, a22 = o2 < 1 ? D(b(255 * o2)) : "";
        return "#" + D(r2) + D(t2) + D(n2) + a22;
      }, L = function(e2) {
        var r2 = e2.r, t2 = e2.g, n2 = e2.b, o2 = e2.a, a22 = Math.max(r2, t2, n2), l2 = a22 - Math.min(r2, t2, n2), u22 = l2 ? a22 === r2 ? (t2 - n2) / l2 : a22 === t2 ? 2 + (n2 - r2) / l2 : 4 + (r2 - t2) / l2 : 0;
        return { h: b(60 * (u22 < 0 ? u22 + 6 : u22)), s: b(a22 ? l2 / a22 * 100 : 0), v: b(a22 / 255 * 100), a: o2 };
      }, S = react_default.memo(function(r2) {
        var t2 = r2.hue, n2 = r2.onChange, o2 = g(["react-colorful__hue", r2.className]);
        return react_default.createElement("div", { className: o2 }, react_default.createElement(m, { onMove: function(e2) {
          n2({ h: 360 * e2.left });
        }, onKey: function(e2) {
          n2({ h: s2(t2 + 360 * e2.left, 0, 360) });
        }, "aria-label": "Hue", "aria-valuenow": b(t2), "aria-valuemax": "360", "aria-valuemin": "0" }, react_default.createElement(p2, { className: "react-colorful__hue-pointer", left: t2 / 360, color: q({ h: t2, s: 100, v: 100, a: 1 }) })));
      }), T = react_default.memo(function(r2) {
        var t2 = r2.hsva, n2 = r2.onChange, o2 = { backgroundColor: q({ h: t2.h, s: 100, v: 100, a: 1 }) };
        return react_default.createElement("div", { className: "react-colorful__saturation", style: o2 }, react_default.createElement(m, { onMove: function(e2) {
          n2({ s: 100 * e2.left, v: 100 - 100 * e2.top });
        }, onKey: function(e2) {
          n2({ s: s2(t2.s + 100 * e2.left, 0, 100), v: s2(t2.v - 100 * e2.top, 0, 100) });
        }, "aria-label": "Color", "aria-valuetext": "Saturation " + b(t2.s) + "%, Brightness " + b(t2.v) + "%" }, react_default.createElement(p2, { className: "react-colorful__saturation-pointer", top: 1 - t2.v / 100, left: t2.s / 100, color: q(t2) })));
      }), F = function(e2, r2) {
        if (e2 === r2) return !0;
        for (var t2 in e2) if (e2[t2] !== r2[t2]) return !1;
        return !0;
      }, P2 = function(e2, r2) {
        return e2.replace(/\s/g, "") === r2.replace(/\s/g, "");
      }, X = function(e2, r2) {
        return e2.toLowerCase() === r2.toLowerCase() || F(C2(e2), C2(r2));
      };
      V = typeof window < "u" ? useLayoutEffect : useEffect, $ = function() {
        return R || (typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : void 0);
      }, J = /* @__PURE__ */ new Map(), Q = function(e2) {
        V(function() {
          var r2 = e2.current ? e2.current.ownerDocument : document;
          if (r2 !== void 0 && !J.has(r2)) {
            var t2 = r2.createElement("style");
            t2.innerHTML = `.react-colorful{position:relative;display:flex;flex-direction:column;width:200px;height:200px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.react-colorful__saturation{position:relative;flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.react-colorful__alpha-gradient,.react-colorful__pointer-fill{content:"";position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;border-radius:inherit}.react-colorful__alpha-gradient,.react-colorful__saturation{box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}.react-colorful__alpha,.react-colorful__hue{position:relative;height:24px}.react-colorful__hue{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.react-colorful__last-control{border-radius:0 0 8px 8px}.react-colorful__interactive{position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;outline:none;touch-action:none}.react-colorful__pointer{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}.react-colorful__interactive:focus .react-colorful__pointer{transform:translate(-50%,-50%) scale(1.1)}.react-colorful__alpha,.react-colorful__alpha-pointer{background-color:#fff;background-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')}.react-colorful__saturation-pointer{z-index:3}.react-colorful__hue-pointer{z-index:2}`, J.set(r2, t2);
            var n2 = $();
            n2 && t2.setAttribute("nonce", n2), r2.head.appendChild(t2);
          }
        }, []);
      }, U = function(t2) {
        var n2 = t2.className, o2 = t2.colorModel, a22 = t2.color, l2 = a22 === void 0 ? o2.defaultColor : a22, i22 = t2.onChange, s22 = c(t2, ["className", "colorModel", "color", "onChange"]), f22 = useRef(null);
        Q(f22);
        var v22 = Y(o2, l2, i22), d22 = v22[0], h22 = v22[1], m22 = g(["react-colorful", n2]);
        return react_default.createElement("div", u({}, s22, { ref: f22, className: m22 }), react_default.createElement(T, { hsva: d22, onChange: h22 }), react_default.createElement(S, { hue: d22.h, onChange: h22, className: "react-colorful__last-control" }));
      }, W = { defaultColor: "000", toHsva: x, fromHsva: function(e2) {
        return w({ h: e2.h, s: e2.s, v: e2.v, a: 1 });
      }, equal: X }, Z = function(r2) {
        return react_default.createElement(U, u({}, r2, { colorModel: W }));
      }, ee = function(r2) {
        var t2 = r2.className, n2 = r2.hsva, o2 = r2.onChange, a22 = { backgroundImage: "linear-gradient(90deg, " + k(Object.assign({}, n2, { a: 0 })) + ", " + k(Object.assign({}, n2, { a: 1 })) + ")" }, l2 = g(["react-colorful__alpha", t2]), u22 = b(100 * n2.a);
        return react_default.createElement("div", { className: l2 }, react_default.createElement("div", { className: "react-colorful__alpha-gradient", style: a22 }), react_default.createElement(m, { onMove: function(e2) {
          o2({ a: e2.left });
        }, onKey: function(e2) {
          o2({ a: s2(n2.a + e2.left) });
        }, "aria-label": "Alpha", "aria-valuetext": u22 + "%", "aria-valuenow": u22, "aria-valuemin": "0", "aria-valuemax": "100" }, react_default.createElement(p2, { className: "react-colorful__alpha-pointer", left: n2.a, color: k(n2) })));
      }, re = function(t2) {
        var n2 = t2.className, o2 = t2.colorModel, a22 = t2.color, l2 = a22 === void 0 ? o2.defaultColor : a22, i22 = t2.onChange, s22 = c(t2, ["className", "colorModel", "color", "onChange"]), f22 = useRef(null);
        Q(f22);
        var v22 = Y(o2, l2, i22), d22 = v22[0], h22 = v22[1], m22 = g(["react-colorful", n2]);
        return react_default.createElement("div", u({}, s22, { ref: f22, className: m22 }), react_default.createElement(T, { hsva: d22, onChange: h22 }), react_default.createElement(S, { hue: d22.h, onChange: h22 }), react_default.createElement(ee, { hsva: d22, onChange: h22, className: "react-colorful__last-control" }));
      }, le = { defaultColor: "hsla(0, 0%, 0%, 1)", toHsva: H, fromHsva: k, equal: P2 }, ue = function(r2) {
        return react_default.createElement(re, u({}, r2, { colorModel: le }));
      }, Ee = { defaultColor: "rgba(0, 0, 0, 1)", toHsva: z, fromHsva: function(e2) {
        var r2 = I(e2);
        return "rgba(" + r2.r + ", " + r2.g + ", " + r2.b + ", " + r2.a + ")";
      }, equal: P2 }, He = function(r2) {
        return react_default.createElement(re, u({}, r2, { colorModel: Ee }));
      }, Wrapper = styled.div({
        position: "relative",
        maxWidth: 250
      }), TooltipContent = styled.div({
        width: 200,
        margin: 5,
        ".react-colorful__saturation": {
          borderRadius: "4px 4px 0 0"
        },
        ".react-colorful__hue": {
          boxShadow: "inset 0 0 0 1px rgb(0 0 0 / 5%)"
        },
        ".react-colorful__last-control": {
          borderRadius: "0 0 4px 4px"
        }
      }), Swatches = styled.div({
        display: "grid",
        gridTemplateColumns: "repeat(9, 16px)",
        gap: 6,
        padding: 3,
        marginTop: 5,
        width: 200
      }), swatchBackground = (isDark) => `url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity="0.05" fill="${isDark ? "white" : "black"}"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')`, SwatchColor = styled(Button)(
        ({ value: value2, selected, theme: theme3 }) => ({
          width: 16,
          height: 16,
          boxShadow: selected ? `${theme3.appBorderColor} 0 0 0 1px inset, ${theme3.textMutedColor}50 0 0 0 4px` : `${theme3.appBorderColor} 0 0 0 1px inset`,
          border: "none",
          borderRadius: theme3.appBorderRadius,
          "&, &:hover": {
            background: "unset",
            backgroundColor: "unset",
            backgroundImage: `linear-gradient(${value2}, ${value2}), ${swatchBackground(theme3.base === "dark")}`
          }
        })
      ), Input = styled(Form.Input)(({ theme: theme3 }) => ({
        width: "100%",
        paddingLeft: 30,
        paddingRight: 30,
        boxSizing: "border-box",
        fontFamily: theme3.typography.fonts.base,
        '[aria-readonly="true"] > &': {
          background: theme3.base === "light" ? theme3.color.lighter : "transparent"
        }
      })), PopoverTrigger = styled(SwatchColor)(({ disabled }) => ({
        position: "absolute",
        top: 4,
        left: 4,
        zIndex: 1,
        cursor: disabled ? "not-allowed" : "pointer"
      })), CycleColorSpaceButton = styled(Button)(({ theme: theme3 }) => ({
        position: "absolute",
        zIndex: 1,
        top: 6,
        right: 7,
        width: 20,
        height: 20,
        padding: 4,
        boxSizing: "border-box",
        cursor: "pointer",
        color: theme3.input.color
      })), ColorSpace = ((ColorSpace2) => (ColorSpace2.RGB = "rgb", ColorSpace2.HSL = "hsl", ColorSpace2.HEX = "hex", ColorSpace2))(ColorSpace || {}), COLOR_SPACES = Object.values(ColorSpace), COLOR_REGEXP = /\(([0-9]+),\s*([0-9]+)%?,\s*([0-9]+)%?,?\s*([0-9.]+)?\)/, RGB_REGEXP = /^\s*rgba?\(([0-9]+),\s*([0-9]+),\s*([0-9]+),?\s*([0-9.]+)?\)\s*$/i, HSL_REGEXP = /^\s*hsla?\(([0-9]+),\s*([0-9]+)%,\s*([0-9]+)%,?\s*([0-9.]+)?\)\s*$/i, HEX_REGEXP = /^\s*#?([0-9a-f]{3}|[0-9a-f]{6})\s*$/i, SHORTHEX_REGEXP = /^\s*#?([0-9a-f]{3})\s*$/i, ColorPicker = {
        hex: Z,
        rgb: He,
        hsl: ue
      }, fallbackColor = {
        hex: "transparent",
        rgb: "rgba(0, 0, 0, 0)",
        hsl: "hsla(0, 0%, 0%, 0)"
      }, stringToArgs = (value2) => {
        let match = value2?.match(COLOR_REGEXP);
        if (!match)
          return [0, 0, 0, 1];
        let [, x22, y22, z22, a22 = 1] = match;
        return [x22, y22, z22, a22].map(Number);
      }, parseRgb = (value2) => {
        let [r2, g22, b22, a22] = stringToArgs(value2), [h22, s22, l2] = import_color_convert.default.rgb.hsl([r2, g22, b22]) || [0, 0, 0];
        return {
          valid: !0,
          value: value2,
          keyword: import_color_convert.default.rgb.keyword([r2, g22, b22]),
          colorSpace: "rgb",
          rgb: value2,
          hsl: `hsla(${h22}, ${s22}%, ${l2}%, ${a22})`,
          hex: `#${import_color_convert.default.rgb.hex([r2, g22, b22]).toLowerCase()}`
        };
      }, parseHsl = (value2) => {
        let [h22, s22, l2, a22] = stringToArgs(value2), [r2, g22, b22] = import_color_convert.default.hsl.rgb([h22, s22, l2]) || [0, 0, 0];
        return {
          valid: !0,
          value: value2,
          keyword: import_color_convert.default.hsl.keyword([h22, s22, l2]),
          colorSpace: "hsl",
          rgb: `rgba(${r2}, ${g22}, ${b22}, ${a22})`,
          hsl: value2,
          hex: `#${import_color_convert.default.hsl.hex([h22, s22, l2]).toLowerCase()}`
        };
      }, parseHexOrKeyword = (value2) => {
        let plain = value2.replace("#", ""), rgb2 = import_color_convert.default.keyword.rgb(plain) || import_color_convert.default.hex.rgb(plain), hsl2 = import_color_convert.default.rgb.hsl(rgb2), mapped = value2;
        /[^#a-f0-9]/i.test(value2) ? mapped = plain : HEX_REGEXP.test(value2) && (mapped = `#${plain}`);
        let valid = !0;
        if (mapped.startsWith("#"))
          valid = HEX_REGEXP.test(mapped);
        else
          try {
            import_color_convert.default.keyword.hex(mapped);
          } catch {
            valid = !1;
          }
        return {
          valid,
          value: mapped,
          keyword: import_color_convert.default.rgb.keyword(rgb2),
          colorSpace: "hex",
          rgb: `rgba(${rgb2[0]}, ${rgb2[1]}, ${rgb2[2]}, 1)`,
          hsl: `hsla(${hsl2[0]}, ${hsl2[1]}%, ${hsl2[2]}%, 1)`,
          hex: mapped
        };
      }, parseValue = (value2) => {
        if (value2)
          return RGB_REGEXP.test(value2) ? parseRgb(value2) : HSL_REGEXP.test(value2) ? parseHsl(value2) : parseHexOrKeyword(value2);
      }, getRealValue = (value2, color2, colorSpace) => {
        if (!value2 || !color2?.valid)
          return fallbackColor[colorSpace];
        if (colorSpace !== "hex")
          return color2?.[colorSpace] || fallbackColor[colorSpace];
        if (!color2.hex.startsWith("#"))
          try {
            return `#${import_color_convert.default.keyword.hex(color2.hex)}`;
          } catch {
            return fallbackColor.hex;
          }
        let short = color2.hex.match(SHORTHEX_REGEXP);
        if (!short)
          return HEX_REGEXP.test(color2.hex) ? color2.hex : fallbackColor.hex;
        let [r2, g22, b22] = short[1].split("");
        return `#${r2}${r2}${g22}${g22}${b22}${b22}`;
      }, useColorInput = (initialValue, onChange) => {
        let [value2, setValue] = useState(initialValue || ""), [color2, setColor] = useState(() => parseValue(value2)), [colorSpace, setColorSpace] = useState(
          color2?.colorSpace || "hex"
          /* HEX */
        );
        useEffect(() => {
          let nextValue = initialValue || "", nextColor = parseValue(nextValue);
          setValue(nextValue), setColor(nextColor), setColorSpace(
            nextColor?.colorSpace || "hex"
            /* HEX */
          );
        }, [initialValue]);
        let realValue = useMemo(
          () => getRealValue(value2, color2, colorSpace).toLowerCase(),
          [value2, color2, colorSpace]
        ), updateValue = useCallback(
          (update) => {
            let parsed = parseValue(update), v22 = parsed?.value || update || "";
            setValue(v22), v22 === "" && (setColor(void 0), onChange(void 0)), parsed && (setColor(parsed), setColorSpace(parsed.colorSpace), onChange(parsed.value));
          },
          [onChange]
        ), cycleColorSpace = useCallback(() => {
          let nextIndex = (COLOR_SPACES.indexOf(colorSpace) + 1) % COLOR_SPACES.length, nextSpace = COLOR_SPACES[nextIndex];
          setColorSpace(nextSpace);
          let updatedValue = color2?.[nextSpace] || "";
          setValue(updatedValue), onChange(updatedValue);
        }, [color2, colorSpace, onChange]);
        return { value: value2, realValue, updateValue, color: color2, colorSpace, cycleColorSpace };
      }, id = (value2) => value2.replace(/\s*/, "").toLowerCase(), usePresets = (presetColors, currentColor, colorSpace) => {
        let [selectedColors, setSelectedColors] = useState(currentColor?.valid ? [currentColor] : []);
        useEffect(() => {
          currentColor === void 0 && setSelectedColors([]);
        }, [currentColor]);
        let presets = useMemo(() => (presetColors || []).map((preset) => typeof preset == "string" ? parseValue(preset) : preset.title ? { ...parseValue(preset.color), keyword: preset.title } : parseValue(preset.color)).concat(selectedColors).filter(Boolean).slice(-27), [presetColors, selectedColors]), addPreset = useCallback(
          (color2) => {
            color2?.valid && (presets.some(
              (preset) => preset && preset[colorSpace] && id(preset[colorSpace] || "") === id(color2[colorSpace] || "")
            ) || setSelectedColors((arr) => arr.concat(color2)));
          },
          [colorSpace, presets]
        );
        return { presets, addPreset };
      }, ColorControl = ({
        name,
        value: initialValue,
        onChange,
        onFocus,
        onBlur,
        presetColors,
        startOpen = !1,
        argType
      }) => {
        let debouncedOnChange = useCallback(debounce(onChange, 200), [onChange]), { value: value2, realValue, updateValue, color: color2, colorSpace, cycleColorSpace } = useColorInput(
          initialValue,
          debouncedOnChange
        ), { presets, addPreset } = usePresets(presetColors ?? [], color2, colorSpace), Picker = ColorPicker[colorSpace], readOnly = !!argType?.table?.readonly, controlId = getControlId(name);
        return react_default.createElement(Wrapper, null, react_default.createElement("label", { htmlFor: controlId, className: "sb-sr-only" }, name), react_default.createElement(
          Input,
          {
            id: controlId,
            value: value2,
            onChange: (e2) => updateValue(e2.target.value),
            onFocus: (e2) => e2.target.select(),
            readOnly,
            placeholder: "Choose color..."
          }
        ), react_default.createElement(
          PopoverProvider,
          {
            defaultVisible: startOpen,
            visible: readOnly ? !1 : void 0,
            onVisibleChange: () => color2 && addPreset(color2),
            popover: react_default.createElement(TooltipContent, null, react_default.createElement(
              Picker,
              {
                color: realValue === "transparent" ? "#000000" : realValue,
                onChange: updateValue,
                onFocus,
                onBlur
              }
            ), presets.length > 0 && react_default.createElement(Swatches, null, presets.map((preset, index2) => react_default.createElement(
              SwatchColor,
              {
                key: `${preset?.value || index2}-${index2}`,
                variant: "ghost",
                padding: "small",
                size: "small",
                ariaLabel: "Pick this color",
                tooltip: preset?.keyword || preset?.value || "",
                value: preset?.value || "",
                selected: !!(color2 && preset && preset[colorSpace] && id(preset[colorSpace] || "") === id(color2[colorSpace])),
                onClick: () => preset && updateValue(preset.value || "")
              }
            ))))
          },
          react_default.createElement(
            PopoverTrigger,
            {
              variant: "ghost",
              padding: "small",
              size: "small",
              ariaLabel: "Open color picker",
              value: realValue,
              style: { margin: 4 },
              disabled: readOnly
            }
          )
        ), value2 ? react_default.createElement(
          CycleColorSpaceButton,
          {
            variant: "ghost",
            padding: "small",
            size: "small",
            ariaLabel: "Cycle through color spaces",
            disabled: readOnly,
            onClick: readOnly ? void 0 : cycleColorSpace
          },
          react_default.createElement(MarkupIcon, null)
        ) : null);
      }, Color_default = ColorControl;
    }
  });

  // node_modules/.cache/storybook/10.2.8/1c3385a5d25e538d10b518b310c74d3ca2690b6aaffeadccd74da79736171f86/sb-manager/storybook-core-server-presets-0/common-manager-bundle.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/storybook/dist/core-server/presets/common-manager.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_2FRVAXCZ();

  // node_modules/storybook/dist/_browser-chunks/chunk-UAYGIC3L.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/storybook/dist/_browser-chunks/chunk-242VQQM5.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  function _objectWithoutPropertiesLoose(r2, e) {
    if (r2 == null) return {};
    var t = {};
    for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
      if (e.indexOf(n2) !== -1) continue;
      t[n2] = r2[n2];
    }
    return t;
  }

  // node_modules/storybook/dist/_browser-chunks/chunk-UAYGIC3L.js
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o22) {
      return typeof o22;
    } : function(o22) {
      return o22 && typeof Symbol == "function" && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
    }, _typeof(o2);
  }
  function toPrimitive(t, r2) {
    if (_typeof(t) != "object" || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (e !== void 0) {
      var i3 = e.call(t, r2 || "default");
      if (_typeof(i3) != "object") return i3;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r2 === "string" ? String : Number)(t);
  }
  function toPropertyKey(t) {
    var i3 = toPrimitive(t, "string");
    return _typeof(i3) == "symbol" ? i3 : i3 + "";
  }
  function _defineProperty(e, r2, t) {
    return (r2 = toPropertyKey(r2)) in e ? Object.defineProperty(e, r2, {
      value: t,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[r2] = t, e;
  }
  function _objectWithoutProperties(e, t) {
    if (e == null) return {};
    var o2, r2, i3 = _objectWithoutPropertiesLoose(e, t);
    if (Object.getOwnPropertySymbols) {
      var n2 = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], t.indexOf(o2) === -1 && {}.propertyIsEnumerable.call(e, o2) && (i3[o2] = e[o2]);
    }
    return i3;
  }

  // node_modules/storybook/dist/_browser-chunks/chunk-NQJGOFZV.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var has = Object.prototype.hasOwnProperty;
  function find(iter, tar, key) {
    for (key of iter.keys())
      if (dequal(key, tar)) return key;
  }
  function dequal(foo, bar) {
    var ctor, len, tmp;
    if (foo === bar) return !0;
    if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
      if (ctor === Date) return foo.getTime() === bar.getTime();
      if (ctor === RegExp) return foo.toString() === bar.toString();
      if (ctor === Array) {
        if ((len = foo.length) === bar.length)
          for (; len-- && dequal(foo[len], bar[len]); ) ;
        return len === -1;
      }
      if (ctor === Set) {
        if (foo.size !== bar.size)
          return !1;
        for (len of foo)
          if (tmp = len, tmp && typeof tmp == "object" && (tmp = find(bar, tmp), !tmp) || !bar.has(tmp)) return !1;
        return !0;
      }
      if (ctor === Map) {
        if (foo.size !== bar.size)
          return !1;
        for (len of foo)
          if (tmp = len[0], tmp && typeof tmp == "object" && (tmp = find(bar, tmp), !tmp) || !dequal(len[1], bar.get(tmp)))
            return !1;
        return !0;
      }
      if (ctor === ArrayBuffer)
        foo = new Uint8Array(foo), bar = new Uint8Array(bar);
      else if (ctor === DataView) {
        if ((len = foo.byteLength) === bar.byteLength)
          for (; len-- && foo.getInt8(len) === bar.getInt8(len); ) ;
        return len === -1;
      }
      if (ArrayBuffer.isView(foo)) {
        if ((len = foo.byteLength) === bar.byteLength)
          for (; len-- && foo[len] === bar[len]; ) ;
        return len === -1;
      }
      if (!ctor || typeof foo == "object") {
        len = 0;
        for (ctor in foo)
          if (has.call(foo, ctor) && ++len && !has.call(bar, ctor) || !(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return !1;
        return Object.keys(bar).length === len;
      }
    }
    return foo !== foo && bar !== bar;
  }
  function uniq(arr) {
    return [...new Set(arr)];
  }

  // node_modules/storybook/dist/_browser-chunks/chunk-FNXWN6IK.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var ADDON_ID = "storybook/background", PARAM_KEY = "backgrounds", EVENTS = {
    UPDATE: `${ADDON_ID}/update`
  }, ADDON_ID2 = "storybook/measure-addon", TOOL_ID = `${ADDON_ID2}/tool`, PARAM_KEY2 = "measureEnabled", EVENTS2 = {
    RESULT: `${ADDON_ID2}/result`,
    REQUEST: `${ADDON_ID2}/request`,
    CLEAR: `${ADDON_ID2}/clear`
  }, ADDON_ID3 = "storybook/outline", PARAM_KEY3 = "outline", DEFAULT_BACKGROUNDS = {
    light: { name: "light", value: "#F8F8F8" },
    dark: { name: "dark", value: "#333" }
  };

  // node_modules/storybook/dist/_browser-chunks/chunk-S6TK43XQ.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/storybook/dist/_browser-chunks/chunk-LE2LTDW3.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(n2) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n2[r2] = t[r2]);
      }
      return n2;
    }, _extends.apply(null, arguments);
  }

  // node_modules/storybook/dist/_browser-chunks/chunk-S6TK43XQ.js
  function _assertThisInitialized(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
      return t2.__proto__ = e2, t2;
    }, _setPrototypeOf(t, e);
  }
  function _inheritsLoose(t, o2) {
    t.prototype = Object.create(o2.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o2);
  }
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
      return t2.__proto__ || Object.getPrototypeOf(t2);
    }, _getPrototypeOf(t);
  }
  function _isNativeFunction(t) {
    try {
      return Function.toString.call(t).indexOf("[native code]") !== -1;
    } catch {
      return typeof t == "function";
    }
  }
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (_isNativeReflectConstruct = function() {
      return !!t;
    })();
  }
  function _construct(t, e, r2) {
    if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
    var o2 = [null];
    o2.push.apply(o2, e);
    var p4 = new (t.bind.apply(t, o2))();
    return r2 && _setPrototypeOf(p4, r2.prototype), p4;
  }
  function _wrapNativeSuper(t) {
    var r2 = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return _wrapNativeSuper = function(t2) {
      if (t2 === null || !_isNativeFunction(t2)) return t2;
      if (typeof t2 != "function") throw new TypeError("Super expression must either be null or a function");
      if (r2 !== void 0) {
        if (r2.has(t2)) return r2.get(t2);
        r2.set(t2, Wrapper11);
      }
      function Wrapper11() {
        return _construct(t2, arguments, _getPrototypeOf(this).constructor);
      }
      return Wrapper11.prototype = Object.create(t2.prototype, {
        constructor: {
          value: Wrapper11,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }), _setPrototypeOf(Wrapper11, t2);
    }, _wrapNativeSuper(t);
  }
  var ERRORS = {
    1: `Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).

`,
    2: `Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).

`,
    3: `Passed an incorrect argument to a color function, please pass a string representation of a color.

`,
    4: `Couldn't generate valid rgb string from %s, it returned %s.

`,
    5: `Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.

`,
    6: `Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).

`,
    7: `Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).

`,
    8: `Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.

`,
    9: `Please provide a number of steps to the modularScale helper.

`,
    10: `Please pass a number or one of the predefined scales to the modularScale helper as the ratio.

`,
    11: `Invalid value passed as base to modularScale, expected number or em string but got "%s"

`,
    12: `Expected a string ending in "px" or a number passed as the first argument to %s(), got "%s" instead.

`,
    13: `Expected a string ending in "px" or a number passed as the second argument to %s(), got "%s" instead.

`,
    14: `Passed invalid pixel value ("%s") to %s(), please pass a value like "12px" or 12.

`,
    15: `Passed invalid base value ("%s") to %s(), please pass a value like "12px" or 12.

`,
    16: `You must provide a template to this method.

`,
    17: `You passed an unsupported selector state to this method.

`,
    18: `minScreen and maxScreen must be provided as stringified numbers with the same units.

`,
    19: `fromSize and toSize must be provided as stringified numbers with the same units.

`,
    20: `expects either an array of objects or a single object with the properties prop, fromSize, and toSize.

`,
    21: "expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
    22: "expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
    23: `fontFace expects a name of a font-family.

`,
    24: `fontFace expects either the path to the font file(s) or a name of a local copy.

`,
    25: `fontFace expects localFonts to be an array.

`,
    26: `fontFace expects fileFormats to be an array.

`,
    27: `radialGradient requries at least 2 color-stops to properly render.

`,
    28: `Please supply a filename to retinaImage() as the first argument.

`,
    29: `Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.

`,
    30: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
    31: `The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation

`,
    32: `To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])
To pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')

`,
    33: `The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation

`,
    34: `borderRadius expects a radius value as a string or number as the second argument.

`,
    35: `borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.

`,
    36: `Property must be a string value.

`,
    37: `Syntax Error at %s.

`,
    38: `Formula contains a function that needs parentheses at %s.

`,
    39: `Formula is missing closing parenthesis at %s.

`,
    40: `Formula has too many closing parentheses at %s.

`,
    41: `All values in a formula must have the same unit or be unitless.

`,
    42: `Please provide a number of steps to the modularScale helper.

`,
    43: `Please pass a number or one of the predefined scales to the modularScale helper as the ratio.

`,
    44: `Invalid value passed as base to modularScale, expected number or em/rem string but got %s.

`,
    45: `Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.

`,
    46: `Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.

`,
    47: `minScreen and maxScreen must be provided as stringified numbers with the same units.

`,
    48: `fromSize and toSize must be provided as stringified numbers with the same units.

`,
    49: `Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.

`,
    50: `Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.

`,
    51: `Expects the first argument object to have the properties prop, fromSize, and toSize.

`,
    52: `fontFace expects either the path to the font file(s) or a name of a local copy.

`,
    53: `fontFace expects localFonts to be an array.

`,
    54: `fontFace expects fileFormats to be an array.

`,
    55: `fontFace expects a name of a font-family.

`,
    56: `linearGradient requries at least 2 color-stops to properly render.

`,
    57: `radialGradient requries at least 2 color-stops to properly render.

`,
    58: `Please supply a filename to retinaImage() as the first argument.

`,
    59: `Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.

`,
    60: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
    61: `Property must be a string value.

`,
    62: `borderRadius expects a radius value as a string or number as the second argument.

`,
    63: `borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.

`,
    64: `The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.

`,
    65: `To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').

`,
    66: `The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.

`,
    67: `You must provide a template to this method.

`,
    68: `You passed an unsupported selector state to this method.

`,
    69: `Expected a string ending in "px" or a number passed as the first argument to %s(), got %s instead.

`,
    70: `Expected a string ending in "px" or a number passed as the second argument to %s(), got %s instead.

`,
    71: `Passed invalid pixel value %s to %s(), please pass a value like "12px" or 12.

`,
    72: `Passed invalid base value %s to %s(), please pass a value like "12px" or 12.

`,
    73: `Please provide a valid CSS variable.

`,
    74: `CSS variable not found and no default was provided.

`,
    75: `important requires a valid style object, got a %s instead.

`,
    76: `fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.

`,
    77: `remToPx expects a value in "rem" but you provided it in "%s".

`,
    78: `base must be set in "px" or "%" but you set it in "%s".
`
  };
  function format() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    var a3 = args[0], b3 = [], c3;
    for (c3 = 1; c3 < args.length; c3 += 1)
      b3.push(args[c3]);
    return b3.forEach(function(d3) {
      a3 = a3.replace(/%[a-z]/, d3);
    }), a3;
  }
  var PolishedError = (function(_Error) {
    _inheritsLoose(PolishedError2, _Error);
    function PolishedError2(code) {
      for (var _this, _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
        args[_key2 - 1] = arguments[_key2];
      return _this = _Error.call(this, format.apply(void 0, [ERRORS[code]].concat(args))) || this, _assertThisInitialized(_this);
    }
    return PolishedError2;
  })(_wrapNativeSuper(Error));
  function endsWith(string, suffix) {
    return string.substr(-suffix.length) === suffix;
  }
  var cssRegex$1 = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/;
  function stripUnit(value2) {
    if (typeof value2 != "string") return value2;
    var matchedValue = value2.match(cssRegex$1);
    return matchedValue ? parseFloat(value2) : value2;
  }
  var pxtoFactory = function(to) {
    return function(pxval, base) {
      base === void 0 && (base = "16px");
      var newPxval = pxval, newBase = base;
      if (typeof pxval == "string") {
        if (!endsWith(pxval, "px"))
          throw new PolishedError(69, to, pxval);
        newPxval = stripUnit(pxval);
      }
      if (typeof base == "string") {
        if (!endsWith(base, "px"))
          throw new PolishedError(70, to, base);
        newBase = stripUnit(base);
      }
      if (typeof newPxval == "string")
        throw new PolishedError(71, pxval, to);
      if (typeof newBase == "string")
        throw new PolishedError(72, base, to);
      return "" + newPxval / newBase + to;
    };
  }, pixelsto = pxtoFactory, em = pixelsto("em"), rem = pixelsto("rem");
  function colorToInt(color2) {
    return Math.round(color2 * 255);
  }
  function convertToInt(red, green, blue) {
    return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
  }
  function hslToRgb(hue, saturation, lightness, convert2) {
    if (convert2 === void 0 && (convert2 = convertToInt), saturation === 0)
      return convert2(lightness, lightness, lightness);
    var huePrime = (hue % 360 + 360) % 360 / 60, chroma = (1 - Math.abs(2 * lightness - 1)) * saturation, secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1)), red = 0, green = 0, blue = 0;
    huePrime >= 0 && huePrime < 1 ? (red = chroma, green = secondComponent) : huePrime >= 1 && huePrime < 2 ? (red = secondComponent, green = chroma) : huePrime >= 2 && huePrime < 3 ? (green = chroma, blue = secondComponent) : huePrime >= 3 && huePrime < 4 ? (green = secondComponent, blue = chroma) : huePrime >= 4 && huePrime < 5 ? (red = secondComponent, blue = chroma) : huePrime >= 5 && huePrime < 6 && (red = chroma, blue = secondComponent);
    var lightnessModification = lightness - chroma / 2, finalRed = red + lightnessModification, finalGreen = green + lightnessModification, finalBlue = blue + lightnessModification;
    return convert2(finalRed, finalGreen, finalBlue);
  }
  var namedColorMap = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "00ffff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "0000ff",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "00ffff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "ff00ff",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "639",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
  };
  function nameToHex(color2) {
    if (typeof color2 != "string") return color2;
    var normalizedColorName = color2.toLowerCase();
    return namedColorMap[normalizedColorName] ? "#" + namedColorMap[normalizedColorName] : color2;
  }
  var hexRegex = /^#[a-fA-F0-9]{6}$/, hexRgbaRegex = /^#[a-fA-F0-9]{8}$/, reducedHexRegex = /^#[a-fA-F0-9]{3}$/, reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/, rgbRegex = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i, rgbaRegex = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i, hslRegex = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i, hslaRegex = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
  function parseToRgb(color2) {
    if (typeof color2 != "string")
      throw new PolishedError(3);
    var normalizedColor = nameToHex(color2);
    if (normalizedColor.match(hexRegex))
      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
        green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
        blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
      };
    if (normalizedColor.match(hexRgbaRegex)) {
      var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
        green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
        blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
        alpha
      };
    }
    if (normalizedColor.match(reducedHexRegex))
      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
        green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
        blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
      };
    if (normalizedColor.match(reducedRgbaHexRegex)) {
      var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));
      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
        green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
        blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
        alpha: _alpha
      };
    }
    var rgbMatched = rgbRegex.exec(normalizedColor);
    if (rgbMatched)
      return {
        red: parseInt("" + rgbMatched[1], 10),
        green: parseInt("" + rgbMatched[2], 10),
        blue: parseInt("" + rgbMatched[3], 10)
      };
    var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));
    if (rgbaMatched)
      return {
        red: parseInt("" + rgbaMatched[1], 10),
        green: parseInt("" + rgbaMatched[2], 10),
        blue: parseInt("" + rgbaMatched[3], 10),
        alpha: parseFloat("" + rgbaMatched[4]) > 1 ? parseFloat("" + rgbaMatched[4]) / 100 : parseFloat("" + rgbaMatched[4])
      };
    var hslMatched = hslRegex.exec(normalizedColor);
    if (hslMatched) {
      var hue = parseInt("" + hslMatched[1], 10), saturation = parseInt("" + hslMatched[2], 10) / 100, lightness = parseInt("" + hslMatched[3], 10) / 100, rgbColorString = "rgb(" + hslToRgb(hue, saturation, lightness) + ")", hslRgbMatched = rgbRegex.exec(rgbColorString);
      if (!hslRgbMatched)
        throw new PolishedError(4, normalizedColor, rgbColorString);
      return {
        red: parseInt("" + hslRgbMatched[1], 10),
        green: parseInt("" + hslRgbMatched[2], 10),
        blue: parseInt("" + hslRgbMatched[3], 10)
      };
    }
    var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));
    if (hslaMatched) {
      var _hue = parseInt("" + hslaMatched[1], 10), _saturation = parseInt("" + hslaMatched[2], 10) / 100, _lightness = parseInt("" + hslaMatched[3], 10) / 100, _rgbColorString = "rgb(" + hslToRgb(_hue, _saturation, _lightness) + ")", _hslRgbMatched = rgbRegex.exec(_rgbColorString);
      if (!_hslRgbMatched)
        throw new PolishedError(4, normalizedColor, _rgbColorString);
      return {
        red: parseInt("" + _hslRgbMatched[1], 10),
        green: parseInt("" + _hslRgbMatched[2], 10),
        blue: parseInt("" + _hslRgbMatched[3], 10),
        alpha: parseFloat("" + hslaMatched[4]) > 1 ? parseFloat("" + hslaMatched[4]) / 100 : parseFloat("" + hslaMatched[4])
      };
    }
    throw new PolishedError(5);
  }
  function rgbToHsl(color2) {
    var red = color2.red / 255, green = color2.green / 255, blue = color2.blue / 255, max = Math.max(red, green, blue), min = Math.min(red, green, blue), lightness = (max + min) / 2;
    if (max === min)
      return color2.alpha !== void 0 ? {
        hue: 0,
        saturation: 0,
        lightness,
        alpha: color2.alpha
      } : {
        hue: 0,
        saturation: 0,
        lightness
      };
    var hue, delta = max - min, saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);
    switch (max) {
      case red:
        hue = (green - blue) / delta + (green < blue ? 6 : 0);
        break;
      case green:
        hue = (blue - red) / delta + 2;
        break;
      default:
        hue = (red - green) / delta + 4;
        break;
    }
    return hue *= 60, color2.alpha !== void 0 ? {
      hue,
      saturation,
      lightness,
      alpha: color2.alpha
    } : {
      hue,
      saturation,
      lightness
    };
  }
  function parseToHsl(color2) {
    return rgbToHsl(parseToRgb(color2));
  }
  var reduceHexValue = function(value2) {
    return value2.length === 7 && value2[1] === value2[2] && value2[3] === value2[4] && value2[5] === value2[6] ? "#" + value2[1] + value2[3] + value2[5] : value2;
  }, reduceHexValue$1 = reduceHexValue;
  function numberToHex(value2) {
    var hex2 = value2.toString(16);
    return hex2.length === 1 ? "0" + hex2 : hex2;
  }
  function colorToHex(color2) {
    return numberToHex(Math.round(color2 * 255));
  }
  function convertToHex(red, green, blue) {
    return reduceHexValue$1("#" + colorToHex(red) + colorToHex(green) + colorToHex(blue));
  }
  function hslToHex(hue, saturation, lightness) {
    return hslToRgb(hue, saturation, lightness, convertToHex);
  }
  function hsl(value2, saturation, lightness) {
    if (typeof value2 == "number" && typeof saturation == "number" && typeof lightness == "number")
      return hslToHex(value2, saturation, lightness);
    if (typeof value2 == "object" && saturation === void 0 && lightness === void 0)
      return hslToHex(value2.hue, value2.saturation, value2.lightness);
    throw new PolishedError(1);
  }
  function hsla(value2, saturation, lightness, alpha) {
    if (typeof value2 == "number" && typeof saturation == "number" && typeof lightness == "number" && typeof alpha == "number")
      return alpha >= 1 ? hslToHex(value2, saturation, lightness) : "rgba(" + hslToRgb(value2, saturation, lightness) + "," + alpha + ")";
    if (typeof value2 == "object" && saturation === void 0 && lightness === void 0 && alpha === void 0)
      return value2.alpha >= 1 ? hslToHex(value2.hue, value2.saturation, value2.lightness) : "rgba(" + hslToRgb(value2.hue, value2.saturation, value2.lightness) + "," + value2.alpha + ")";
    throw new PolishedError(2);
  }
  function rgb(value2, green, blue) {
    if (typeof value2 == "number" && typeof green == "number" && typeof blue == "number")
      return reduceHexValue$1("#" + numberToHex(value2) + numberToHex(green) + numberToHex(blue));
    if (typeof value2 == "object" && green === void 0 && blue === void 0)
      return reduceHexValue$1("#" + numberToHex(value2.red) + numberToHex(value2.green) + numberToHex(value2.blue));
    throw new PolishedError(6);
  }
  function rgba(firstValue, secondValue, thirdValue, fourthValue) {
    if (typeof firstValue == "string" && typeof secondValue == "number") {
      var rgbValue = parseToRgb(firstValue);
      return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
    } else {
      if (typeof firstValue == "number" && typeof secondValue == "number" && typeof thirdValue == "number" && typeof fourthValue == "number")
        return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
      if (typeof firstValue == "object" && secondValue === void 0 && thirdValue === void 0 && fourthValue === void 0)
        return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
    }
    throw new PolishedError(7);
  }
  var isRgb = function(color2) {
    return typeof color2.red == "number" && typeof color2.green == "number" && typeof color2.blue == "number" && (typeof color2.alpha != "number" || typeof color2.alpha > "u");
  }, isRgba = function(color2) {
    return typeof color2.red == "number" && typeof color2.green == "number" && typeof color2.blue == "number" && typeof color2.alpha == "number";
  }, isHsl = function(color2) {
    return typeof color2.hue == "number" && typeof color2.saturation == "number" && typeof color2.lightness == "number" && (typeof color2.alpha != "number" || typeof color2.alpha > "u");
  }, isHsla = function(color2) {
    return typeof color2.hue == "number" && typeof color2.saturation == "number" && typeof color2.lightness == "number" && typeof color2.alpha == "number";
  };
  function toColorString(color2) {
    if (typeof color2 != "object") throw new PolishedError(8);
    if (isRgba(color2)) return rgba(color2);
    if (isRgb(color2)) return rgb(color2);
    if (isHsla(color2)) return hsla(color2);
    if (isHsl(color2)) return hsl(color2);
    throw new PolishedError(8);
  }
  function curried(f4, length, acc) {
    return function() {
      var combined = acc.concat(Array.prototype.slice.call(arguments));
      return combined.length >= length ? f4.apply(this, combined) : curried(f4, length, combined);
    };
  }
  function curry(f4) {
    return curried(f4, f4.length, []);
  }
  function adjustHue(degree, color2) {
    if (color2 === "transparent") return color2;
    var hslColor = parseToHsl(color2);
    return toColorString(_extends({}, hslColor, {
      hue: hslColor.hue + parseFloat(degree)
    }));
  }
  var curriedAdjustHue = curry(adjustHue);
  function guard(lowerBoundary, upperBoundary, value2) {
    return Math.max(lowerBoundary, Math.min(upperBoundary, value2));
  }
  function darken(amount, color2) {
    if (color2 === "transparent") return color2;
    var hslColor = parseToHsl(color2);
    return toColorString(_extends({}, hslColor, {
      lightness: guard(0, 1, hslColor.lightness - parseFloat(amount))
    }));
  }
  var curriedDarken = curry(darken), curriedDarken$1 = curriedDarken;
  function desaturate(amount, color2) {
    if (color2 === "transparent") return color2;
    var hslColor = parseToHsl(color2);
    return toColorString(_extends({}, hslColor, {
      saturation: guard(0, 1, hslColor.saturation - parseFloat(amount))
    }));
  }
  var curriedDesaturate = curry(desaturate);
  function lighten(amount, color2) {
    if (color2 === "transparent") return color2;
    var hslColor = parseToHsl(color2);
    return toColorString(_extends({}, hslColor, {
      lightness: guard(0, 1, hslColor.lightness + parseFloat(amount))
    }));
  }
  var curriedLighten = curry(lighten), curriedLighten$1 = curriedLighten;
  function mix(weight, color2, otherColor) {
    if (color2 === "transparent") return otherColor;
    if (otherColor === "transparent") return color2;
    if (weight === 0) return otherColor;
    var parsedColor1 = parseToRgb(color2), color1 = _extends({}, parsedColor1, {
      alpha: typeof parsedColor1.alpha == "number" ? parsedColor1.alpha : 1
    }), parsedColor2 = parseToRgb(otherColor), color22 = _extends({}, parsedColor2, {
      alpha: typeof parsedColor2.alpha == "number" ? parsedColor2.alpha : 1
    }), alphaDelta = color1.alpha - color22.alpha, x3 = parseFloat(weight) * 2 - 1, y3 = x3 * alphaDelta === -1 ? x3 : x3 + alphaDelta, z3 = 1 + x3 * alphaDelta, weight1 = (y3 / z3 + 1) / 2, weight2 = 1 - weight1, mixedColor = {
      red: Math.floor(color1.red * weight1 + color22.red * weight2),
      green: Math.floor(color1.green * weight1 + color22.green * weight2),
      blue: Math.floor(color1.blue * weight1 + color22.blue * weight2),
      alpha: color1.alpha * parseFloat(weight) + color22.alpha * (1 - parseFloat(weight))
    };
    return rgba(mixedColor);
  }
  var curriedMix = curry(mix), mix$1 = curriedMix;
  function opacify(amount, color2) {
    if (color2 === "transparent") return color2;
    var parsedColor = parseToRgb(color2), alpha = typeof parsedColor.alpha == "number" ? parsedColor.alpha : 1, colorWithAlpha = _extends({}, parsedColor, {
      alpha: guard(0, 1, (alpha * 100 + parseFloat(amount) * 100) / 100)
    });
    return rgba(colorWithAlpha);
  }
  var curriedOpacify = curry(opacify), curriedOpacify$1 = curriedOpacify;
  function saturate(amount, color2) {
    if (color2 === "transparent") return color2;
    var hslColor = parseToHsl(color2);
    return toColorString(_extends({}, hslColor, {
      saturation: guard(0, 1, hslColor.saturation + parseFloat(amount))
    }));
  }
  var curriedSaturate = curry(saturate);
  function setHue(hue, color2) {
    return color2 === "transparent" ? color2 : toColorString(_extends({}, parseToHsl(color2), {
      hue: parseFloat(hue)
    }));
  }
  var curriedSetHue = curry(setHue);
  function setLightness(lightness, color2) {
    return color2 === "transparent" ? color2 : toColorString(_extends({}, parseToHsl(color2), {
      lightness: parseFloat(lightness)
    }));
  }
  var curriedSetLightness = curry(setLightness);
  function setSaturation(saturation, color2) {
    return color2 === "transparent" ? color2 : toColorString(_extends({}, parseToHsl(color2), {
      saturation: parseFloat(saturation)
    }));
  }
  var curriedSetSaturation = curry(setSaturation);
  function shade(percentage, color2) {
    return color2 === "transparent" ? color2 : mix$1(parseFloat(percentage), "rgb(0, 0, 0)", color2);
  }
  var curriedShade = curry(shade);
  function tint(percentage, color2) {
    return color2 === "transparent" ? color2 : mix$1(parseFloat(percentage), "rgb(255, 255, 255)", color2);
  }
  var curriedTint = curry(tint);
  function transparentize(amount, color2) {
    if (color2 === "transparent") return color2;
    var parsedColor = parseToRgb(color2), alpha = typeof parsedColor.alpha == "number" ? parsedColor.alpha : 1, colorWithAlpha = _extends({}, parsedColor, {
      alpha: guard(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100)
    });
    return rgba(colorWithAlpha);
  }
  var curriedTransparentize = curry(transparentize), curriedTransparentize$1 = curriedTransparentize;

  // node_modules/storybook/dist/_browser-chunks/chunk-ZUWEVLDX.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var EVENTS3 = {
    CALL: "storybook/instrumenter/call",
    SYNC: "storybook/instrumenter/sync",
    START: "storybook/instrumenter/start",
    BACK: "storybook/instrumenter/back",
    GOTO: "storybook/instrumenter/goto",
    NEXT: "storybook/instrumenter/next",
    END: "storybook/instrumenter/end"
  }, CallStates = ((CallStates2) => (CallStates2.DONE = "done", CallStates2.ERROR = "error", CallStates2.ACTIVE = "active", CallStates2.WAITING = "waiting", CallStates2))(CallStates || {});

  // node_modules/storybook/dist/_browser-chunks/chunk-V2VKKSMQ.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_A242L54C();
  var require_entities = __commonJS({
    "../../node_modules/entities/lib/maps/entities.json"(exports, module) {
      module.exports = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", amp: "&", AMP: "&", andand: "\u2A55", And: "\u2A53", and: "\u2227", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angmsd: "\u2221", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", apacir: "\u2A6F", ap: "\u2248", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxHd: "\u2564", boxhD: "\u2565", boxHD: "\u2566", boxhu: "\u2534", boxHu: "\u2567", boxhU: "\u2568", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsolb: "\u29C5", bsol: "\\", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", cap: "\u2229", Cap: "\u22D2", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\u{1D520}", Cfr: "\u212D", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cir: "\u25CB", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\u{1D554}", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cupbrcap: "\u2A48", cupcap: "\u2A46", CupCap: "\u224D", cup: "\u222A", Cup: "\u22D3", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", Darr: "\u21A1", dArr: "\u21D3", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", ddagger: "\u2021", ddarr: "\u21CA", DD: "\u2145", dd: "\u2146", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrowBar: "\u2913", downarrow: "\u2193", DownArrow: "\u2193", Downarrow: "\u21D3", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVectorBar: "\u2956", DownLeftVector: "\u21BD", DownRightTeeVector: "\u295F", DownRightVectorBar: "\u2957", DownRightVector: "\u21C1", DownTeeArrow: "\u21A7", DownTee: "\u22A4", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", Ecirc: "\xCA", ecirc: "\xEA", ecir: "\u2256", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", edot: "\u0117", eDot: "\u2251", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", forall: "\u2200", ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", Fscr: "\u2131", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", ge: "\u2265", gE: "\u2267", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", gescc: "\u2AA9", ges: "\u2A7E", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gla: "\u2AA5", gl: "\u2277", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gt: ">", GT: ">", Gt: "\u226B", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", harrcir: "\u2948", harr: "\u2194", hArr: "\u21D4", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\u{1D4BD}", Hscr: "\u210B", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", Ifr: "\u2111", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", Im: "\u2111", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", incare: "\u2105", in: "\u2208", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", intcal: "\u22BA", int: "\u222B", Int: "\u222C", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", lang: "\u27E8", Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larrb: "\u21E4", larrbfs: "\u291F", larr: "\u2190", Larr: "\u219E", lArr: "\u21D0", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", latail: "\u2919", lAtail: "\u291B", lat: "\u2AAB", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", LeftArrowBar: "\u21E4", leftarrow: "\u2190", LeftArrow: "\u2190", Leftarrow: "\u21D0", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVectorBar: "\u2959", LeftDownVector: "\u21C3", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTeeArrow: "\u21A4", LeftTee: "\u22A3", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangleBar: "\u29CF", LeftTriangle: "\u22B2", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVectorBar: "\u2958", LeftUpVector: "\u21BF", LeftVectorBar: "\u2952", LeftVector: "\u21BC", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", lescc: "\u2AA8", les: "\u2A7D", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", llarr: "\u21C7", ll: "\u226A", Ll: "\u22D8", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoustache: "\u23B0", lmoust: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftrightarrow: "\u27F7", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longmapsto: "\u27FC", longrightarrow: "\u27F6", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", lt: "<", LT: "<", Lt: "\u226A", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", midast: "*", midcir: "\u2AF0", mid: "\u2223", middot: "\xB7", minusb: "\u229F", minus: "\u2212", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", Mscr: "\u2133", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natural: "\u266E", naturals: "\u2115", natur: "\u266E", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", ne: "\u2260", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: `
`, nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nleftarrow: "\u219A", nLeftarrow: "\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\u{1D55F}", Nopf: "\u2115", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangle: "\u22EB", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", nparallel: "\u2226", npar: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", nprec: "\u2280", npreceq: "\u2AAF\u0338", npre: "\u2AAF\u0338", nrarrc: "\u2933\u0338", nrarr: "\u219B", nrArr: "\u21CF", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", Ocirc: "\xD4", ocirc: "\xF4", ocir: "\u229A", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", orarr: "\u21BB", Or: "\u2A54", or: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", otimesas: "\u2A36", Otimes: "\u2A37", otimes: "\u2297", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", para: "\xB6", parallel: "\u2225", par: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plus: "+", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\u{1D561}", Popf: "\u2119", pound: "\xA3", prap: "\u2AB7", Pr: "\u2ABB", pr: "\u227A", prcue: "\u227C", precapprox: "\u2AB7", prec: "\u227A", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", pre: "\u2AAF", prE: "\u2AB3", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportional: "\u221D", Proportion: "\u2237", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", Qopf: "\u211A", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarr: "\u2192", Rarr: "\u21A0", rArr: "\u21D2", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", Re: "\u211C", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrowBar: "\u21E5", rightarrow: "\u2192", RightArrow: "\u2192", Rightarrow: "\u21D2", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVectorBar: "\u2955", RightDownVector: "\u21C2", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTeeArrow: "\u21A6", RightTee: "\u22A2", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangleBar: "\u29D0", RightTriangle: "\u22B3", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVectorBar: "\u2954", RightUpVector: "\u21BE", RightVectorBar: "\u2953", RightVector: "\u21C0", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoustache: "\u23B1", rmoust: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\u{1D4C7}", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", Sc: "\u2ABC", sc: "\u227B", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdotb: "\u22A1", sdot: "\u22C5", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", solbar: "\u233F", solb: "\u29C4", sol: "/", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squ: "\u25A1", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succapprox: "\u2AB8", succ: "\u227B", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", Sup: "\u22D1", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", timesbar: "\u2A31", timesb: "\u22A0", times: "\xD7", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", topbot: "\u2336", topcir: "\u2AF1", top: "\u22A4", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", uarr: "\u2191", Uarr: "\u219F", uArr: "\u21D1", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrowBar: "\u2912", uparrow: "\u2191", UpArrow: "\u2191", Uparrow: "\u21D1", UpArrowDownArrow: "\u21C5", updownarrow: "\u2195", UpDownArrow: "\u2195", Updownarrow: "\u21D5", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTeeArrow: "\u21A5", UpTee: "\u22A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", vdash: "\u22A2", vDash: "\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", veebar: "\u22BB", vee: "\u2228", Vee: "\u22C1", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xharr: "\u27F7", xhArr: "\u27FA", Xi: "\u039E", xi: "\u03BE", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\u27F9", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", yuml: "\xFF", Yuml: "\u0178", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", zfr: "\u{1D537}", Zfr: "\u2128", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", Zopf: "\u2124", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" };
    }
  }), require_legacy = __commonJS({
    "../../node_modules/entities/lib/maps/legacy.json"(exports, module) {
      module.exports = { Aacute: "\xC1", aacute: "\xE1", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", AElig: "\xC6", aelig: "\xE6", Agrave: "\xC0", agrave: "\xE0", amp: "&", AMP: "&", Aring: "\xC5", aring: "\xE5", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", brvbar: "\xA6", Ccedil: "\xC7", ccedil: "\xE7", cedil: "\xB8", cent: "\xA2", copy: "\xA9", COPY: "\xA9", curren: "\xA4", deg: "\xB0", divide: "\xF7", Eacute: "\xC9", eacute: "\xE9", Ecirc: "\xCA", ecirc: "\xEA", Egrave: "\xC8", egrave: "\xE8", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", frac12: "\xBD", frac14: "\xBC", frac34: "\xBE", gt: ">", GT: ">", Iacute: "\xCD", iacute: "\xED", Icirc: "\xCE", icirc: "\xEE", iexcl: "\xA1", Igrave: "\xCC", igrave: "\xEC", iquest: "\xBF", Iuml: "\xCF", iuml: "\xEF", laquo: "\xAB", lt: "<", LT: "<", macr: "\xAF", micro: "\xB5", middot: "\xB7", nbsp: "\xA0", not: "\xAC", Ntilde: "\xD1", ntilde: "\xF1", Oacute: "\xD3", oacute: "\xF3", Ocirc: "\xD4", ocirc: "\xF4", Ograve: "\xD2", ograve: "\xF2", ordf: "\xAA", ordm: "\xBA", Oslash: "\xD8", oslash: "\xF8", Otilde: "\xD5", otilde: "\xF5", Ouml: "\xD6", ouml: "\xF6", para: "\xB6", plusmn: "\xB1", pound: "\xA3", quot: '"', QUOT: '"', raquo: "\xBB", reg: "\xAE", REG: "\xAE", sect: "\xA7", shy: "\xAD", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", szlig: "\xDF", THORN: "\xDE", thorn: "\xFE", times: "\xD7", Uacute: "\xDA", uacute: "\xFA", Ucirc: "\xDB", ucirc: "\xFB", Ugrave: "\xD9", ugrave: "\xF9", uml: "\xA8", Uuml: "\xDC", uuml: "\xFC", Yacute: "\xDD", yacute: "\xFD", yen: "\xA5", yuml: "\xFF" };
    }
  }), require_xml = __commonJS({
    "../../node_modules/entities/lib/maps/xml.json"(exports, module) {
      module.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
    }
  }), require_decode = __commonJS({
    "../../node_modules/entities/lib/maps/decode.json"(exports, module) {
      module.exports = { 0: 65533, 128: 8364, 130: 8218, 131: 402, 132: 8222, 133: 8230, 134: 8224, 135: 8225, 136: 710, 137: 8240, 138: 352, 139: 8249, 140: 338, 142: 381, 145: 8216, 146: 8217, 147: 8220, 148: 8221, 149: 8226, 150: 8211, 151: 8212, 152: 732, 153: 8482, 154: 353, 155: 8250, 156: 339, 158: 382, 159: 376 };
    }
  }), require_decode_codepoint = __commonJS({
    "../../node_modules/entities/lib/decode_codepoint.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
      Object.defineProperty(exports, "__esModule", { value: !0 });
      var decode_json_1 = __importDefault(require_decode()), fromCodePoint = (
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        String.fromCodePoint || function(codePoint) {
          var output = "";
          return codePoint > 65535 && (codePoint -= 65536, output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296), codePoint = 56320 | codePoint & 1023), output += String.fromCharCode(codePoint), output;
        }
      );
      function decodeCodePoint(codePoint) {
        return codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111 ? "\uFFFD" : (codePoint in decode_json_1.default && (codePoint = decode_json_1.default[codePoint]), fromCodePoint(codePoint));
      }
      exports.default = decodeCodePoint;
    }
  }), require_decode2 = __commonJS({
    "../../node_modules/entities/lib/decode.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
      var entities_json_1 = __importDefault(require_entities()), legacy_json_1 = __importDefault(require_legacy()), xml_json_1 = __importDefault(require_xml()), decode_codepoint_1 = __importDefault(require_decode_codepoint()), strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
      exports.decodeXML = getStrictDecoder(xml_json_1.default), exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
      function getStrictDecoder(map) {
        var replace = getReplacer(map);
        return function(str) {
          return String(str).replace(strictEntityRe, replace);
        };
      }
      var sorter = function(a3, b3) {
        return a3 < b3 ? 1 : -1;
      };
      exports.decodeHTML = (function() {
        for (var legacy = Object.keys(legacy_json_1.default).sort(sorter), keys = Object.keys(entities_json_1.default).sort(sorter), i3 = 0, j2 = 0; i3 < keys.length; i3++)
          legacy[j2] === keys[i3] ? (keys[i3] += ";?", j2++) : keys[i3] += ";";
        var re3 = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), replace = getReplacer(entities_json_1.default);
        function replacer(str) {
          return str.substr(-1) !== ";" && (str += ";"), replace(str);
        }
        return function(str) {
          return String(str).replace(re3, replacer);
        };
      })();
      function getReplacer(map) {
        return function(str) {
          if (str.charAt(1) === "#") {
            var secondChar = str.charAt(2);
            return secondChar === "X" || secondChar === "x" ? decode_codepoint_1.default(parseInt(str.substr(3), 16)) : decode_codepoint_1.default(parseInt(str.substr(2), 10));
          }
          return map[str.slice(1, -1)] || str;
        };
      }
    }
  }), require_encode = __commonJS({
    "../../node_modules/entities/lib/encode.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;
      var xml_json_1 = __importDefault(require_xml()), inverseXML = getInverseObj(xml_json_1.default), xmlReplacer = getInverseReplacer(inverseXML);
      exports.encodeXML = getASCIIEncoder(inverseXML);
      var entities_json_1 = __importDefault(require_entities()), inverseHTML = getInverseObj(entities_json_1.default), htmlReplacer = getInverseReplacer(inverseHTML);
      exports.encodeHTML = getInverse(inverseHTML, htmlReplacer), exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
      function getInverseObj(obj) {
        return Object.keys(obj).sort().reduce(function(inverse, name) {
          return inverse[obj[name]] = "&" + name + ";", inverse;
        }, {});
      }
      function getInverseReplacer(inverse) {
        for (var single = [], multiple = [], _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
          var k3 = _a[_i];
          k3.length === 1 ? single.push("\\" + k3) : multiple.push(k3);
        }
        single.sort();
        for (var start = 0; start < single.length - 1; start++) {
          for (var end = start; end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1); )
            end += 1;
          var count2 = 1 + end - start;
          count2 < 3 || single.splice(start, count2, single[start] + "-" + single[end]);
        }
        return multiple.unshift("[" + single.join("") + "]"), new RegExp(multiple.join("|"), "g");
      }
      var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, getCodePoint = (
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        String.prototype.codePointAt != null ? (
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          (function(str) {
            return str.codePointAt(0);
          })
        ) : (
          // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
          (function(c3) {
            return (c3.charCodeAt(0) - 55296) * 1024 + c3.charCodeAt(1) - 56320 + 65536;
          })
        )
      );
      function singleCharReplacer(c3) {
        return "&#x" + (c3.length > 1 ? getCodePoint(c3) : c3.charCodeAt(0)).toString(16).toUpperCase() + ";";
      }
      function getInverse(inverse, re3) {
        return function(data) {
          return data.replace(re3, function(name) {
            return inverse[name];
          }).replace(reNonASCII, singleCharReplacer);
        };
      }
      var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
      function escape2(data) {
        return data.replace(reEscapeChars, singleCharReplacer);
      }
      exports.escape = escape2;
      function escapeUTF8(data) {
        return data.replace(xmlReplacer, singleCharReplacer);
      }
      exports.escapeUTF8 = escapeUTF8;
      function getASCIIEncoder(obj) {
        return function(data) {
          return data.replace(reEscapeChars, function(c3) {
            return obj[c3] || singleCharReplacer(c3);
          });
        };
      }
    }
  }), require_lib = __commonJS({
    "../../node_modules/entities/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
      var decode_1 = require_decode2(), encode_1 = require_encode();
      function decode(data, level) {
        return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
      }
      exports.decode = decode;
      function decodeStrict(data, level) {
        return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
      }
      exports.decodeStrict = decodeStrict;
      function encode(data, level) {
        return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
      }
      exports.encode = encode;
      var encode_2 = require_encode();
      Object.defineProperty(exports, "encodeXML", { enumerable: !0, get: function() {
        return encode_2.encodeXML;
      } }), Object.defineProperty(exports, "encodeHTML", { enumerable: !0, get: function() {
        return encode_2.encodeHTML;
      } }), Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: !0, get: function() {
        return encode_2.encodeNonAsciiHTML;
      } }), Object.defineProperty(exports, "escape", { enumerable: !0, get: function() {
        return encode_2.escape;
      } }), Object.defineProperty(exports, "escapeUTF8", { enumerable: !0, get: function() {
        return encode_2.escapeUTF8;
      } }), Object.defineProperty(exports, "encodeHTML4", { enumerable: !0, get: function() {
        return encode_2.encodeHTML;
      } }), Object.defineProperty(exports, "encodeHTML5", { enumerable: !0, get: function() {
        return encode_2.encodeHTML;
      } });
      var decode_2 = require_decode2();
      Object.defineProperty(exports, "decodeXML", { enumerable: !0, get: function() {
        return decode_2.decodeXML;
      } }), Object.defineProperty(exports, "decodeHTML", { enumerable: !0, get: function() {
        return decode_2.decodeHTML;
      } }), Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: !0, get: function() {
        return decode_2.decodeHTMLStrict;
      } }), Object.defineProperty(exports, "decodeHTML4", { enumerable: !0, get: function() {
        return decode_2.decodeHTML;
      } }), Object.defineProperty(exports, "decodeHTML5", { enumerable: !0, get: function() {
        return decode_2.decodeHTML;
      } }), Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: !0, get: function() {
        return decode_2.decodeHTMLStrict;
      } }), Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: !0, get: function() {
        return decode_2.decodeHTMLStrict;
      } }), Object.defineProperty(exports, "decodeXMLStrict", { enumerable: !0, get: function() {
        return decode_2.decodeXML;
      } });
    }
  }), require_ansi_to_html = __commonJS({
    "../../node_modules/ansi-to-html/lib/ansi_to_html.js"(exports, module) {
      "use strict";
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor))
          throw new TypeError("Cannot call a class as a function");
      }
      function _defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
      }
      function _createForOfIteratorHelper(o2, allowArrayLike) {
        var it = typeof Symbol < "u" && o2[Symbol.iterator] || o2["@@iterator"];
        if (!it) {
          if (Array.isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length == "number") {
            it && (o2 = it);
            var i3 = 0, F3 = function() {
            };
            return { s: F3, n: function() {
              return i3 >= o2.length ? { done: !0 } : { done: !1, value: o2[i3++] };
            }, e: function(_e2) {
              throw _e2;
            }, f: F3 };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var normalCompletion = !0, didErr = !1, err;
        return { s: function() {
          it = it.call(o2);
        }, n: function() {
          var step2 = it.next();
          return normalCompletion = step2.done, step2;
        }, e: function(_e2) {
          didErr = !0, err = _e2;
        }, f: function() {
          try {
            !normalCompletion && it.return != null && it.return();
          } finally {
            if (didErr) throw err;
          }
        } };
      }
      function _unsupportedIterableToArray(o2, minLen) {
        if (o2) {
          if (typeof o2 == "string") return _arrayLikeToArray(o2, minLen);
          var n2 = Object.prototype.toString.call(o2).slice(8, -1);
          if (n2 === "Object" && o2.constructor && (n2 = o2.constructor.name), n2 === "Map" || n2 === "Set") return Array.from(o2);
          if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o2, minLen);
        }
      }
      function _arrayLikeToArray(arr, len) {
        (len == null || len > arr.length) && (len = arr.length);
        for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++)
          arr2[i3] = arr[i3];
        return arr2;
      }
      var entities = require_lib(), defaults = {
        fg: "#FFF",
        bg: "#000",
        newline: !1,
        escapeXML: !1,
        stream: !1,
        colors: getDefaultColors()
      };
      function getDefaultColors() {
        var colors3 = {
          0: "#000",
          1: "#A00",
          2: "#0A0",
          3: "#A50",
          4: "#00A",
          5: "#A0A",
          6: "#0AA",
          7: "#AAA",
          8: "#555",
          9: "#F55",
          10: "#5F5",
          11: "#FF5",
          12: "#55F",
          13: "#F5F",
          14: "#5FF",
          15: "#FFF"
        };
        return range(0, 5).forEach(function(red) {
          range(0, 5).forEach(function(green) {
            range(0, 5).forEach(function(blue) {
              return setStyleColor(red, green, blue, colors3);
            });
          });
        }), range(0, 23).forEach(function(gray) {
          var c3 = gray + 232, l2 = toHexString(gray * 10 + 8);
          colors3[c3] = "#" + l2 + l2 + l2;
        }), colors3;
      }
      function setStyleColor(red, green, blue, colors3) {
        var c3 = 16 + red * 36 + green * 6 + blue, r2 = red > 0 ? red * 40 + 55 : 0, g3 = green > 0 ? green * 40 + 55 : 0, b3 = blue > 0 ? blue * 40 + 55 : 0;
        colors3[c3] = toColorHexString([r2, g3, b3]);
      }
      function toHexString(num) {
        for (var str = num.toString(16); str.length < 2; )
          str = "0" + str;
        return str;
      }
      function toColorHexString(ref) {
        var results = [], _iterator = _createForOfIteratorHelper(ref), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var r2 = _step.value;
            results.push(toHexString(r2));
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return "#" + results.join("");
      }
      function generateOutput(stack, token, data, options) {
        var result;
        return token === "text" ? result = pushText(data, options) : token === "display" ? result = handleDisplay(stack, data, options) : token === "xterm256Foreground" ? result = pushForegroundColor(stack, options.colors[data]) : token === "xterm256Background" ? result = pushBackgroundColor(stack, options.colors[data]) : token === "rgb" && (result = handleRgb(stack, data)), result;
      }
      function handleRgb(stack, data) {
        data = data.substring(2).slice(0, -1);
        var operation = +data.substr(0, 2), color2 = data.substring(5).split(";"), rgb2 = color2.map(function(value2) {
          return ("0" + Number(value2).toString(16)).substr(-2);
        }).join("");
        return pushStyle(stack, (operation === 38 ? "color:#" : "background-color:#") + rgb2);
      }
      function handleDisplay(stack, code, options) {
        code = parseInt(code, 10);
        var codeMap = {
          "-1": function() {
            return "<br/>";
          },
          0: function() {
            return stack.length && resetStyles(stack);
          },
          1: function() {
            return pushTag(stack, "b");
          },
          3: function() {
            return pushTag(stack, "i");
          },
          4: function() {
            return pushTag(stack, "u");
          },
          8: function() {
            return pushStyle(stack, "display:none");
          },
          9: function() {
            return pushTag(stack, "strike");
          },
          22: function() {
            return pushStyle(stack, "font-weight:normal;text-decoration:none;font-style:normal");
          },
          23: function() {
            return closeTag(stack, "i");
          },
          24: function() {
            return closeTag(stack, "u");
          },
          39: function() {
            return pushForegroundColor(stack, options.fg);
          },
          49: function() {
            return pushBackgroundColor(stack, options.bg);
          },
          53: function() {
            return pushStyle(stack, "text-decoration:overline");
          }
        }, result;
        return codeMap[code] ? result = codeMap[code]() : 4 < code && code < 7 ? result = pushTag(stack, "blink") : 29 < code && code < 38 ? result = pushForegroundColor(stack, options.colors[code - 30]) : 39 < code && code < 48 ? result = pushBackgroundColor(stack, options.colors[code - 40]) : 89 < code && code < 98 ? result = pushForegroundColor(stack, options.colors[8 + (code - 90)]) : 99 < code && code < 108 && (result = pushBackgroundColor(stack, options.colors[8 + (code - 100)])), result;
      }
      function resetStyles(stack) {
        var stackClone = stack.slice(0);
        return stack.length = 0, stackClone.reverse().map(function(tag) {
          return "</" + tag + ">";
        }).join("");
      }
      function range(low, high) {
        for (var results = [], j2 = low; j2 <= high; j2++)
          results.push(j2);
        return results;
      }
      function notCategory(category) {
        return function(e) {
          return (category === null || e.category !== category) && category !== "all";
        };
      }
      function categoryForCode(code) {
        code = parseInt(code, 10);
        var result = null;
        return code === 0 ? result = "all" : code === 1 ? result = "bold" : 2 < code && code < 5 ? result = "underline" : 4 < code && code < 7 ? result = "blink" : code === 8 ? result = "hide" : code === 9 ? result = "strike" : 29 < code && code < 38 || code === 39 || 89 < code && code < 98 ? result = "foreground-color" : (39 < code && code < 48 || code === 49 || 99 < code && code < 108) && (result = "background-color"), result;
      }
      function pushText(text, options) {
        return options.escapeXML ? entities.encodeXML(text) : text;
      }
      function pushTag(stack, tag, style) {
        return style || (style = ""), stack.push(tag), "<".concat(tag).concat(style ? ' style="'.concat(style, '"') : "", ">");
      }
      function pushStyle(stack, style) {
        return pushTag(stack, "span", style);
      }
      function pushForegroundColor(stack, color2) {
        return pushTag(stack, "span", "color:" + color2);
      }
      function pushBackgroundColor(stack, color2) {
        return pushTag(stack, "span", "background-color:" + color2);
      }
      function closeTag(stack, style) {
        var last;
        if (stack.slice(-1)[0] === style && (last = stack.pop()), last)
          return "</" + style + ">";
      }
      function tokenize(text, options, callback) {
        var ansiMatch = !1, ansiHandler = 3;
        function remove() {
          return "";
        }
        function removeXterm256Foreground(m3, g1) {
          return callback("xterm256Foreground", g1), "";
        }
        function removeXterm256Background(m3, g1) {
          return callback("xterm256Background", g1), "";
        }
        function newline(m3) {
          return options.newline ? callback("display", -1) : callback("text", m3), "";
        }
        function ansiMess(m3, g1) {
          ansiMatch = !0, g1.trim().length === 0 && (g1 = "0"), g1 = g1.trimRight(";").split(";");
          var _iterator2 = _createForOfIteratorHelper(g1), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var g3 = _step2.value;
              callback("display", g3);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          return "";
        }
        function realText(m3) {
          return callback("text", m3), "";
        }
        function rgb2(m3) {
          return callback("rgb", m3), "";
        }
        var tokens2 = [{
          pattern: /^\x08+/,
          sub: remove
        }, {
          pattern: /^\x1b\[[012]?K/,
          sub: remove
        }, {
          pattern: /^\x1b\[\(B/,
          sub: remove
        }, {
          pattern: /^\x1b\[[34]8;2;\d+;\d+;\d+m/,
          sub: rgb2
        }, {
          pattern: /^\x1b\[38;5;(\d+)m/,
          sub: removeXterm256Foreground
        }, {
          pattern: /^\x1b\[48;5;(\d+)m/,
          sub: removeXterm256Background
        }, {
          pattern: /^\n/,
          sub: newline
        }, {
          pattern: /^\r+\n/,
          sub: newline
        }, {
          pattern: /^\r/,
          sub: newline
        }, {
          pattern: /^\x1b\[((?:\d{1,3};?)+|)m/,
          sub: ansiMess
        }, {
          // CSI n J
          // ED - Erase in Display Clears part of the screen.
          // If n is 0 (or missing), clear from cursor to end of screen.
          // If n is 1, clear from cursor to beginning of the screen.
          // If n is 2, clear entire screen (and moves cursor to upper left on DOS ANSI.SYS).
          // If n is 3, clear entire screen and delete all lines saved in the scrollback buffer
          //   (this feature was added for xterm and is supported by other terminal applications).
          pattern: /^\x1b\[\d?J/,
          sub: remove
        }, {
          // CSI n ; m f
          // HVP - Horizontal Vertical Position Same as CUP
          pattern: /^\x1b\[\d{0,3};\d{0,3}f/,
          sub: remove
        }, {
          // catch-all for CSI sequences?
          pattern: /^\x1b\[?[\d;]{0,3}/,
          sub: remove
        }, {
          /**
           * extracts real text - not containing:
           * - `\x1b' - ESC - escape (Ascii 27)
           * - '\x08' - BS - backspace (Ascii 8)
           * - `\n` - Newline - linefeed (LF) (ascii 10)
           * - `\r` - Windows Carriage Return (CR)
           */
          pattern: /^(([^\x1b\x08\r\n])+)/,
          sub: realText
        }];
        function process2(handler2, i22) {
          i22 > ansiHandler && ansiMatch || (ansiMatch = !1, text = text.replace(handler2.pattern, handler2.sub));
        }
        var results1 = [], _text = text, length = _text.length;
        outer: for (; length > 0; ) {
          for (var i3 = 0, o2 = 0, len = tokens2.length; o2 < len; i3 = ++o2) {
            var handler = tokens2[i3];
            if (process2(handler, i3), text.length !== length) {
              length = text.length;
              continue outer;
            }
          }
          if (text.length === length)
            break;
          results1.push(0), length = text.length;
        }
        return results1;
      }
      function updateStickyStack(stickyStack, token, data) {
        return token !== "text" && (stickyStack = stickyStack.filter(notCategory(categoryForCode(data))), stickyStack.push({
          token,
          data,
          category: categoryForCode(data)
        })), stickyStack;
      }
      var Filter = (function() {
        function Filter2(options) {
          _classCallCheck(this, Filter2), options = options || {}, options.colors && (options.colors = Object.assign({}, defaults.colors, options.colors)), this.options = Object.assign({}, defaults, options), this.stack = [], this.stickyStack = [];
        }
        return _createClass(Filter2, [{
          key: "toHtml",
          value: function(input) {
            var _this = this;
            input = typeof input == "string" ? [input] : input;
            var stack = this.stack, options = this.options, buf = [];
            return this.stickyStack.forEach(function(element) {
              var output = generateOutput(stack, element.token, element.data, options);
              output && buf.push(output);
            }), tokenize(input.join(""), options, function(token, data) {
              var output = generateOutput(stack, token, data, options);
              output && buf.push(output), options.stream && (_this.stickyStack = updateStickyStack(_this.stickyStack, token, data));
            }), stack.length && buf.push(resetStyles(stack)), buf.join("");
          }
        }]), Filter2;
      })();
      module.exports = Filter;
    }
  });

  // node_modules/storybook/dist/_browser-chunks/chunk-YK43Z22A.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/storybook/dist/_browser-chunks/chunk-LCHBOIHN.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  function isPlainObject(value2) {
    if (!value2 || typeof value2 != "object")
      return !1;
    let proto = Object.getPrototypeOf(value2);
    return proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null ? Object.prototype.toString.call(value2) === "[object Object]" : !1;
  }
  function isPrimitive(value2) {
    return value2 == null || typeof value2 != "object" && typeof value2 != "function";
  }
  function isTypedArray(x3) {
    return ArrayBuffer.isView(x3) && !(x3 instanceof DataView);
  }
  function getSymbols(object2) {
    return Object.getOwnPropertySymbols(object2).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object2, symbol));
  }
  function getTag(value2) {
    return value2 == null ? value2 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value2);
  }
  var regexpTag = "[object RegExp]", stringTag = "[object String]", numberTag = "[object Number]", booleanTag = "[object Boolean]", argumentsTag = "[object Arguments]", symbolTag = "[object Symbol]", dateTag = "[object Date]", mapTag = "[object Map]", setTag = "[object Set]", arrayTag = "[object Array]";
  var arrayBufferTag = "[object ArrayBuffer]", objectTag = "[object Object]";
  var dataViewTag = "[object DataView]", uint8ArrayTag = "[object Uint8Array]", uint8ClampedArrayTag = "[object Uint8ClampedArray]", uint16ArrayTag = "[object Uint16Array]", uint32ArrayTag = "[object Uint32Array]";
  var int8ArrayTag = "[object Int8Array]", int16ArrayTag = "[object Int16Array]", int32ArrayTag = "[object Int32Array]";
  var float32ArrayTag = "[object Float32Array]", float64ArrayTag = "[object Float64Array]";

  // node_modules/storybook/dist/_browser-chunks/chunk-YK43Z22A.js
  function mapValues(object2, getNewValue) {
    let result = {}, keys = Object.keys(object2);
    for (let i3 = 0; i3 < keys.length; i3++) {
      let key = keys[i3], value2 = object2[key];
      result[key] = getNewValue(value2, key, object2);
    }
    return result;
  }
  function pickBy(obj, shouldPick) {
    let result = {}, keys = Object.keys(obj);
    for (let i3 = 0; i3 < keys.length; i3++) {
      let key = keys[i3], value2 = obj[key];
      shouldPick(value2, key) && (result[key] = value2);
    }
    return result;
  }
  function cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack = /* @__PURE__ */ new Map(), cloneValue = void 0) {
    let cloned = cloneValue?.(valueToClone, keyToClone, objectToClone, stack);
    if (cloned !== void 0)
      return cloned;
    if (isPrimitive(valueToClone))
      return valueToClone;
    if (stack.has(valueToClone))
      return stack.get(valueToClone);
    if (Array.isArray(valueToClone)) {
      let result = new Array(valueToClone.length);
      stack.set(valueToClone, result);
      for (let i3 = 0; i3 < valueToClone.length; i3++)
        result[i3] = cloneDeepWithImpl(valueToClone[i3], i3, objectToClone, stack, cloneValue);
      return Object.hasOwn(valueToClone, "index") && (result.index = valueToClone.index), Object.hasOwn(valueToClone, "input") && (result.input = valueToClone.input), result;
    }
    if (valueToClone instanceof Date)
      return new Date(valueToClone.getTime());
    if (valueToClone instanceof RegExp) {
      let result = new RegExp(valueToClone.source, valueToClone.flags);
      return result.lastIndex = valueToClone.lastIndex, result;
    }
    if (valueToClone instanceof Map) {
      let result = /* @__PURE__ */ new Map();
      stack.set(valueToClone, result);
      for (let [key, value2] of valueToClone)
        result.set(key, cloneDeepWithImpl(value2, key, objectToClone, stack, cloneValue));
      return result;
    }
    if (valueToClone instanceof Set) {
      let result = /* @__PURE__ */ new Set();
      stack.set(valueToClone, result);
      for (let value2 of valueToClone)
        result.add(cloneDeepWithImpl(value2, void 0, objectToClone, stack, cloneValue));
      return result;
    }
    if (typeof Buffer < "u" && Buffer.isBuffer(valueToClone))
      return valueToClone.subarray();
    if (isTypedArray(valueToClone)) {
      let result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
      stack.set(valueToClone, result);
      for (let i3 = 0; i3 < valueToClone.length; i3++)
        result[i3] = cloneDeepWithImpl(valueToClone[i3], i3, objectToClone, stack, cloneValue);
      return result;
    }
    if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && valueToClone instanceof SharedArrayBuffer)
      return valueToClone.slice(0);
    if (valueToClone instanceof DataView) {
      let result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
      return stack.set(valueToClone, result), copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;
    }
    if (typeof File < "u" && valueToClone instanceof File) {
      let result = new File([valueToClone], valueToClone.name, {
        type: valueToClone.type
      });
      return stack.set(valueToClone, result), copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;
    }
    if (typeof Blob < "u" && valueToClone instanceof Blob) {
      let result = new Blob([valueToClone], { type: valueToClone.type });
      return stack.set(valueToClone, result), copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;
    }
    if (valueToClone instanceof Error) {
      let result = new valueToClone.constructor();
      return stack.set(valueToClone, result), result.message = valueToClone.message, result.name = valueToClone.name, result.stack = valueToClone.stack, result.cause = valueToClone.cause, copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;
    }
    if (valueToClone instanceof Boolean) {
      let result = new Boolean(valueToClone.valueOf());
      return stack.set(valueToClone, result), copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;
    }
    if (valueToClone instanceof Number) {
      let result = new Number(valueToClone.valueOf());
      return stack.set(valueToClone, result), copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;
    }
    if (valueToClone instanceof String) {
      let result = new String(valueToClone.valueOf());
      return stack.set(valueToClone, result), copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;
    }
    if (typeof valueToClone == "object" && isCloneableObject(valueToClone)) {
      let result = Object.create(Object.getPrototypeOf(valueToClone));
      return stack.set(valueToClone, result), copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;
    }
    return valueToClone;
  }
  function copyProperties(target, source, objectToClone = target, stack, cloneValue) {
    let keys = [...Object.keys(source), ...getSymbols(source)];
    for (let i3 = 0; i3 < keys.length; i3++) {
      let key = keys[i3], descriptor = Object.getOwnPropertyDescriptor(target, key);
      (descriptor == null || descriptor.writable) && (target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue));
    }
  }
  function isCloneableObject(object2) {
    switch (getTag(object2)) {
      case argumentsTag:
      case arrayTag:
      case arrayBufferTag:
      case dataViewTag:
      case booleanTag:
      case dateTag:
      case float32ArrayTag:
      case float64ArrayTag:
      case int8ArrayTag:
      case int16ArrayTag:
      case int32ArrayTag:
      case mapTag:
      case numberTag:
      case objectTag:
      case regexpTag:
      case setTag:
      case stringTag:
      case symbolTag:
      case uint8ArrayTag:
      case uint8ClampedArrayTag:
      case uint16ArrayTag:
      case uint32ArrayTag:
        return !0;
      default:
        return !1;
    }
  }
  function cloneDeep(obj) {
    return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), void 0);
  }
  var CASE_SPLIT_PATTERN = new RegExp("\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+", "gu");

  // node_modules/storybook/dist/_browser-chunks/chunk-6XWLIJQL.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var PARAM_KEY4 = "actions", ADDON_ID4 = "storybook/actions", PANEL_ID = `${ADDON_ID4}/panel`, EVENT_ID = `${ADDON_ID4}/action-event`, CLEAR_ID = `${ADDON_ID4}/action-clear`;

  // node_modules/storybook/dist/_browser-chunks/chunk-ASKQZAOS.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var MINIMAL_VIEWPORTS = {
    mobile1: {
      name: "Small mobile",
      styles: {
        height: "568px",
        width: "320px"
      },
      type: "mobile"
    },
    mobile2: {
      name: "Large mobile",
      styles: {
        height: "896px",
        width: "414px"
      },
      type: "mobile"
    },
    tablet: {
      name: "Tablet",
      styles: {
        height: "1112px",
        width: "834px"
      },
      type: "tablet"
    },
    desktop: {
      name: "Desktop",
      styles: {
        height: "1024px",
        width: "1280px"
      },
      type: "desktop"
    }
  };

  // node_modules/storybook/dist/_browser-chunks/chunk-SL75JR6Y.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var ADDON_ID5 = "storybook/viewport", PARAM_KEY5 = "viewport", PANEL_ID2 = `${ADDON_ID5}/panel`, TOOL_ID2 = `${ADDON_ID5}/tool`;

  // node_modules/storybook/dist/core-server/presets/common-manager.js
  init_chunk_A242L54C();

  // node_modules/@storybook/global/dist/index.mjs
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var scope = (() => {
    let win;
    return typeof window < "u" ? win = window : typeof globalThis < "u" ? win = globalThis : typeof window < "u" ? win = window : typeof self < "u" ? win = self : win = {}, win;
  })();

  // global-externals:storybook/manager-api
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var manager_api_default = __STORYBOOK_API__, { ActiveTabs, Consumer, ManagerContext, Provider, RequestResponseError, Tag, addons, combineParameters, controlOrMetaKey, controlOrMetaSymbol, eventMatchesShortcut, eventToShortcut, experimental_MockUniversalStore, experimental_UniversalStore, experimental_getStatusStore, experimental_getTestProviderStore, experimental_requestResponse, experimental_useStatusStore, experimental_useTestProviderStore, experimental_useUniversalStore, internal_checklistStore, internal_fullStatusStore, internal_fullTestProviderStore, internal_universalChecklistStore, internal_universalStatusStore, internal_universalTestProviderStore, isMacLike, isShortcutTaken, keyToSymbol, merge, mockChannel, optionOrAltSymbol, shortcutMatchesShortcut, shortcutToAriaKeyshortcuts, shortcutToHumanString, types, useAddonState, useArgTypes, useArgs, useChannel, useGlobalTypes, useGlobals, useParameter, useSharedState, useStoryPrepared, useStorybookApi, useStorybookState } = __STORYBOOK_API__;

  // node_modules/storybook/dist/core-server/presets/common-manager.js
  init_react();
  init_components();

  // global-externals:storybook/internal/core-events
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var core_events_default = __STORYBOOK_CORE_EVENTS__, { ARGTYPES_INFO_REQUEST, ARGTYPES_INFO_RESPONSE, CHANNEL_CREATED, CHANNEL_WS_DISCONNECT, CONFIG_ERROR, CREATE_NEW_STORYFILE_REQUEST, CREATE_NEW_STORYFILE_RESPONSE, CURRENT_STORY_WAS_SET, DOCS_PREPARED, DOCS_RENDERED, FILE_COMPONENT_SEARCH_REQUEST, FILE_COMPONENT_SEARCH_RESPONSE, FORCE_REMOUNT, FORCE_RE_RENDER, GHOST_STORIES_REQUEST, GHOST_STORIES_RESPONSE, GLOBALS_UPDATED, MANAGER_INERT_ATTRIBUTE_CHANGED, NAVIGATE_URL, OPEN_IN_EDITOR_REQUEST, OPEN_IN_EDITOR_RESPONSE, PLAY_FUNCTION_THREW_EXCEPTION, PRELOAD_ENTRIES, PREVIEW_BUILDER_PROGRESS, PREVIEW_INITIALIZED, PREVIEW_KEYDOWN, REGISTER_SUBSCRIPTION, REQUEST_WHATS_NEW_DATA, RESET_STORY_ARGS, RESULT_WHATS_NEW_DATA, SAVE_STORY_REQUEST, SAVE_STORY_RESPONSE, SELECT_STORY, SET_CONFIG, SET_CURRENT_STORY, SET_FILTER, SET_GLOBALS, SET_INDEX, SET_STORIES, SET_WHATS_NEW_CACHE, SHARED_STATE_CHANGED, SHARED_STATE_SET, SHARE_ISOLATE_MODE, SHARE_POPOVER_OPENED, SHARE_STORY_LINK, STORIES_COLLAPSE_ALL, STORIES_EXPAND_ALL, STORY_ARGS_UPDATED, STORY_CHANGED, STORY_ERRORED, STORY_FINISHED, STORY_HOT_UPDATED, STORY_INDEX_INVALIDATED, STORY_MISSING, STORY_PREPARED, STORY_RENDERED, STORY_RENDER_PHASE_CHANGED, STORY_SPECIFIED, STORY_THREW_EXCEPTION, STORY_UNCHANGED, TELEMETRY_ERROR, TOGGLE_WHATS_NEW_NOTIFICATIONS, UNHANDLED_ERRORS_WHILE_PLAYING, UPDATE_GLOBALS, UPDATE_QUERY_PARAMS, UPDATE_STORY_ARGS } = __STORYBOOK_CORE_EVENTS__;

  // node_modules/storybook/dist/core-server/presets/common-manager.js
  init_icons();
  init_theming();
  init_react();
  init_theming();
  init_react();

  // global-externals:storybook/internal/client-logger
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var client_logger_default = __STORYBOOK_CLIENT_LOGGER__, { deprecate, logger, once, pretty } = __STORYBOOK_CLIENT_LOGGER__;

  // node_modules/storybook/dist/core-server/presets/common-manager.js
  init_components();

  // node_modules/storybook/dist/csf/index.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/storybook/dist/_browser-chunks/chunk-2N4WE3KZ.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/storybook/dist/_browser-chunks/chunk-MEXTPDJG.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/storybook/dist/_browser-chunks/chunk-AFVOZMXQ.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/storybook/dist/_browser-chunks/chunk-XLJZ7AOP.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_A242L54C();
  var require_string_util = __commonJS({
    "../../node_modules/picoquery/lib/string-util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.encodeString = encodeString;
      var hexTable = Array.from({ length: 256 }, (_3, i3) => "%" + ((i3 < 16 ? "0" : "") + i3.toString(16)).toUpperCase()), noEscape = new Int8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        0,
        0,
        1,
        1,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        1,
        0
      ]);
      function encodeString(str) {
        let len = str.length;
        if (len === 0)
          return "";
        let out = "", lastPos = 0, i3 = 0;
        outer: for (; i3 < len; i3++) {
          let c3 = str.charCodeAt(i3);
          for (; c3 < 128; ) {
            if (noEscape[c3] !== 1 && (lastPos < i3 && (out += str.slice(lastPos, i3)), lastPos = i3 + 1, out += hexTable[c3]), ++i3 === len)
              break outer;
            c3 = str.charCodeAt(i3);
          }
          if (lastPos < i3 && (out += str.slice(lastPos, i3)), c3 < 2048) {
            lastPos = i3 + 1, out += hexTable[192 | c3 >> 6] + hexTable[128 | c3 & 63];
            continue;
          }
          if (c3 < 55296 || c3 >= 57344) {
            lastPos = i3 + 1, out += hexTable[224 | c3 >> 12] + hexTable[128 | c3 >> 6 & 63] + hexTable[128 | c3 & 63];
            continue;
          }
          if (++i3, i3 >= len)
            throw new Error("URI malformed");
          let c22 = str.charCodeAt(i3) & 1023;
          lastPos = i3 + 1, c3 = 65536 + ((c3 & 1023) << 10 | c22), out += hexTable[240 | c3 >> 18] + hexTable[128 | c3 >> 12 & 63] + hexTable[128 | c3 >> 6 & 63] + hexTable[128 | c3 & 63];
        }
        return lastPos === 0 ? str : lastPos < len ? out + str.slice(lastPos) : out;
      }
    }
  }), require_shared = __commonJS({
    "../../node_modules/picoquery/lib/shared.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.defaultOptions = exports.defaultShouldSerializeObject = exports.defaultValueSerializer = void 0;
      var string_util_js_1 = require_string_util(), defaultValueSerializer = (value2) => {
        switch (typeof value2) {
          case "string":
            return (0, string_util_js_1.encodeString)(value2);
          case "bigint":
          case "boolean":
            return "" + value2;
          case "number":
            if (Number.isFinite(value2))
              return value2 < 1e21 ? "" + value2 : (0, string_util_js_1.encodeString)("" + value2);
            break;
        }
        return value2 instanceof Date ? (0, string_util_js_1.encodeString)(value2.toISOString()) : "";
      };
      exports.defaultValueSerializer = defaultValueSerializer;
      var defaultShouldSerializeObject = (val) => val instanceof Date;
      exports.defaultShouldSerializeObject = defaultShouldSerializeObject;
      var identityFunc = (v3) => v3;
      exports.defaultOptions = {
        nesting: !0,
        nestingSyntax: "dot",
        arrayRepeat: !1,
        arrayRepeatSyntax: "repeat",
        delimiter: 38,
        valueDeserializer: identityFunc,
        valueSerializer: exports.defaultValueSerializer,
        keyDeserializer: identityFunc,
        shouldSerializeObject: exports.defaultShouldSerializeObject
      };
    }
  }), require_object_util = __commonJS({
    "../../node_modules/picoquery/lib/object-util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.getDeepObject = getDeepObject, exports.stringifyObject = stringifyObject;
      var shared_js_1 = require_shared(), string_util_js_1 = require_string_util();
      function isPrototypeKey(value2) {
        return value2 === "__proto__" || value2 === "constructor" || value2 === "prototype";
      }
      function getDeepObject(obj, key, nextKey, forceObject, forceArray) {
        if (isPrototypeKey(key))
          return obj;
        let currObj = obj[key];
        return typeof currObj == "object" && currObj !== null ? currObj : !forceObject && (forceArray || typeof nextKey == "number" || typeof nextKey == "string" && nextKey * 0 === 0 && nextKey.indexOf(".") === -1) ? obj[key] = [] : obj[key] = {};
      }
      var MAX_DEPTH = 20, strBracketPair = "[]", strBracketLeft = "[", strBracketRight = "]", strDot = ".";
      function stringifyObject(obj, options, depth = 0, parentKey, isProbableArray) {
        let { nestingSyntax = shared_js_1.defaultOptions.nestingSyntax, arrayRepeat = shared_js_1.defaultOptions.arrayRepeat, arrayRepeatSyntax = shared_js_1.defaultOptions.arrayRepeatSyntax, nesting = shared_js_1.defaultOptions.nesting, delimiter = shared_js_1.defaultOptions.delimiter, valueSerializer = shared_js_1.defaultOptions.valueSerializer, shouldSerializeObject = shared_js_1.defaultOptions.shouldSerializeObject } = options, strDelimiter = typeof delimiter == "number" ? String.fromCharCode(delimiter) : delimiter, useArrayRepeatKey = isProbableArray === !0 && arrayRepeat, shouldUseDot = nestingSyntax === "dot" || nestingSyntax === "js" && !isProbableArray;
        if (depth > MAX_DEPTH)
          return "";
        let result = "", firstKey = !0, valueIsProbableArray = !1;
        for (let key in obj) {
          let value2 = obj[key];
          if (value2 === void 0)
            continue;
          let path;
          parentKey ? (path = parentKey, useArrayRepeatKey ? arrayRepeatSyntax === "bracket" && (path += strBracketPair) : shouldUseDot ? (path += strDot, path += key) : (path += strBracketLeft, path += key, path += strBracketRight)) : path = key, firstKey || (result += strDelimiter), typeof value2 == "object" && value2 !== null && !shouldSerializeObject(value2) ? (valueIsProbableArray = value2.pop !== void 0, (nesting || arrayRepeat && valueIsProbableArray) && (result += stringifyObject(value2, options, depth + 1, path, valueIsProbableArray))) : (result += (0, string_util_js_1.encodeString)(path), result += "=", result += valueSerializer(value2, key)), firstKey && (firstKey = !1);
        }
        return result;
      }
    }
  }), require_decode_uri_component = __commonJS({
    "../../node_modules/picoquery/lib/decode-uri-component.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.decodeURIComponent = decodeURIComponent2;
      var UTF8_ACCEPT = 12, UTF8_REJECT = 0, UTF8_DATA = [
        // The first part of the table maps bytes to character to a transition.
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        4,
        4,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        6,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        8,
        7,
        7,
        10,
        9,
        9,
        9,
        11,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        // The second part of the table maps a state to a new state when adding a
        // transition.
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        12,
        0,
        0,
        0,
        0,
        24,
        36,
        48,
        60,
        72,
        84,
        96,
        0,
        12,
        12,
        12,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        24,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        48,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // The third part maps the current transition to a mask that needs to apply
        // to the byte.
        127,
        63,
        63,
        63,
        0,
        31,
        15,
        15,
        15,
        7,
        7,
        7
      ];
      function decodeURIComponent2(uri) {
        let percentPosition = uri.indexOf("%");
        if (percentPosition === -1)
          return uri;
        let length = uri.length, decoded = "", last = 0, codepoint = 0, startOfOctets = percentPosition, state3 = UTF8_ACCEPT;
        for (; percentPosition > -1 && percentPosition < length; ) {
          let high = hexCodeToInt(uri[percentPosition + 1], 4), low = hexCodeToInt(uri[percentPosition + 2], 0), byte = high | low, type = UTF8_DATA[byte];
          if (state3 = UTF8_DATA[256 + state3 + type], codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type], state3 === UTF8_ACCEPT)
            decoded += uri.slice(last, startOfOctets), decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023)), codepoint = 0, last = percentPosition + 3, percentPosition = startOfOctets = uri.indexOf("%", last);
          else {
            if (state3 === UTF8_REJECT)
              return null;
            if (percentPosition += 3, percentPosition < length && uri.charCodeAt(percentPosition) === 37)
              continue;
            return null;
          }
        }
        return decoded + uri.slice(last);
      }
      var HEX = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        a: 10,
        A: 10,
        b: 11,
        B: 11,
        c: 12,
        C: 12,
        d: 13,
        D: 13,
        e: 14,
        E: 14,
        f: 15,
        F: 15
      };
      function hexCodeToInt(c3, shift) {
        let i3 = HEX[c3];
        return i3 === void 0 ? 255 : i3 << shift;
      }
    }
  }), require_parse = __commonJS({
    "../../node_modules/picoquery/lib/parse.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.numberValueDeserializer = exports.numberKeyDeserializer = void 0, exports.parse = parse5;
      var object_util_js_1 = require_object_util(), shared_js_1 = require_shared(), decode_uri_component_js_1 = require_decode_uri_component(), numberKeyDeserializer = (key) => {
        let asNumber = Number(key);
        return Number.isNaN(asNumber) ? key : asNumber;
      };
      exports.numberKeyDeserializer = numberKeyDeserializer;
      var numberValueDeserializer = (value2) => {
        let asNumber = Number(value2);
        return Number.isNaN(asNumber) ? value2 : asNumber;
      };
      exports.numberValueDeserializer = numberValueDeserializer;
      var regexPlus = /\+/g, Empty3 = function() {
      };
      Empty3.prototype = /* @__PURE__ */ Object.create(null);
      function computeKeySlice(input, startIndex, endIndex, keyHasPlus, shouldDecodeKey) {
        let chunk = input.substring(startIndex, endIndex);
        return keyHasPlus && (chunk = chunk.replace(regexPlus, " ")), shouldDecodeKey && (chunk = (0, decode_uri_component_js_1.decodeURIComponent)(chunk) || chunk), chunk;
      }
      function parse5(input, options) {
        let { valueDeserializer = shared_js_1.defaultOptions.valueDeserializer, keyDeserializer = shared_js_1.defaultOptions.keyDeserializer, arrayRepeatSyntax = shared_js_1.defaultOptions.arrayRepeatSyntax, nesting = shared_js_1.defaultOptions.nesting, arrayRepeat = shared_js_1.defaultOptions.arrayRepeat, nestingSyntax = shared_js_1.defaultOptions.nestingSyntax, delimiter = shared_js_1.defaultOptions.delimiter } = options ?? {}, charDelimiter = typeof delimiter == "string" ? delimiter.charCodeAt(0) : delimiter, isJsNestingSyntax = nestingSyntax === "js", result = new Empty3();
        if (typeof input != "string")
          return result;
        let inputLength = input.length, value2 = "", startingIndex = -1, equalityIndex = -1, keySeparatorIndex = -1, currentObj = result, lastKey, currentKey = "", keyChunk = "", shouldDecodeKey = !1, shouldDecodeValue = !1, keyHasPlus = !1, valueHasPlus = !1, keyIsDot = !1, hasBothKeyValuePair = !1, c3 = 0, arrayRepeatBracketIndex = -1, prevIndex = -1, prevChar = -1;
        for (let i3 = 0; i3 < inputLength + 1; i3++) {
          if (c3 = i3 !== inputLength ? input.charCodeAt(i3) : charDelimiter, c3 === charDelimiter) {
            if (hasBothKeyValuePair = equalityIndex > startingIndex, hasBothKeyValuePair || (equalityIndex = i3), keySeparatorIndex !== equalityIndex - 1 && (keyChunk = computeKeySlice(input, keySeparatorIndex + 1, arrayRepeatBracketIndex > -1 ? arrayRepeatBracketIndex : equalityIndex, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax && keyIsDot, void 0))), hasBothKeyValuePair || currentKey !== "") {
              hasBothKeyValuePair && (value2 = input.slice(equalityIndex + 1, i3), valueHasPlus && (value2 = value2.replace(regexPlus, " ")), shouldDecodeValue && (value2 = (0, decode_uri_component_js_1.decodeURIComponent)(value2) || value2));
              let newValue = valueDeserializer(value2, currentKey);
              if (arrayRepeat) {
                let currentValue = currentObj[currentKey];
                currentValue === void 0 ? arrayRepeatBracketIndex > -1 ? currentObj[currentKey] = [newValue] : currentObj[currentKey] = newValue : currentValue.pop ? currentValue.push(newValue) : currentObj[currentKey] = [currentValue, newValue];
              } else
                currentObj[currentKey] = newValue;
            }
            value2 = "", startingIndex = i3, equalityIndex = i3, shouldDecodeKey = !1, shouldDecodeValue = !1, keyHasPlus = !1, valueHasPlus = !1, keyIsDot = !1, arrayRepeatBracketIndex = -1, keySeparatorIndex = i3, currentObj = result, lastKey = void 0, currentKey = "";
          } else c3 === 93 ? (arrayRepeat && arrayRepeatSyntax === "bracket" && prevChar === 91 && (arrayRepeatBracketIndex = prevIndex), nesting && (nestingSyntax === "index" || isJsNestingSyntax) && equalityIndex <= startingIndex && (keySeparatorIndex !== prevIndex && (keyChunk = computeKeySlice(input, keySeparatorIndex + 1, i3, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, void 0, void 0)), lastKey = currentKey, keyHasPlus = !1, shouldDecodeKey = !1), keySeparatorIndex = i3, keyIsDot = !1)) : c3 === 46 ? nesting && (nestingSyntax === "dot" || isJsNestingSyntax) && equalityIndex <= startingIndex && (keySeparatorIndex !== prevIndex && (keyChunk = computeKeySlice(input, keySeparatorIndex + 1, i3, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax)), lastKey = currentKey, keyHasPlus = !1, shouldDecodeKey = !1), keyIsDot = !0, keySeparatorIndex = i3) : c3 === 91 ? nesting && (nestingSyntax === "index" || isJsNestingSyntax) && equalityIndex <= startingIndex && (keySeparatorIndex !== prevIndex && (keyChunk = computeKeySlice(input, keySeparatorIndex + 1, i3, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), isJsNestingSyntax && lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax)), lastKey = currentKey, keyHasPlus = !1, shouldDecodeKey = !1, keyIsDot = !1), keySeparatorIndex = i3) : c3 === 61 ? equalityIndex <= startingIndex ? equalityIndex = i3 : shouldDecodeValue = !0 : c3 === 43 ? equalityIndex > startingIndex ? valueHasPlus = !0 : keyHasPlus = !0 : c3 === 37 && (equalityIndex > startingIndex ? shouldDecodeValue = !0 : shouldDecodeKey = !0);
          prevIndex = i3, prevChar = c3;
        }
        return result;
      }
    }
  }), require_stringify = __commonJS({
    "../../node_modules/picoquery/lib/stringify.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.stringify = stringify4;
      var object_util_js_1 = require_object_util();
      function stringify4(input, options) {
        if (input === null || typeof input != "object")
          return "";
        let optionsObj = options ?? {};
        return (0, object_util_js_1.stringifyObject)(input, optionsObj);
      }
    }
  }), require_main = __commonJS({
    "../../node_modules/picoquery/lib/main.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o2, m3, k3, k22) {
        k22 === void 0 && (k22 = k3);
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
          return m3[k3];
        } }), Object.defineProperty(o2, k22, desc);
      }) : (function(o2, m3, k3, k22) {
        k22 === void 0 && (k22 = k3), o2[k22] = m3[k3];
      })), __exportStar = exports && exports.__exportStar || function(m3, exports2) {
        for (var p4 in m3) p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4) && __createBinding(exports2, m3, p4);
      };
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.stringify = exports.parse = void 0;
      var parse_js_1 = require_parse();
      Object.defineProperty(exports, "parse", { enumerable: !0, get: function() {
        return parse_js_1.parse;
      } });
      var stringify_js_1 = require_stringify();
      Object.defineProperty(exports, "stringify", { enumerable: !0, get: function() {
        return stringify_js_1.stringify;
      } }), __exportStar(require_shared(), exports);
    }
  });

  // node_modules/storybook/dist/_browser-chunks/chunk-SI6AKD4S.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_A242L54C();

  // node_modules/storybook/dist/preview-errors.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/storybook/dist/_browser-chunks/chunk-POMIZRJL.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/storybook/dist/_browser-chunks/chunk-JVRDBUUP.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  function parseErrorCode({
    code,
    category
  }) {
    let paddedCode = String(code).padStart(4, "0");
    return `SB_${category}_${paddedCode}`;
  }
  function appendErrorRef(url) {
    if (/^(?!.*storybook\.js\.org)|[?&]ref=error\b/.test(url))
      return url;
    try {
      let urlObj = new URL(url);
      return urlObj.searchParams.set("ref", "error"), urlObj.toString();
    } catch {
      return url;
    }
  }
  var StorybookError = class _StorybookError extends Error {
    constructor(props) {
      super(_StorybookError.getFullMessage(props)), this.data = {}, this.fromStorybook = !0, this.isHandledError = !1, this.subErrors = [], this.category = props.category, this.documentation = props.documentation ?? !1, this.code = props.code, this.isHandledError = props.isHandledError ?? !1, this.name = props.name, this.subErrors = props.subErrors ?? [];
    }
    get fullErrorCode() {
      return parseErrorCode({ code: this.code, category: this.category });
    }
    /** Overrides the default `Error.name` property in the format: SB_<CATEGORY>_<CODE>. */
    get name() {
      let errorName = this._name || this.constructor.name;
      return `${this.fullErrorCode} (${errorName})`;
    }
    set name(name) {
      this._name = name;
    }
    /** Generates the error message along with additional documentation link (if applicable). */
    static getFullMessage({
      documentation,
      code,
      category,
      message
    }) {
      let page;
      return documentation === !0 ? page = `https://storybook.js.org/error/${parseErrorCode({ code, category })}?ref=error` : typeof documentation == "string" ? page = appendErrorRef(documentation) : Array.isArray(documentation) && (page = `
${documentation.map((doc) => `	- ${appendErrorRef(doc)}`).join(`
`)}`), `${message}${page != null ? `

More info: ${page}
` : ""}`;
    }
  };

  // node_modules/storybook/dist/_browser-chunks/chunk-3LY4VQVK.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  function dedent(templ) {
    for (var values = [], _i = 1; _i < arguments.length; _i++)
      values[_i - 1] = arguments[_i];
    var strings = Array.from(typeof templ == "string" ? [templ] : templ);
    strings[strings.length - 1] = strings[strings.length - 1].replace(/\r?\n([\t ]*)$/, "");
    var indentLengths = strings.reduce(function(arr, str) {
      var matches2 = str.match(/\n([\t ]+|(?!\s).)/g);
      return matches2 ? arr.concat(matches2.map(function(match) {
        var _a, _b;
        return (_b = (_a = match.match(/[\t ]/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
      })) : arr;
    }, []);
    if (indentLengths.length) {
      var pattern_1 = new RegExp(`
[	 ]{` + Math.min.apply(Math, indentLengths) + "}", "g");
      strings = strings.map(function(str) {
        return str.replace(pattern_1, `
`);
      });
    }
    strings[0] = strings[0].replace(/^\r?\n/, "");
    var string = strings[0];
    return values.forEach(function(value2, i3) {
      var endentations = string.match(/(?:^|\n)( *)$/), endentation = endentations ? endentations[1] : "", indentedValue = value2;
      typeof value2 == "string" && value2.includes(`
`) && (indentedValue = String(value2).split(`
`).map(function(str, i22) {
        return i22 === 0 ? str : "" + endentation + str;
      }).join(`
`)), string += indentedValue + strings[i3 + 1];
    }), string;
  }

  // node_modules/storybook/dist/_browser-chunks/chunk-POMIZRJL.js
  var Category = ((Category2) => (Category2.BLOCKS = "BLOCKS", Category2.DOCS_TOOLS = "DOCS-TOOLS", Category2.PREVIEW_CLIENT_LOGGER = "PREVIEW_CLIENT-LOGGER", Category2.PREVIEW_CHANNELS = "PREVIEW_CHANNELS", Category2.PREVIEW_CORE_EVENTS = "PREVIEW_CORE-EVENTS", Category2.PREVIEW_INSTRUMENTER = "PREVIEW_INSTRUMENTER", Category2.PREVIEW_API = "PREVIEW_API", Category2.PREVIEW_REACT_DOM_SHIM = "PREVIEW_REACT-DOM-SHIM", Category2.PREVIEW_ROUTER = "PREVIEW_ROUTER", Category2.PREVIEW_THEMING = "PREVIEW_THEMING", Category2.RENDERER_HTML = "RENDERER_HTML", Category2.RENDERER_PREACT = "RENDERER_PREACT", Category2.RENDERER_REACT = "RENDERER_REACT", Category2.RENDERER_SERVER = "RENDERER_SERVER", Category2.RENDERER_SVELTE = "RENDERER_SVELTE", Category2.RENDERER_VUE = "RENDERER_VUE", Category2.RENDERER_VUE3 = "RENDERER_VUE3", Category2.RENDERER_WEB_COMPONENTS = "RENDERER_WEB-COMPONENTS", Category2.FRAMEWORK_NEXTJS = "FRAMEWORK_NEXTJS", Category2.ADDON_VITEST = "ADDON_VITEST", Category2.ADDON_A11Y = "ADDON_A11Y", Category2))(Category || {});
  var ImplicitActionsDuringRendering = class extends StorybookError {
    constructor(data) {
      super({
        name: "ImplicitActionsDuringRendering",
        category: "PREVIEW_API",
        code: 2,
        documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#using-implicit-actions-during-rendering-is-deprecated-for-example-in-the-play-function",
        message: dedent`
        We detected that you use an implicit action arg while ${data.phase} of your story.  
        ${data.deprecated ? `
This is deprecated and won't work in Storybook 8 anymore.
` : ""}
        Please provide an explicit spy to your args like this:
          import { fn } from 'storybook/test';
          ... 
          args: {
           ${data.name}: fn()
          }`
      }), this.data = data;
    }
  };

  // node_modules/storybook/dist/preview-errors.js
  init_chunk_A242L54C();

  // node_modules/storybook/dist/_browser-chunks/chunk-SI6AKD4S.js
  var require_dist = __commonJS({
    "../../node_modules/jsdoc-type-pratt-parser/dist/index.js"(exports, module) {
      (function(global2, factory) {
        typeof exports == "object" && typeof module < "u" ? factory(exports) : typeof define == "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis < "u" ? globalThis : global2 || self, factory(global2.jtpp = {}));
      })(exports, (function(exports2) {
        "use strict";
        function tokenToString(token) {
          return token.text !== void 0 && token.text !== "" ? `'${token.type}' with value '${token.text}'` : `'${token.type}'`;
        }
        class NoParsletFoundError extends Error {
          constructor(token) {
            super(`No parslet found for token: ${tokenToString(token)}`), this.token = token, Object.setPrototypeOf(this, NoParsletFoundError.prototype);
          }
          getToken() {
            return this.token;
          }
        }
        class EarlyEndOfParseError extends Error {
          constructor(token) {
            super(`The parsing ended early. The next token was: ${tokenToString(token)}`), this.token = token, Object.setPrototypeOf(this, EarlyEndOfParseError.prototype);
          }
          getToken() {
            return this.token;
          }
        }
        class UnexpectedTypeError extends Error {
          constructor(result, message) {
            let error = `Unexpected type: '${result.type}'.`;
            message !== void 0 && (error += ` Message: ${message}`), super(error), Object.setPrototypeOf(this, UnexpectedTypeError.prototype);
          }
        }
        function makePunctuationRule(type) {
          return (text) => text.startsWith(type) ? { type, text: type } : null;
        }
        function getQuoted(text) {
          let position = 0, char, mark = text[0], escaped = !1;
          if (mark !== "'" && mark !== '"')
            return null;
          for (; position < text.length; ) {
            if (position++, char = text[position], !escaped && char === mark) {
              position++;
              break;
            }
            escaped = !escaped && char === "\\";
          }
          if (char !== mark)
            throw new Error("Unterminated String");
          return text.slice(0, position);
        }
        let identifierStartRegex = new RegExp("[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u"), identifierContinueRegex = new RegExp("[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u");
        function getIdentifier(text) {
          let char = text[0];
          if (!identifierStartRegex.test(char))
            return null;
          let position = 1;
          do {
            if (char = text[position], !identifierContinueRegex.test(char))
              break;
            position++;
          } while (position < text.length);
          return text.slice(0, position);
        }
        let numberRegex = /^(NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity))/;
        function getNumber(text) {
          var _a, _b;
          return (_b = (_a = numberRegex.exec(text)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;
        }
        let identifierRule = (text) => {
          let value2 = getIdentifier(text);
          return value2 == null ? null : {
            type: "Identifier",
            text: value2
          };
        };
        function makeKeyWordRule(type) {
          return (text) => {
            if (!text.startsWith(type))
              return null;
            let prepends = text[type.length];
            return prepends !== void 0 && identifierContinueRegex.test(prepends) ? null : {
              type,
              text: type
            };
          };
        }
        let stringValueRule = (text) => {
          let value2 = getQuoted(text);
          return value2 == null ? null : {
            type: "StringValue",
            text: value2
          };
        }, eofRule = (text) => text.length > 0 ? null : {
          type: "EOF",
          text: ""
        }, numberRule = (text) => {
          let value2 = getNumber(text);
          return value2 === null ? null : {
            type: "Number",
            text: value2
          };
        }, rules = [
          eofRule,
          makePunctuationRule("=>"),
          makePunctuationRule("("),
          makePunctuationRule(")"),
          makePunctuationRule("{"),
          makePunctuationRule("}"),
          makePunctuationRule("["),
          makePunctuationRule("]"),
          makePunctuationRule("|"),
          makePunctuationRule("&"),
          makePunctuationRule("<"),
          makePunctuationRule(">"),
          makePunctuationRule(","),
          makePunctuationRule(";"),
          makePunctuationRule("*"),
          makePunctuationRule("?"),
          makePunctuationRule("!"),
          makePunctuationRule("="),
          makePunctuationRule(":"),
          makePunctuationRule("..."),
          makePunctuationRule("."),
          makePunctuationRule("#"),
          makePunctuationRule("~"),
          makePunctuationRule("/"),
          makePunctuationRule("@"),
          makeKeyWordRule("undefined"),
          makeKeyWordRule("null"),
          makeKeyWordRule("function"),
          makeKeyWordRule("this"),
          makeKeyWordRule("new"),
          makeKeyWordRule("module"),
          makeKeyWordRule("event"),
          makeKeyWordRule("extends"),
          makeKeyWordRule("external"),
          makeKeyWordRule("infer"),
          makeKeyWordRule("typeof"),
          makeKeyWordRule("keyof"),
          makeKeyWordRule("readonly"),
          makeKeyWordRule("import"),
          makeKeyWordRule("is"),
          makeKeyWordRule("in"),
          makeKeyWordRule("asserts"),
          numberRule,
          identifierRule,
          stringValueRule
        ], breakingWhitespaceRegex = /^\s*\n\s*/;
        class Lexer {
          static create(text) {
            let current = this.read(text);
            text = current.text;
            let next = this.read(text);
            return text = next.text, new Lexer(text, void 0, current.token, next.token);
          }
          constructor(text, previous, current, next) {
            this.text = "", this.text = text, this.previous = previous, this.current = current, this.next = next;
          }
          static read(text, startOfLine = !1) {
            startOfLine = startOfLine || breakingWhitespaceRegex.test(text), text = text.trim();
            for (let rule of rules) {
              let partial2 = rule(text);
              if (partial2 !== null) {
                let token = Object.assign(Object.assign({}, partial2), { startOfLine });
                return text = text.slice(token.text.length), { text, token };
              }
            }
            throw new Error("Unexpected Token " + text);
          }
          advance() {
            let next = Lexer.read(this.text);
            return new Lexer(next.text, this.current, this.next, next.token);
          }
        }
        function assertRootResult(result) {
          if (result === void 0)
            throw new Error("Unexpected undefined");
          if (result.type === "JsdocTypeKeyValue" || result.type === "JsdocTypeParameterList" || result.type === "JsdocTypeProperty" || result.type === "JsdocTypeReadonlyProperty" || result.type === "JsdocTypeObjectField" || result.type === "JsdocTypeJsdocObjectField" || result.type === "JsdocTypeIndexSignature" || result.type === "JsdocTypeMappedType" || result.type === "JsdocTypeTypeParameter")
            throw new UnexpectedTypeError(result);
          return result;
        }
        function assertPlainKeyValueOrRootResult(result) {
          return result.type === "JsdocTypeKeyValue" ? assertPlainKeyValueResult(result) : assertRootResult(result);
        }
        function assertPlainKeyValueOrNameResult(result) {
          return result.type === "JsdocTypeName" ? result : assertPlainKeyValueResult(result);
        }
        function assertPlainKeyValueResult(result) {
          if (result.type !== "JsdocTypeKeyValue")
            throw new UnexpectedTypeError(result);
          return result;
        }
        function assertNumberOrVariadicNameResult(result) {
          var _a;
          if (result.type === "JsdocTypeVariadic") {
            if (((_a = result.element) === null || _a === void 0 ? void 0 : _a.type) === "JsdocTypeName")
              return result;
            throw new UnexpectedTypeError(result);
          }
          if (result.type !== "JsdocTypeNumber" && result.type !== "JsdocTypeName")
            throw new UnexpectedTypeError(result);
          return result;
        }
        function assertArrayOrTupleResult(result) {
          if (result.type === "JsdocTypeTuple" || result.type === "JsdocTypeGeneric" && result.meta.brackets === "square")
            return result;
          throw new UnexpectedTypeError(result);
        }
        function isSquaredProperty(result) {
          return result.type === "JsdocTypeIndexSignature" || result.type === "JsdocTypeMappedType";
        }
        var Precedence;
        (function(Precedence2) {
          Precedence2[Precedence2.ALL = 0] = "ALL", Precedence2[Precedence2.PARAMETER_LIST = 1] = "PARAMETER_LIST", Precedence2[Precedence2.OBJECT = 2] = "OBJECT", Precedence2[Precedence2.KEY_VALUE = 3] = "KEY_VALUE", Precedence2[Precedence2.INDEX_BRACKETS = 4] = "INDEX_BRACKETS", Precedence2[Precedence2.UNION = 5] = "UNION", Precedence2[Precedence2.INTERSECTION = 6] = "INTERSECTION", Precedence2[Precedence2.PREFIX = 7] = "PREFIX", Precedence2[Precedence2.INFIX = 8] = "INFIX", Precedence2[Precedence2.TUPLE = 9] = "TUPLE", Precedence2[Precedence2.SYMBOL = 10] = "SYMBOL", Precedence2[Precedence2.OPTIONAL = 11] = "OPTIONAL", Precedence2[Precedence2.NULLABLE = 12] = "NULLABLE", Precedence2[Precedence2.KEY_OF_TYPE_OF = 13] = "KEY_OF_TYPE_OF", Precedence2[Precedence2.FUNCTION = 14] = "FUNCTION", Precedence2[Precedence2.ARROW = 15] = "ARROW", Precedence2[Precedence2.ARRAY_BRACKETS = 16] = "ARRAY_BRACKETS", Precedence2[Precedence2.GENERIC = 17] = "GENERIC", Precedence2[Precedence2.NAME_PATH = 18] = "NAME_PATH", Precedence2[Precedence2.PARENTHESIS = 19] = "PARENTHESIS", Precedence2[Precedence2.SPECIAL_TYPES = 20] = "SPECIAL_TYPES";
        })(Precedence || (Precedence = {}));
        class Parser {
          constructor(grammar, textOrLexer, baseParser) {
            this.grammar = grammar, typeof textOrLexer == "string" ? this._lexer = Lexer.create(textOrLexer) : this._lexer = textOrLexer, this.baseParser = baseParser;
          }
          get lexer() {
            return this._lexer;
          }
          /**
           * Parses a given string and throws an error if the parse ended before the end of the string.
           */
          parse() {
            let result = this.parseType(Precedence.ALL);
            if (this.lexer.current.type !== "EOF")
              throw new EarlyEndOfParseError(this.lexer.current);
            return result;
          }
          /**
           * Parses with the current lexer and asserts that the result is a {@link RootResult}.
           */
          parseType(precedence) {
            return assertRootResult(this.parseIntermediateType(precedence));
          }
          /**
           * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues
           * to parse the state in the infix step.
           */
          parseIntermediateType(precedence) {
            let result = this.tryParslets(null, precedence);
            if (result === null)
              throw new NoParsletFoundError(this.lexer.current);
            return this.parseInfixIntermediateType(result, precedence);
          }
          /**
           * In the infix parsing step the parser continues to parse the current state with all parslets until none returns
           * a result.
           */
          parseInfixIntermediateType(left, precedence) {
            let result = this.tryParslets(left, precedence);
            for (; result !== null; )
              left = result, result = this.tryParslets(left, precedence);
            return left;
          }
          /**
           * Tries to parse the current state with all parslets in the grammar and returns the first non null result.
           */
          tryParslets(left, precedence) {
            for (let parslet of this.grammar) {
              let result = parslet(this, precedence, left);
              if (result !== null)
                return result;
            }
            return null;
          }
          /**
           * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was
           * advanced.
           */
          consume(types2) {
            return Array.isArray(types2) || (types2 = [types2]), types2.includes(this.lexer.current.type) ? (this._lexer = this.lexer.advance(), !0) : !1;
          }
          acceptLexerState(parser) {
            this._lexer = parser.lexer;
          }
        }
        function isQuestionMarkUnknownType(next) {
          return next === "}" || next === "EOF" || next === "|" || next === "," || next === ")" || next === ">";
        }
        let nullableParslet = (parser, precedence, left) => {
          let type = parser.lexer.current.type, next = parser.lexer.next.type;
          return left == null && type === "?" && !isQuestionMarkUnknownType(next) || left != null && type === "?" ? (parser.consume("?"), left == null ? {
            type: "JsdocTypeNullable",
            element: parser.parseType(Precedence.NULLABLE),
            meta: {
              position: "prefix"
            }
          } : {
            type: "JsdocTypeNullable",
            element: assertRootResult(left),
            meta: {
              position: "suffix"
            }
          }) : null;
        };
        function composeParslet(options) {
          let parslet = (parser, curPrecedence, left) => {
            let type = parser.lexer.current.type, next = parser.lexer.next.type;
            if (left === null) {
              if ("parsePrefix" in options && options.accept(type, next))
                return options.parsePrefix(parser);
            } else if ("parseInfix" in options && options.precedence > curPrecedence && options.accept(type, next))
              return options.parseInfix(parser, left);
            return null;
          };
          return Object.defineProperty(parslet, "name", {
            value: options.name
          }), parslet;
        }
        let optionalParslet = composeParslet({
          name: "optionalParslet",
          accept: (type) => type === "=",
          precedence: Precedence.OPTIONAL,
          parsePrefix: (parser) => (parser.consume("="), {
            type: "JsdocTypeOptional",
            element: parser.parseType(Precedence.OPTIONAL),
            meta: {
              position: "prefix"
            }
          }),
          parseInfix: (parser, left) => (parser.consume("="), {
            type: "JsdocTypeOptional",
            element: assertRootResult(left),
            meta: {
              position: "suffix"
            }
          })
        }), numberParslet = composeParslet({
          name: "numberParslet",
          accept: (type) => type === "Number",
          parsePrefix: (parser) => {
            let value2 = parseFloat(parser.lexer.current.text);
            return parser.consume("Number"), {
              type: "JsdocTypeNumber",
              value: value2
            };
          }
        }), parenthesisParslet = composeParslet({
          name: "parenthesisParslet",
          accept: (type) => type === "(",
          parsePrefix: (parser) => {
            if (parser.consume("("), parser.consume(")"))
              return {
                type: "JsdocTypeParameterList",
                elements: []
              };
            let result = parser.parseIntermediateType(Precedence.ALL);
            if (!parser.consume(")"))
              throw new Error("Unterminated parenthesis");
            return result.type === "JsdocTypeParameterList" ? result : result.type === "JsdocTypeKeyValue" ? {
              type: "JsdocTypeParameterList",
              elements: [result]
            } : {
              type: "JsdocTypeParenthesis",
              element: assertRootResult(result)
            };
          }
        }), specialTypesParslet = composeParslet({
          name: "specialTypesParslet",
          accept: (type, next) => type === "?" && isQuestionMarkUnknownType(next) || type === "null" || type === "undefined" || type === "*",
          parsePrefix: (parser) => {
            if (parser.consume("null"))
              return {
                type: "JsdocTypeNull"
              };
            if (parser.consume("undefined"))
              return {
                type: "JsdocTypeUndefined"
              };
            if (parser.consume("*"))
              return {
                type: "JsdocTypeAny"
              };
            if (parser.consume("?"))
              return {
                type: "JsdocTypeUnknown"
              };
            throw new Error("Unacceptable token: " + parser.lexer.current.text);
          }
        }), notNullableParslet = composeParslet({
          name: "notNullableParslet",
          accept: (type) => type === "!",
          precedence: Precedence.NULLABLE,
          parsePrefix: (parser) => (parser.consume("!"), {
            type: "JsdocTypeNotNullable",
            element: parser.parseType(Precedence.NULLABLE),
            meta: {
              position: "prefix"
            }
          }),
          parseInfix: (parser, left) => (parser.consume("!"), {
            type: "JsdocTypeNotNullable",
            element: assertRootResult(left),
            meta: {
              position: "suffix"
            }
          })
        });
        function createParameterListParslet({ allowTrailingComma }) {
          return composeParslet({
            name: "parameterListParslet",
            accept: (type) => type === ",",
            precedence: Precedence.PARAMETER_LIST,
            parseInfix: (parser, left) => {
              let elements = [
                assertPlainKeyValueOrRootResult(left)
              ];
              parser.consume(",");
              do
                try {
                  let next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);
                  elements.push(assertPlainKeyValueOrRootResult(next));
                } catch (e) {
                  if (e instanceof NoParsletFoundError)
                    break;
                  throw e;
                }
              while (parser.consume(","));
              if (elements.length > 0 && elements.slice(0, -1).some((e) => e.type === "JsdocTypeVariadic"))
                throw new Error("Only the last parameter may be a rest parameter");
              return {
                type: "JsdocTypeParameterList",
                elements
              };
            }
          });
        }
        let genericParslet = composeParslet({
          name: "genericParslet",
          accept: (type, next) => type === "<" || type === "." && next === "<",
          precedence: Precedence.GENERIC,
          parseInfix: (parser, left) => {
            let dot = parser.consume(".");
            parser.consume("<");
            let objects = [], infer = !1;
            if (parser.consume("infer")) {
              infer = !0;
              let left2 = parser.parseIntermediateType(Precedence.SYMBOL);
              if (left2.type !== "JsdocTypeName")
                throw new UnexpectedTypeError(left2, "A typescript asserts always has to have a name on the left side.");
              objects.push(left2);
            } else
              do
                objects.push(parser.parseType(Precedence.PARAMETER_LIST));
              while (parser.consume(","));
            if (!parser.consume(">"))
              throw new Error("Unterminated generic parameter list");
            return Object.assign(Object.assign({ type: "JsdocTypeGeneric", left: assertRootResult(left), elements: objects }, infer ? { infer: !0 } : {}), { meta: {
              brackets: "angle",
              dot
            } });
          }
        }), unionParslet = composeParslet({
          name: "unionParslet",
          accept: (type) => type === "|",
          precedence: Precedence.UNION,
          parseInfix: (parser, left) => {
            parser.consume("|");
            let elements = [];
            do
              elements.push(parser.parseType(Precedence.UNION));
            while (parser.consume("|"));
            return {
              type: "JsdocTypeUnion",
              elements: [assertRootResult(left), ...elements]
            };
          }
        }), baseGrammar = [
          nullableParslet,
          optionalParslet,
          numberParslet,
          parenthesisParslet,
          specialTypesParslet,
          notNullableParslet,
          createParameterListParslet({
            allowTrailingComma: !0
          }),
          genericParslet,
          unionParslet,
          optionalParslet
        ];
        function createNamePathParslet({ allowSquareBracketsOnAnyType, allowJsdocNamePaths, pathGrammar: pathGrammar2 }) {
          return function(parser, precedence, left) {
            if (left == null || precedence >= Precedence.NAME_PATH)
              return null;
            let type = parser.lexer.current.type, next = parser.lexer.next.type;
            if (!(type === "." && next !== "<" || type === "[" && (allowSquareBracketsOnAnyType || left.type === "JsdocTypeName") || allowJsdocNamePaths && (type === "~" || type === "#")))
              return null;
            let pathType, brackets = !1;
            parser.consume(".") ? pathType = "property" : parser.consume("[") ? (pathType = "property-brackets", brackets = !0) : parser.consume("~") ? pathType = "inner" : (parser.consume("#"), pathType = "instance");
            let pathParser = pathGrammar2 !== null ? new Parser(pathGrammar2, parser.lexer, parser) : parser, parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);
            parser.acceptLexerState(pathParser);
            let right;
            switch (parsed.type) {
              case "JsdocTypeName":
                right = {
                  type: "JsdocTypeProperty",
                  value: parsed.value,
                  meta: {
                    quote: void 0
                  }
                };
                break;
              case "JsdocTypeNumber":
                right = {
                  type: "JsdocTypeProperty",
                  value: parsed.value.toString(10),
                  meta: {
                    quote: void 0
                  }
                };
                break;
              case "JsdocTypeStringValue":
                right = {
                  type: "JsdocTypeProperty",
                  value: parsed.value,
                  meta: {
                    quote: parsed.meta.quote
                  }
                };
                break;
              case "JsdocTypeSpecialNamePath":
                if (parsed.specialType === "event")
                  right = parsed;
                else
                  throw new UnexpectedTypeError(parsed, "Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'");
                break;
              default:
                throw new UnexpectedTypeError(parsed, "Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'");
            }
            if (brackets && !parser.consume("]")) {
              let token = parser.lexer.current;
              throw new Error(`Unterminated square brackets. Next token is '${token.type}' with text '${token.text}'`);
            }
            return {
              type: "JsdocTypeNamePath",
              left: assertRootResult(left),
              right,
              pathType
            };
          };
        }
        function createNameParslet({ allowedAdditionalTokens }) {
          return composeParslet({
            name: "nameParslet",
            accept: (type) => type === "Identifier" || type === "this" || type === "new" || allowedAdditionalTokens.includes(type),
            parsePrefix: (parser) => {
              let { type, text } = parser.lexer.current;
              return parser.consume(type), {
                type: "JsdocTypeName",
                value: text
              };
            }
          });
        }
        let stringValueParslet = composeParslet({
          name: "stringValueParslet",
          accept: (type) => type === "StringValue",
          parsePrefix: (parser) => {
            let text = parser.lexer.current.text;
            return parser.consume("StringValue"), {
              type: "JsdocTypeStringValue",
              value: text.slice(1, -1),
              meta: {
                quote: text[0] === "'" ? "single" : "double"
              }
            };
          }
        });
        function createSpecialNamePathParslet({ pathGrammar: pathGrammar2, allowedTypes }) {
          return composeParslet({
            name: "specialNamePathParslet",
            accept: (type) => allowedTypes.includes(type),
            parsePrefix: (parser) => {
              let type = parser.lexer.current.type;
              if (parser.consume(type), !parser.consume(":"))
                return {
                  type: "JsdocTypeName",
                  value: type
                };
              let result, token = parser.lexer.current;
              if (parser.consume("StringValue"))
                result = {
                  type: "JsdocTypeSpecialNamePath",
                  value: token.text.slice(1, -1),
                  specialType: type,
                  meta: {
                    quote: token.text[0] === "'" ? "single" : "double"
                  }
                };
              else {
                let value2 = "", allowed = ["Identifier", "@", "/"];
                for (; allowed.some((type2) => parser.consume(type2)); )
                  value2 += token.text, token = parser.lexer.current;
                result = {
                  type: "JsdocTypeSpecialNamePath",
                  value: value2,
                  specialType: type,
                  meta: {
                    quote: void 0
                  }
                };
              }
              let moduleParser = new Parser(pathGrammar2, parser.lexer, parser), moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);
              return parser.acceptLexerState(moduleParser), assertRootResult(moduleResult);
            }
          });
        }
        let basePathGrammar = [
          createNameParslet({
            allowedAdditionalTokens: ["external", "module"]
          }),
          stringValueParslet,
          numberParslet,
          createNamePathParslet({
            allowSquareBracketsOnAnyType: !1,
            allowJsdocNamePaths: !0,
            pathGrammar: null
          })
        ], pathGrammar = [
          ...basePathGrammar,
          createSpecialNamePathParslet({
            allowedTypes: ["event"],
            pathGrammar: basePathGrammar
          })
        ];
        function getParameters(value2) {
          let parameters2;
          if (value2.type === "JsdocTypeParameterList")
            parameters2 = value2.elements;
          else if (value2.type === "JsdocTypeParenthesis")
            parameters2 = [value2.element];
          else
            throw new UnexpectedTypeError(value2);
          return parameters2.map((p4) => assertPlainKeyValueOrRootResult(p4));
        }
        function getUnnamedParameters(value2) {
          let parameters2 = getParameters(value2);
          if (parameters2.some((p4) => p4.type === "JsdocTypeKeyValue"))
            throw new Error("No parameter should be named");
          return parameters2;
        }
        function createFunctionParslet({ allowNamedParameters, allowNoReturnType, allowWithoutParenthesis, allowNewAsFunctionKeyword }) {
          return composeParslet({
            name: "functionParslet",
            accept: (type, next) => type === "function" || allowNewAsFunctionKeyword && type === "new" && next === "(",
            parsePrefix: (parser) => {
              let newKeyword = parser.consume("new");
              parser.consume("function");
              let hasParenthesis = parser.lexer.current.type === "(";
              if (!hasParenthesis) {
                if (!allowWithoutParenthesis)
                  throw new Error("function is missing parameter list");
                return {
                  type: "JsdocTypeName",
                  value: "function"
                };
              }
              let result = {
                type: "JsdocTypeFunction",
                parameters: [],
                arrow: !1,
                constructor: newKeyword,
                parenthesis: hasParenthesis
              }, value2 = parser.parseIntermediateType(Precedence.FUNCTION);
              if (allowNamedParameters === void 0)
                result.parameters = getUnnamedParameters(value2);
              else {
                if (newKeyword && value2.type === "JsdocTypeFunction" && value2.arrow)
                  return result = value2, result.constructor = !0, result;
                result.parameters = getParameters(value2);
                for (let p4 of result.parameters)
                  if (p4.type === "JsdocTypeKeyValue" && !allowNamedParameters.includes(p4.key))
                    throw new Error(`only allowed named parameters are ${allowNamedParameters.join(", ")} but got ${p4.type}`);
              }
              if (parser.consume(":"))
                result.returnType = parser.parseType(Precedence.PREFIX);
              else if (!allowNoReturnType)
                throw new Error("function is missing return type");
              return result;
            }
          });
        }
        function createVariadicParslet({ allowPostfix, allowEnclosingBrackets }) {
          return composeParslet({
            name: "variadicParslet",
            accept: (type) => type === "...",
            precedence: Precedence.PREFIX,
            parsePrefix: (parser) => {
              parser.consume("...");
              let brackets = allowEnclosingBrackets && parser.consume("[");
              try {
                let element = parser.parseType(Precedence.PREFIX);
                if (brackets && !parser.consume("]"))
                  throw new Error("Unterminated variadic type. Missing ']'");
                return {
                  type: "JsdocTypeVariadic",
                  element: assertRootResult(element),
                  meta: {
                    position: "prefix",
                    squareBrackets: brackets
                  }
                };
              } catch (e) {
                if (e instanceof NoParsletFoundError) {
                  if (brackets)
                    throw new Error("Empty square brackets for variadic are not allowed.");
                  return {
                    type: "JsdocTypeVariadic",
                    meta: {
                      position: void 0,
                      squareBrackets: !1
                    }
                  };
                } else
                  throw e;
              }
            },
            parseInfix: allowPostfix ? (parser, left) => (parser.consume("..."), {
              type: "JsdocTypeVariadic",
              element: assertRootResult(left),
              meta: {
                position: "suffix",
                squareBrackets: !1
              }
            }) : void 0
          });
        }
        let symbolParslet = composeParslet({
          name: "symbolParslet",
          accept: (type) => type === "(",
          precedence: Precedence.SYMBOL,
          parseInfix: (parser, left) => {
            if (left.type !== "JsdocTypeName")
              throw new Error("Symbol expects a name on the left side. (Reacting on '(')");
            parser.consume("(");
            let result = {
              type: "JsdocTypeSymbol",
              value: left.value
            };
            if (!parser.consume(")")) {
              let next = parser.parseIntermediateType(Precedence.SYMBOL);
              if (result.element = assertNumberOrVariadicNameResult(next), !parser.consume(")"))
                throw new Error("Symbol does not end after value");
            }
            return result;
          }
        }), arrayBracketsParslet = composeParslet({
          name: "arrayBracketsParslet",
          precedence: Precedence.ARRAY_BRACKETS,
          accept: (type, next) => type === "[" && next === "]",
          parseInfix: (parser, left) => (parser.consume("["), parser.consume("]"), {
            type: "JsdocTypeGeneric",
            left: {
              type: "JsdocTypeName",
              value: "Array"
            },
            elements: [
              assertRootResult(left)
            ],
            meta: {
              brackets: "square",
              dot: !1
            }
          })
        });
        function createObjectParslet({ objectFieldGrammar: objectFieldGrammar2, allowKeyTypes }) {
          return composeParslet({
            name: "objectParslet",
            accept: (type) => type === "{",
            parsePrefix: (parser) => {
              parser.consume("{");
              let result = {
                type: "JsdocTypeObject",
                meta: {
                  separator: "comma"
                },
                elements: []
              };
              if (!parser.consume("}")) {
                let separator, fieldParser = new Parser(objectFieldGrammar2, parser.lexer, parser);
                for (; ; ) {
                  fieldParser.acceptLexerState(parser);
                  let field = fieldParser.parseIntermediateType(Precedence.OBJECT);
                  parser.acceptLexerState(fieldParser), field === void 0 && allowKeyTypes && (field = parser.parseIntermediateType(Precedence.OBJECT));
                  let optional = !1;
                  if (field.type === "JsdocTypeNullable" && (optional = !0, field = field.element), field.type === "JsdocTypeNumber" || field.type === "JsdocTypeName" || field.type === "JsdocTypeStringValue") {
                    let quote2;
                    field.type === "JsdocTypeStringValue" && (quote2 = field.meta.quote), result.elements.push({
                      type: "JsdocTypeObjectField",
                      key: field.value.toString(),
                      right: void 0,
                      optional,
                      readonly: !1,
                      meta: {
                        quote: quote2
                      }
                    });
                  } else if (field.type === "JsdocTypeObjectField" || field.type === "JsdocTypeJsdocObjectField")
                    result.elements.push(field);
                  else
                    throw new UnexpectedTypeError(field);
                  if (parser.lexer.current.startOfLine)
                    separator = "linebreak", parser.consume(",") || parser.consume(";");
                  else if (parser.consume(","))
                    separator = "comma";
                  else if (parser.consume(";"))
                    separator = "semicolon";
                  else
                    break;
                  if (parser.lexer.current.type === "}")
                    break;
                }
                if (result.meta.separator = separator ?? "comma", separator === "linebreak" && (result.meta.propertyIndent = "  "), !parser.consume("}"))
                  throw new Error("Unterminated record type. Missing '}'");
              }
              return result;
            }
          });
        }
        function createObjectFieldParslet({ allowSquaredProperties, allowKeyTypes, allowReadonly, allowOptional }) {
          return composeParslet({
            name: "objectFieldParslet",
            precedence: Precedence.KEY_VALUE,
            accept: (type) => type === ":",
            parseInfix: (parser, left) => {
              var _a;
              let optional = !1, readonlyProperty = !1;
              allowOptional && left.type === "JsdocTypeNullable" && (optional = !0, left = left.element), allowReadonly && left.type === "JsdocTypeReadonlyProperty" && (readonlyProperty = !0, left = left.element);
              let parentParser = (_a = parser.baseParser) !== null && _a !== void 0 ? _a : parser;
              if (parentParser.acceptLexerState(parser), left.type === "JsdocTypeNumber" || left.type === "JsdocTypeName" || left.type === "JsdocTypeStringValue" || isSquaredProperty(left)) {
                if (isSquaredProperty(left) && !allowSquaredProperties)
                  throw new UnexpectedTypeError(left);
                parentParser.consume(":");
                let quote2;
                left.type === "JsdocTypeStringValue" && (quote2 = left.meta.quote);
                let right = parentParser.parseType(Precedence.KEY_VALUE);
                return parser.acceptLexerState(parentParser), {
                  type: "JsdocTypeObjectField",
                  key: isSquaredProperty(left) ? left : left.value.toString(),
                  right,
                  optional,
                  readonly: readonlyProperty,
                  meta: {
                    quote: quote2
                  }
                };
              } else {
                if (!allowKeyTypes)
                  throw new UnexpectedTypeError(left);
                parentParser.consume(":");
                let right = parentParser.parseType(Precedence.KEY_VALUE);
                return parser.acceptLexerState(parentParser), {
                  type: "JsdocTypeJsdocObjectField",
                  left: assertRootResult(left),
                  right
                };
              }
            }
          });
        }
        function createKeyValueParslet({ allowOptional, allowVariadic }) {
          return composeParslet({
            name: "keyValueParslet",
            precedence: Precedence.KEY_VALUE,
            accept: (type) => type === ":",
            parseInfix: (parser, left) => {
              let optional = !1, variadic = !1;
              if (allowOptional && left.type === "JsdocTypeNullable" && (optional = !0, left = left.element), allowVariadic && left.type === "JsdocTypeVariadic" && left.element !== void 0 && (variadic = !0, left = left.element), left.type !== "JsdocTypeName")
                throw new UnexpectedTypeError(left);
              parser.consume(":");
              let right = parser.parseType(Precedence.KEY_VALUE);
              return {
                type: "JsdocTypeKeyValue",
                key: left.value,
                right,
                optional,
                variadic
              };
            }
          });
        }
        let jsdocBaseGrammar = [
          ...baseGrammar,
          createFunctionParslet({
            allowWithoutParenthesis: !0,
            allowNamedParameters: ["this", "new"],
            allowNoReturnType: !0,
            allowNewAsFunctionKeyword: !1
          }),
          stringValueParslet,
          createSpecialNamePathParslet({
            allowedTypes: ["module", "external", "event"],
            pathGrammar
          }),
          createVariadicParslet({
            allowEnclosingBrackets: !0,
            allowPostfix: !0
          }),
          createNameParslet({
            allowedAdditionalTokens: ["keyof"]
          }),
          symbolParslet,
          arrayBracketsParslet,
          createNamePathParslet({
            allowSquareBracketsOnAnyType: !1,
            allowJsdocNamePaths: !0,
            pathGrammar
          })
        ], jsdocGrammar = [
          ...jsdocBaseGrammar,
          createObjectParslet({
            // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here
            // we leave out the object type deliberately
            objectFieldGrammar: [
              createNameParslet({
                allowedAdditionalTokens: ["typeof", "module", "in"]
              }),
              createObjectFieldParslet({
                allowSquaredProperties: !1,
                allowKeyTypes: !0,
                allowOptional: !1,
                allowReadonly: !1
              }),
              ...jsdocBaseGrammar
            ],
            allowKeyTypes: !0
          }),
          createKeyValueParslet({
            allowOptional: !0,
            allowVariadic: !0
          })
        ], typeOfParslet = composeParslet({
          name: "typeOfParslet",
          accept: (type) => type === "typeof",
          parsePrefix: (parser) => (parser.consume("typeof"), {
            type: "JsdocTypeTypeof",
            element: parser.parseType(Precedence.KEY_OF_TYPE_OF)
          })
        }), objectFieldGrammar$1 = [
          createNameParslet({
            allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
          }),
          nullableParslet,
          optionalParslet,
          stringValueParslet,
          numberParslet,
          createObjectFieldParslet({
            allowSquaredProperties: !1,
            allowKeyTypes: !1,
            allowOptional: !1,
            allowReadonly: !1
          })
        ], closureGrammar = [
          ...baseGrammar,
          createObjectParslet({
            allowKeyTypes: !1,
            objectFieldGrammar: objectFieldGrammar$1
          }),
          createNameParslet({
            allowedAdditionalTokens: ["event", "external", "in"]
          }),
          typeOfParslet,
          createFunctionParslet({
            allowWithoutParenthesis: !1,
            allowNamedParameters: ["this", "new"],
            allowNoReturnType: !0,
            allowNewAsFunctionKeyword: !1
          }),
          createVariadicParslet({
            allowEnclosingBrackets: !1,
            allowPostfix: !1
          }),
          // additional name parslet is needed for some special cases
          createNameParslet({
            allowedAdditionalTokens: ["keyof"]
          }),
          createSpecialNamePathParslet({
            allowedTypes: ["module"],
            pathGrammar
          }),
          createNamePathParslet({
            allowSquareBracketsOnAnyType: !1,
            allowJsdocNamePaths: !0,
            pathGrammar
          }),
          createKeyValueParslet({
            allowOptional: !1,
            allowVariadic: !1
          }),
          symbolParslet
        ], assertsParslet = composeParslet({
          name: "assertsParslet",
          accept: (type) => type === "asserts",
          parsePrefix: (parser) => {
            parser.consume("asserts");
            let left = parser.parseIntermediateType(Precedence.SYMBOL);
            if (left.type !== "JsdocTypeName")
              throw new UnexpectedTypeError(left, "A typescript asserts always has to have a name on the left side.");
            return parser.consume("is") ? {
              type: "JsdocTypeAsserts",
              left,
              right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))
            } : {
              type: "JsdocTypeAssertsPlain",
              element: left
            };
          }
        });
        function createTupleParslet({ allowQuestionMark }) {
          return composeParslet({
            name: "tupleParslet",
            accept: (type) => type === "[",
            parsePrefix: (parser) => {
              parser.consume("[");
              let result = {
                type: "JsdocTypeTuple",
                elements: []
              };
              if (parser.consume("]"))
                return result;
              let typeList = parser.parseIntermediateType(Precedence.ALL);
              if (typeList.type === "JsdocTypeParameterList" ? typeList.elements[0].type === "JsdocTypeKeyValue" ? result.elements = typeList.elements.map(assertPlainKeyValueResult) : result.elements = typeList.elements.map(assertRootResult) : typeList.type === "JsdocTypeKeyValue" ? result.elements = [assertPlainKeyValueResult(typeList)] : result.elements = [assertRootResult(typeList)], !parser.consume("]"))
                throw new Error("Unterminated '['");
              if (result.elements.some((e) => e.type === "JsdocTypeUnknown"))
                throw new Error("Question mark in tuple not allowed");
              return result;
            }
          });
        }
        let keyOfParslet = composeParslet({
          name: "keyOfParslet",
          accept: (type) => type === "keyof",
          parsePrefix: (parser) => (parser.consume("keyof"), {
            type: "JsdocTypeKeyof",
            element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))
          })
        }), importParslet = composeParslet({
          name: "importParslet",
          accept: (type) => type === "import",
          parsePrefix: (parser) => {
            if (parser.consume("import"), !parser.consume("("))
              throw new Error("Missing parenthesis after import keyword");
            let path = parser.parseType(Precedence.PREFIX);
            if (path.type !== "JsdocTypeStringValue")
              throw new Error("Only string values are allowed as paths for imports");
            if (!parser.consume(")"))
              throw new Error("Missing closing parenthesis after import keyword");
            return {
              type: "JsdocTypeImport",
              element: path
            };
          }
        }), readonlyPropertyParslet = composeParslet({
          name: "readonlyPropertyParslet",
          accept: (type) => type === "readonly",
          parsePrefix: (parser) => (parser.consume("readonly"), {
            type: "JsdocTypeReadonlyProperty",
            element: parser.parseIntermediateType(Precedence.KEY_VALUE)
          })
        }), arrowFunctionParslet = composeParslet({
          name: "arrowFunctionParslet",
          precedence: Precedence.ARROW,
          accept: (type) => type === "=>",
          parseInfix: (parser, left) => (parser.consume("=>"), {
            type: "JsdocTypeFunction",
            parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),
            arrow: !0,
            constructor: !1,
            parenthesis: !0,
            returnType: parser.parseType(Precedence.OBJECT)
          })
        }), genericArrowFunctionParslet = composeParslet({
          name: "genericArrowFunctionParslet",
          accept: (type) => type === "<",
          parsePrefix: (parser) => {
            let typeParameters = [];
            parser.consume("<");
            do {
              let defaultValue, name = parser.parseIntermediateType(Precedence.SYMBOL);
              if (name.type === "JsdocTypeOptional" && (name = name.element, defaultValue = parser.parseType(Precedence.SYMBOL)), name.type !== "JsdocTypeName")
                throw new UnexpectedTypeError(name);
              let constraint;
              parser.consume("extends") && (constraint = parser.parseType(Precedence.SYMBOL), constraint.type === "JsdocTypeOptional" && (constraint = constraint.element, defaultValue = parser.parseType(Precedence.SYMBOL)));
              let typeParameter = {
                type: "JsdocTypeTypeParameter",
                name
              };
              if (constraint !== void 0 && (typeParameter.constraint = constraint), defaultValue !== void 0 && (typeParameter.defaultValue = defaultValue), typeParameters.push(typeParameter), parser.consume(">"))
                break;
            } while (parser.consume(","));
            let functionBase = parser.parseIntermediateType(Precedence.SYMBOL);
            return functionBase.typeParameters = typeParameters, functionBase;
          }
        }), intersectionParslet = composeParslet({
          name: "intersectionParslet",
          accept: (type) => type === "&",
          precedence: Precedence.INTERSECTION,
          parseInfix: (parser, left) => {
            parser.consume("&");
            let elements = [];
            do
              elements.push(parser.parseType(Precedence.INTERSECTION));
            while (parser.consume("&"));
            return {
              type: "JsdocTypeIntersection",
              elements: [assertRootResult(left), ...elements]
            };
          }
        }), predicateParslet = composeParslet({
          name: "predicateParslet",
          precedence: Precedence.INFIX,
          accept: (type) => type === "is",
          parseInfix: (parser, left) => {
            if (left.type !== "JsdocTypeName")
              throw new UnexpectedTypeError(left, "A typescript predicate always has to have a name on the left side.");
            return parser.consume("is"), {
              type: "JsdocTypePredicate",
              left,
              right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))
            };
          }
        }), objectSquaredPropertyParslet = composeParslet({
          name: "objectSquareBracketPropertyParslet",
          accept: (type) => type === "[",
          parsePrefix: (parser) => {
            if (parser.baseParser === void 0)
              throw new Error("Only allowed inside object grammar");
            parser.consume("[");
            let key = parser.lexer.current.text;
            parser.consume("Identifier");
            let result;
            if (parser.consume(":")) {
              let parentParser = parser.baseParser;
              parentParser.acceptLexerState(parser), result = {
                type: "JsdocTypeIndexSignature",
                key,
                right: parentParser.parseType(Precedence.INDEX_BRACKETS)
              }, parser.acceptLexerState(parentParser);
            } else if (parser.consume("in")) {
              let parentParser = parser.baseParser;
              parentParser.acceptLexerState(parser), result = {
                type: "JsdocTypeMappedType",
                key,
                right: parentParser.parseType(Precedence.ARRAY_BRACKETS)
              }, parser.acceptLexerState(parentParser);
            } else
              throw new Error("Missing ':' or 'in' inside square bracketed property.");
            if (!parser.consume("]"))
              throw new Error("Unterminated square brackets");
            return result;
          }
        }), readonlyArrayParslet = composeParslet({
          name: "readonlyArrayParslet",
          accept: (type) => type === "readonly",
          parsePrefix: (parser) => (parser.consume("readonly"), {
            type: "JsdocTypeReadonlyArray",
            element: assertArrayOrTupleResult(parser.parseIntermediateType(Precedence.ALL))
          })
        }), conditionalParslet = composeParslet({
          name: "conditionalParslet",
          precedence: Precedence.INFIX,
          accept: (type) => type === "extends",
          parseInfix: (parser, left) => {
            parser.consume("extends");
            let extendsType = parser.parseType(Precedence.KEY_OF_TYPE_OF).element, trueType = parser.parseType(Precedence.INFIX);
            return parser.consume(":"), {
              type: "JsdocTypeConditional",
              checksType: assertRootResult(left),
              extendsType,
              trueType,
              falseType: parser.parseType(Precedence.INFIX)
            };
          }
        }), objectFieldGrammar = [
          readonlyPropertyParslet,
          createNameParslet({
            allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
          }),
          nullableParslet,
          optionalParslet,
          stringValueParslet,
          numberParslet,
          createObjectFieldParslet({
            allowSquaredProperties: !0,
            allowKeyTypes: !1,
            allowOptional: !0,
            allowReadonly: !0
          }),
          objectSquaredPropertyParslet
        ], typescriptGrammar = [
          ...baseGrammar,
          createObjectParslet({
            allowKeyTypes: !1,
            objectFieldGrammar
          }),
          readonlyArrayParslet,
          typeOfParslet,
          keyOfParslet,
          importParslet,
          stringValueParslet,
          createFunctionParslet({
            allowWithoutParenthesis: !0,
            allowNoReturnType: !1,
            allowNamedParameters: ["this", "new", "args"],
            allowNewAsFunctionKeyword: !0
          }),
          createTupleParslet({
            allowQuestionMark: !1
          }),
          createVariadicParslet({
            allowEnclosingBrackets: !1,
            allowPostfix: !1
          }),
          assertsParslet,
          conditionalParslet,
          createNameParslet({
            allowedAdditionalTokens: ["event", "external", "in"]
          }),
          createSpecialNamePathParslet({
            allowedTypes: ["module"],
            pathGrammar
          }),
          arrayBracketsParslet,
          arrowFunctionParslet,
          genericArrowFunctionParslet,
          createNamePathParslet({
            allowSquareBracketsOnAnyType: !0,
            allowJsdocNamePaths: !1,
            pathGrammar
          }),
          intersectionParslet,
          predicateParslet,
          createKeyValueParslet({
            allowVariadic: !0,
            allowOptional: !0
          })
        ];
        function parse32(expression, mode) {
          switch (mode) {
            case "closure":
              return new Parser(closureGrammar, expression).parse();
            case "jsdoc":
              return new Parser(jsdocGrammar, expression).parse();
            case "typescript":
              return new Parser(typescriptGrammar, expression).parse();
          }
        }
        function tryParse(expression, modes = ["typescript", "closure", "jsdoc"]) {
          let error;
          for (let mode of modes)
            try {
              return parse32(expression, mode);
            } catch (e) {
              error = e;
            }
          throw error;
        }
        function transform(rules2, parseResult) {
          let rule = rules2[parseResult.type];
          if (rule === void 0)
            throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);
          return rule(parseResult, (aParseResult) => transform(rules2, aParseResult));
        }
        function notAvailableTransform(parseResult) {
          throw new Error("This transform is not available. Are you trying the correct parsing mode?");
        }
        function extractSpecialParams(source) {
          let result = {
            params: []
          };
          for (let param of source.parameters)
            param.type === "JsdocTypeKeyValue" ? param.key === "this" ? result.this = param.right : param.key === "new" ? result.new = param.right : result.params.push(param) : result.params.push(param);
          return result;
        }
        function applyPosition(position, target, value2) {
          return position === "prefix" ? value2 + target : target + value2;
        }
        function quote(value2, quote2) {
          switch (quote2) {
            case "double":
              return `"${value2}"`;
            case "single":
              return `'${value2}'`;
            case void 0:
              return value2;
          }
        }
        function stringifyRules2() {
          return {
            JsdocTypeParenthesis: (result, transform2) => `(${result.element !== void 0 ? transform2(result.element) : ""})`,
            JsdocTypeKeyof: (result, transform2) => `keyof ${transform2(result.element)}`,
            JsdocTypeFunction: (result, transform2) => {
              var _a;
              if (result.arrow) {
                if (result.returnType === void 0)
                  throw new Error("Arrow function needs a return type.");
                let stringified = `${result.typeParameters !== void 0 ? `<${(_a = result.typeParameters.map(transform2).join(", ")) !== null && _a !== void 0 ? _a : ""}>` : ""}(${result.parameters.map(transform2).join(", ")}) => ${transform2(result.returnType)}`;
                return result.constructor && (stringified = "new " + stringified), stringified;
              } else {
                let stringified = result.constructor ? "new" : "function";
                return result.parenthesis && (stringified += `(${result.parameters.map(transform2).join(", ")})`, result.returnType !== void 0 && (stringified += `: ${transform2(result.returnType)}`)), stringified;
              }
            },
            JsdocTypeName: (result) => result.value,
            JsdocTypeTuple: (result, transform2) => `[${result.elements.map(transform2).join(", ")}]`,
            JsdocTypeVariadic: (result, transform2) => result.meta.position === void 0 ? "..." : applyPosition(result.meta.position, transform2(result.element), "..."),
            JsdocTypeNamePath: (result, transform2) => {
              let left = transform2(result.left), right = transform2(result.right);
              switch (result.pathType) {
                case "inner":
                  return `${left}~${right}`;
                case "instance":
                  return `${left}#${right}`;
                case "property":
                  return `${left}.${right}`;
                case "property-brackets":
                  return `${left}[${right}]`;
              }
            },
            JsdocTypeStringValue: (result) => quote(result.value, result.meta.quote),
            JsdocTypeAny: () => "*",
            JsdocTypeGeneric: (result, transform2) => {
              if (result.meta.brackets === "square") {
                let element = result.elements[0], transformed = transform2(element);
                return element.type === "JsdocTypeUnion" || element.type === "JsdocTypeIntersection" ? `(${transformed})[]` : `${transformed}[]`;
              } else
                return `${transform2(result.left)}${result.meta.dot ? "." : ""}<${result.infer === !0 ? "infer " : ""}${result.elements.map(transform2).join(", ")}>`;
            },
            JsdocTypeImport: (result, transform2) => `import(${transform2(result.element)})`,
            JsdocTypeObjectField: (result, transform2) => {
              let text = "";
              return result.readonly && (text += "readonly "), typeof result.key == "string" ? text += quote(result.key, result.meta.quote) : text += transform2(result.key), result.optional && (text += "?"), result.right === void 0 ? text : text + `: ${transform2(result.right)}`;
            },
            JsdocTypeJsdocObjectField: (result, transform2) => `${transform2(result.left)}: ${transform2(result.right)}`,
            JsdocTypeKeyValue: (result, transform2) => {
              let text = result.key;
              return result.optional && (text += "?"), result.variadic && (text = "..." + text), result.right === void 0 ? text : text + `: ${transform2(result.right)}`;
            },
            JsdocTypeSpecialNamePath: (result) => `${result.specialType}:${quote(result.value, result.meta.quote)}`,
            JsdocTypeNotNullable: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), "!"),
            JsdocTypeNull: () => "null",
            JsdocTypeNullable: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), "?"),
            JsdocTypeNumber: (result) => result.value.toString(),
            JsdocTypeObject: (result, transform2) => {
              var _a, _b;
              return `{${(result.meta.separator === "linebreak" && result.elements.length > 1 ? `
` + ((_a = result.meta.propertyIndent) !== null && _a !== void 0 ? _a : "") : "") + result.elements.map(transform2).join(result.meta.separator === "comma" ? ", " : result.meta.separator === "linebreak" ? `
` + ((_b = result.meta.propertyIndent) !== null && _b !== void 0 ? _b : "") : "; ") + (result.meta.separator === "linebreak" && result.elements.length > 1 ? `
` : "")}}`;
            },
            JsdocTypeOptional: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), "="),
            JsdocTypeSymbol: (result, transform2) => `${result.value}(${result.element !== void 0 ? transform2(result.element) : ""})`,
            JsdocTypeTypeof: (result, transform2) => `typeof ${transform2(result.element)}`,
            JsdocTypeUndefined: () => "undefined",
            JsdocTypeUnion: (result, transform2) => result.elements.map(transform2).join(" | "),
            JsdocTypeUnknown: () => "?",
            JsdocTypeIntersection: (result, transform2) => result.elements.map(transform2).join(" & "),
            JsdocTypeProperty: (result) => quote(result.value, result.meta.quote),
            JsdocTypePredicate: (result, transform2) => `${transform2(result.left)} is ${transform2(result.right)}`,
            JsdocTypeIndexSignature: (result, transform2) => `[${result.key}: ${transform2(result.right)}]`,
            JsdocTypeMappedType: (result, transform2) => `[${result.key} in ${transform2(result.right)}]`,
            JsdocTypeAsserts: (result, transform2) => `asserts ${transform2(result.left)} is ${transform2(result.right)}`,
            JsdocTypeReadonlyArray: (result, transform2) => `readonly ${transform2(result.element)}`,
            JsdocTypeAssertsPlain: (result, transform2) => `asserts ${transform2(result.element)}`,
            JsdocTypeConditional: (result, transform2) => `${transform2(result.checksType)} extends ${transform2(result.extendsType)} ? ${transform2(result.trueType)} : ${transform2(result.falseType)}`,
            JsdocTypeTypeParameter: (result, transform2) => `${transform2(result.name)}${result.constraint !== void 0 ? ` extends ${transform2(result.constraint)}` : ""}${result.defaultValue !== void 0 ? ` = ${transform2(result.defaultValue)}` : ""}`
          };
        }
        let storedStringifyRules = stringifyRules2();
        function stringify22(result) {
          return transform(storedStringifyRules, result);
        }
        let reservedWords = [
          "null",
          "true",
          "false",
          "break",
          "case",
          "catch",
          "class",
          "const",
          "continue",
          "debugger",
          "default",
          "delete",
          "do",
          "else",
          "export",
          "extends",
          "finally",
          "for",
          "function",
          "if",
          "import",
          "in",
          "instanceof",
          "new",
          "return",
          "super",
          "switch",
          "this",
          "throw",
          "try",
          "typeof",
          "var",
          "void",
          "while",
          "with",
          "yield"
        ];
        function makeName(value2) {
          let result = {
            type: "NameExpression",
            name: value2
          };
          return reservedWords.includes(value2) && (result.reservedWord = !0), result;
        }
        let catharsisTransformRules = {
          JsdocTypeOptional: (result, transform2) => {
            let transformed = transform2(result.element);
            return transformed.optional = !0, transformed;
          },
          JsdocTypeNullable: (result, transform2) => {
            let transformed = transform2(result.element);
            return transformed.nullable = !0, transformed;
          },
          JsdocTypeNotNullable: (result, transform2) => {
            let transformed = transform2(result.element);
            return transformed.nullable = !1, transformed;
          },
          JsdocTypeVariadic: (result, transform2) => {
            if (result.element === void 0)
              throw new Error("dots without value are not allowed in catharsis mode");
            let transformed = transform2(result.element);
            return transformed.repeatable = !0, transformed;
          },
          JsdocTypeAny: () => ({
            type: "AllLiteral"
          }),
          JsdocTypeNull: () => ({
            type: "NullLiteral"
          }),
          JsdocTypeStringValue: (result) => makeName(quote(result.value, result.meta.quote)),
          JsdocTypeUndefined: () => ({
            type: "UndefinedLiteral"
          }),
          JsdocTypeUnknown: () => ({
            type: "UnknownLiteral"
          }),
          JsdocTypeFunction: (result, transform2) => {
            let params = extractSpecialParams(result), transformed = {
              type: "FunctionType",
              params: params.params.map(transform2)
            };
            return params.this !== void 0 && (transformed.this = transform2(params.this)), params.new !== void 0 && (transformed.new = transform2(params.new)), result.returnType !== void 0 && (transformed.result = transform2(result.returnType)), transformed;
          },
          JsdocTypeGeneric: (result, transform2) => ({
            type: "TypeApplication",
            applications: result.elements.map((o2) => transform2(o2)),
            expression: transform2(result.left)
          }),
          JsdocTypeSpecialNamePath: (result) => makeName(result.specialType + ":" + quote(result.value, result.meta.quote)),
          JsdocTypeName: (result) => result.value !== "function" ? makeName(result.value) : {
            type: "FunctionType",
            params: []
          },
          JsdocTypeNumber: (result) => makeName(result.value.toString()),
          JsdocTypeObject: (result, transform2) => {
            let transformed = {
              type: "RecordType",
              fields: []
            };
            for (let field of result.elements)
              field.type !== "JsdocTypeObjectField" && field.type !== "JsdocTypeJsdocObjectField" ? transformed.fields.push({
                type: "FieldType",
                key: transform2(field),
                value: void 0
              }) : transformed.fields.push(transform2(field));
            return transformed;
          },
          JsdocTypeObjectField: (result, transform2) => {
            if (typeof result.key != "string")
              throw new Error("Index signatures and mapped types are not supported");
            return {
              type: "FieldType",
              key: makeName(quote(result.key, result.meta.quote)),
              value: result.right === void 0 ? void 0 : transform2(result.right)
            };
          },
          JsdocTypeJsdocObjectField: (result, transform2) => ({
            type: "FieldType",
            key: transform2(result.left),
            value: transform2(result.right)
          }),
          JsdocTypeUnion: (result, transform2) => ({
            type: "TypeUnion",
            elements: result.elements.map((e) => transform2(e))
          }),
          JsdocTypeKeyValue: (result, transform2) => ({
            type: "FieldType",
            key: makeName(result.key),
            value: result.right === void 0 ? void 0 : transform2(result.right)
          }),
          JsdocTypeNamePath: (result, transform2) => {
            let leftResult = transform2(result.left), rightValue;
            result.right.type === "JsdocTypeSpecialNamePath" ? rightValue = transform2(result.right).name : rightValue = quote(result.right.value, result.right.meta.quote);
            let joiner = result.pathType === "inner" ? "~" : result.pathType === "instance" ? "#" : ".";
            return makeName(`${leftResult.name}${joiner}${rightValue}`);
          },
          JsdocTypeSymbol: (result) => {
            let value2 = "", element = result.element, trailingDots = !1;
            return element?.type === "JsdocTypeVariadic" && (element.meta.position === "prefix" ? value2 = "..." : trailingDots = !0, element = element.element), element?.type === "JsdocTypeName" ? value2 += element.value : element?.type === "JsdocTypeNumber" && (value2 += element.value.toString()), trailingDots && (value2 += "..."), makeName(`${result.value}(${value2})`);
          },
          JsdocTypeParenthesis: (result, transform2) => transform2(assertRootResult(result.element)),
          JsdocTypeMappedType: notAvailableTransform,
          JsdocTypeIndexSignature: notAvailableTransform,
          JsdocTypeImport: notAvailableTransform,
          JsdocTypeKeyof: notAvailableTransform,
          JsdocTypeTuple: notAvailableTransform,
          JsdocTypeTypeof: notAvailableTransform,
          JsdocTypeIntersection: notAvailableTransform,
          JsdocTypeProperty: notAvailableTransform,
          JsdocTypePredicate: notAvailableTransform,
          JsdocTypeAsserts: notAvailableTransform,
          JsdocTypeReadonlyArray: notAvailableTransform,
          JsdocTypeAssertsPlain: notAvailableTransform,
          JsdocTypeConditional: notAvailableTransform,
          JsdocTypeTypeParameter: notAvailableTransform
        };
        function catharsisTransform(result) {
          return transform(catharsisTransformRules, result);
        }
        function getQuoteStyle(quote2) {
          switch (quote2) {
            case void 0:
              return "none";
            case "single":
              return "single";
            case "double":
              return "double";
          }
        }
        function getMemberType(type) {
          switch (type) {
            case "inner":
              return "INNER_MEMBER";
            case "instance":
              return "INSTANCE_MEMBER";
            case "property":
              return "MEMBER";
            case "property-brackets":
              return "MEMBER";
          }
        }
        function nestResults(type, results) {
          return results.length === 2 ? {
            type,
            left: results[0],
            right: results[1]
          } : {
            type,
            left: results[0],
            right: nestResults(type, results.slice(1))
          };
        }
        let jtpRules = {
          JsdocTypeOptional: (result, transform2) => ({
            type: "OPTIONAL",
            value: transform2(result.element),
            meta: {
              syntax: result.meta.position === "prefix" ? "PREFIX_EQUAL_SIGN" : "SUFFIX_EQUALS_SIGN"
            }
          }),
          JsdocTypeNullable: (result, transform2) => ({
            type: "NULLABLE",
            value: transform2(result.element),
            meta: {
              syntax: result.meta.position === "prefix" ? "PREFIX_QUESTION_MARK" : "SUFFIX_QUESTION_MARK"
            }
          }),
          JsdocTypeNotNullable: (result, transform2) => ({
            type: "NOT_NULLABLE",
            value: transform2(result.element),
            meta: {
              syntax: result.meta.position === "prefix" ? "PREFIX_BANG" : "SUFFIX_BANG"
            }
          }),
          JsdocTypeVariadic: (result, transform2) => {
            let transformed = {
              type: "VARIADIC",
              meta: {
                syntax: result.meta.position === "prefix" ? "PREFIX_DOTS" : result.meta.position === "suffix" ? "SUFFIX_DOTS" : "ONLY_DOTS"
              }
            };
            return result.element !== void 0 && (transformed.value = transform2(result.element)), transformed;
          },
          JsdocTypeName: (result) => ({
            type: "NAME",
            name: result.value
          }),
          JsdocTypeTypeof: (result, transform2) => ({
            type: "TYPE_QUERY",
            name: transform2(result.element)
          }),
          JsdocTypeTuple: (result, transform2) => ({
            type: "TUPLE",
            entries: result.elements.map(transform2)
          }),
          JsdocTypeKeyof: (result, transform2) => ({
            type: "KEY_QUERY",
            value: transform2(result.element)
          }),
          JsdocTypeImport: (result) => ({
            type: "IMPORT",
            path: {
              type: "STRING_VALUE",
              quoteStyle: getQuoteStyle(result.element.meta.quote),
              string: result.element.value
            }
          }),
          JsdocTypeUndefined: () => ({
            type: "NAME",
            name: "undefined"
          }),
          JsdocTypeAny: () => ({
            type: "ANY"
          }),
          JsdocTypeFunction: (result, transform2) => {
            let specialParams = extractSpecialParams(result), transformed = {
              type: result.arrow ? "ARROW" : "FUNCTION",
              params: specialParams.params.map((param) => {
                if (param.type === "JsdocTypeKeyValue") {
                  if (param.right === void 0)
                    throw new Error("Function parameter without ':' is not expected to be 'KEY_VALUE'");
                  return {
                    type: "NAMED_PARAMETER",
                    name: param.key,
                    typeName: transform2(param.right)
                  };
                } else
                  return transform2(param);
              }),
              new: null,
              returns: null
            };
            return specialParams.this !== void 0 ? transformed.this = transform2(specialParams.this) : result.arrow || (transformed.this = null), specialParams.new !== void 0 && (transformed.new = transform2(specialParams.new)), result.returnType !== void 0 && (transformed.returns = transform2(result.returnType)), transformed;
          },
          JsdocTypeGeneric: (result, transform2) => {
            let transformed = {
              type: "GENERIC",
              subject: transform2(result.left),
              objects: result.elements.map(transform2),
              meta: {
                syntax: result.meta.brackets === "square" ? "SQUARE_BRACKET" : result.meta.dot ? "ANGLE_BRACKET_WITH_DOT" : "ANGLE_BRACKET"
              }
            };
            return result.meta.brackets === "square" && result.elements[0].type === "JsdocTypeFunction" && !result.elements[0].parenthesis && (transformed.objects[0] = {
              type: "NAME",
              name: "function"
            }), transformed;
          },
          JsdocTypeObjectField: (result, transform2) => {
            if (typeof result.key != "string")
              throw new Error("Index signatures and mapped types are not supported");
            if (result.right === void 0)
              return {
                type: "RECORD_ENTRY",
                key: result.key,
                quoteStyle: getQuoteStyle(result.meta.quote),
                value: null,
                readonly: !1
              };
            let right = transform2(result.right);
            return result.optional && (right = {
              type: "OPTIONAL",
              value: right,
              meta: {
                syntax: "SUFFIX_KEY_QUESTION_MARK"
              }
            }), {
              type: "RECORD_ENTRY",
              key: result.key.toString(),
              quoteStyle: getQuoteStyle(result.meta.quote),
              value: right,
              readonly: !1
            };
          },
          JsdocTypeJsdocObjectField: () => {
            throw new Error("Keys may not be typed in jsdoctypeparser.");
          },
          JsdocTypeKeyValue: (result, transform2) => {
            if (result.right === void 0)
              return {
                type: "RECORD_ENTRY",
                key: result.key,
                quoteStyle: "none",
                value: null,
                readonly: !1
              };
            let right = transform2(result.right);
            return result.optional && (right = {
              type: "OPTIONAL",
              value: right,
              meta: {
                syntax: "SUFFIX_KEY_QUESTION_MARK"
              }
            }), {
              type: "RECORD_ENTRY",
              key: result.key,
              quoteStyle: "none",
              value: right,
              readonly: !1
            };
          },
          JsdocTypeObject: (result, transform2) => {
            let entries = [];
            for (let field of result.elements)
              (field.type === "JsdocTypeObjectField" || field.type === "JsdocTypeJsdocObjectField") && entries.push(transform2(field));
            return {
              type: "RECORD",
              entries
            };
          },
          JsdocTypeSpecialNamePath: (result) => {
            if (result.specialType !== "module")
              throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);
            return {
              type: "MODULE",
              value: {
                type: "FILE_PATH",
                quoteStyle: getQuoteStyle(result.meta.quote),
                path: result.value
              }
            };
          },
          JsdocTypeNamePath: (result, transform2) => {
            let hasEventPrefix = !1, name, quoteStyle;
            result.right.type === "JsdocTypeSpecialNamePath" && result.right.specialType === "event" ? (hasEventPrefix = !0, name = result.right.value, quoteStyle = getQuoteStyle(result.right.meta.quote)) : (name = result.right.value, quoteStyle = getQuoteStyle(result.right.meta.quote));
            let transformed = {
              type: getMemberType(result.pathType),
              owner: transform2(result.left),
              name,
              quoteStyle,
              hasEventPrefix
            };
            if (transformed.owner.type === "MODULE") {
              let tModule = transformed.owner;
              return transformed.owner = transformed.owner.value, tModule.value = transformed, tModule;
            } else
              return transformed;
          },
          JsdocTypeUnion: (result, transform2) => nestResults("UNION", result.elements.map(transform2)),
          JsdocTypeParenthesis: (result, transform2) => ({
            type: "PARENTHESIS",
            value: transform2(assertRootResult(result.element))
          }),
          JsdocTypeNull: () => ({
            type: "NAME",
            name: "null"
          }),
          JsdocTypeUnknown: () => ({
            type: "UNKNOWN"
          }),
          JsdocTypeStringValue: (result) => ({
            type: "STRING_VALUE",
            quoteStyle: getQuoteStyle(result.meta.quote),
            string: result.value
          }),
          JsdocTypeIntersection: (result, transform2) => nestResults("INTERSECTION", result.elements.map(transform2)),
          JsdocTypeNumber: (result) => ({
            type: "NUMBER_VALUE",
            number: result.value.toString()
          }),
          JsdocTypeSymbol: notAvailableTransform,
          JsdocTypeProperty: notAvailableTransform,
          JsdocTypePredicate: notAvailableTransform,
          JsdocTypeMappedType: notAvailableTransform,
          JsdocTypeIndexSignature: notAvailableTransform,
          JsdocTypeAsserts: notAvailableTransform,
          JsdocTypeReadonlyArray: notAvailableTransform,
          JsdocTypeAssertsPlain: notAvailableTransform,
          JsdocTypeConditional: notAvailableTransform,
          JsdocTypeTypeParameter: notAvailableTransform
        };
        function jtpTransform(result) {
          return transform(jtpRules, result);
        }
        function identityTransformRules() {
          return {
            JsdocTypeIntersection: (result, transform2) => ({
              type: "JsdocTypeIntersection",
              elements: result.elements.map(transform2)
            }),
            JsdocTypeGeneric: (result, transform2) => ({
              type: "JsdocTypeGeneric",
              left: transform2(result.left),
              elements: result.elements.map(transform2),
              meta: {
                dot: result.meta.dot,
                brackets: result.meta.brackets
              }
            }),
            JsdocTypeNullable: (result) => result,
            JsdocTypeUnion: (result, transform2) => ({
              type: "JsdocTypeUnion",
              elements: result.elements.map(transform2)
            }),
            JsdocTypeUnknown: (result) => result,
            JsdocTypeUndefined: (result) => result,
            JsdocTypeTypeof: (result, transform2) => ({
              type: "JsdocTypeTypeof",
              element: transform2(result.element)
            }),
            JsdocTypeSymbol: (result, transform2) => {
              let transformed = {
                type: "JsdocTypeSymbol",
                value: result.value
              };
              return result.element !== void 0 && (transformed.element = transform2(result.element)), transformed;
            },
            JsdocTypeOptional: (result, transform2) => ({
              type: "JsdocTypeOptional",
              element: transform2(result.element),
              meta: {
                position: result.meta.position
              }
            }),
            JsdocTypeObject: (result, transform2) => ({
              type: "JsdocTypeObject",
              meta: {
                separator: "comma"
              },
              elements: result.elements.map(transform2)
            }),
            JsdocTypeNumber: (result) => result,
            JsdocTypeNull: (result) => result,
            JsdocTypeNotNullable: (result, transform2) => ({
              type: "JsdocTypeNotNullable",
              element: transform2(result.element),
              meta: {
                position: result.meta.position
              }
            }),
            JsdocTypeSpecialNamePath: (result) => result,
            JsdocTypeObjectField: (result, transform2) => ({
              type: "JsdocTypeObjectField",
              key: result.key,
              right: result.right === void 0 ? void 0 : transform2(result.right),
              optional: result.optional,
              readonly: result.readonly,
              meta: result.meta
            }),
            JsdocTypeJsdocObjectField: (result, transform2) => ({
              type: "JsdocTypeJsdocObjectField",
              left: transform2(result.left),
              right: transform2(result.right)
            }),
            JsdocTypeKeyValue: (result, transform2) => ({
              type: "JsdocTypeKeyValue",
              key: result.key,
              right: result.right === void 0 ? void 0 : transform2(result.right),
              optional: result.optional,
              variadic: result.variadic
            }),
            JsdocTypeImport: (result, transform2) => ({
              type: "JsdocTypeImport",
              element: transform2(result.element)
            }),
            JsdocTypeAny: (result) => result,
            JsdocTypeStringValue: (result) => result,
            JsdocTypeNamePath: (result) => result,
            JsdocTypeVariadic: (result, transform2) => {
              let transformed = {
                type: "JsdocTypeVariadic",
                meta: {
                  position: result.meta.position,
                  squareBrackets: result.meta.squareBrackets
                }
              };
              return result.element !== void 0 && (transformed.element = transform2(result.element)), transformed;
            },
            JsdocTypeTuple: (result, transform2) => ({
              type: "JsdocTypeTuple",
              elements: result.elements.map(transform2)
            }),
            JsdocTypeName: (result) => result,
            JsdocTypeFunction: (result, transform2) => {
              let transformed = {
                type: "JsdocTypeFunction",
                arrow: result.arrow,
                parameters: result.parameters.map(transform2),
                constructor: result.constructor,
                parenthesis: result.parenthesis
              };
              return result.returnType !== void 0 && (transformed.returnType = transform2(result.returnType)), transformed;
            },
            JsdocTypeKeyof: (result, transform2) => ({
              type: "JsdocTypeKeyof",
              element: transform2(result.element)
            }),
            JsdocTypeParenthesis: (result, transform2) => ({
              type: "JsdocTypeParenthesis",
              element: transform2(result.element)
            }),
            JsdocTypeProperty: (result) => result,
            JsdocTypePredicate: (result, transform2) => ({
              type: "JsdocTypePredicate",
              left: transform2(result.left),
              right: transform2(result.right)
            }),
            JsdocTypeIndexSignature: (result, transform2) => ({
              type: "JsdocTypeIndexSignature",
              key: result.key,
              right: transform2(result.right)
            }),
            JsdocTypeMappedType: (result, transform2) => ({
              type: "JsdocTypeMappedType",
              key: result.key,
              right: transform2(result.right)
            }),
            JsdocTypeAsserts: (result, transform2) => ({
              type: "JsdocTypeAsserts",
              left: transform2(result.left),
              right: transform2(result.right)
            }),
            JsdocTypeReadonlyArray: (result, transform2) => ({
              type: "JsdocTypeReadonlyArray",
              element: transform2(result.element)
            }),
            JsdocTypeAssertsPlain: (result, transform2) => ({
              type: "JsdocTypeAssertsPlain",
              element: transform2(result.element)
            }),
            JsdocTypeConditional: (result, transform2) => ({
              type: "JsdocTypeConditional",
              checksType: transform2(result.checksType),
              extendsType: transform2(result.extendsType),
              trueType: transform2(result.trueType),
              falseType: transform2(result.falseType)
            }),
            JsdocTypeTypeParameter: (result, transform2) => ({
              type: "JsdocTypeTypeParameter",
              name: transform2(result.name),
              constraint: result.constraint !== void 0 ? transform2(result.constraint) : void 0,
              defaultValue: result.defaultValue !== void 0 ? transform2(result.defaultValue) : void 0
            })
          };
        }
        let visitorKeys = {
          JsdocTypeAny: [],
          JsdocTypeFunction: ["parameters", "returnType"],
          JsdocTypeGeneric: ["left", "elements"],
          JsdocTypeImport: [],
          JsdocTypeIndexSignature: ["right"],
          JsdocTypeIntersection: ["elements"],
          JsdocTypeKeyof: ["element"],
          JsdocTypeKeyValue: ["right"],
          JsdocTypeMappedType: ["right"],
          JsdocTypeName: [],
          JsdocTypeNamePath: ["left", "right"],
          JsdocTypeNotNullable: ["element"],
          JsdocTypeNull: [],
          JsdocTypeNullable: ["element"],
          JsdocTypeNumber: [],
          JsdocTypeObject: ["elements"],
          JsdocTypeObjectField: ["right"],
          JsdocTypeJsdocObjectField: ["left", "right"],
          JsdocTypeOptional: ["element"],
          JsdocTypeParenthesis: ["element"],
          JsdocTypeSpecialNamePath: [],
          JsdocTypeStringValue: [],
          JsdocTypeSymbol: ["element"],
          JsdocTypeTuple: ["elements"],
          JsdocTypeTypeof: ["element"],
          JsdocTypeUndefined: [],
          JsdocTypeUnion: ["elements"],
          JsdocTypeUnknown: [],
          JsdocTypeVariadic: ["element"],
          JsdocTypeProperty: [],
          JsdocTypePredicate: ["left", "right"],
          JsdocTypeAsserts: ["left", "right"],
          JsdocTypeReadonlyArray: ["element"],
          JsdocTypeAssertsPlain: ["element"],
          JsdocTypeConditional: ["checksType", "extendsType", "trueType", "falseType"],
          JsdocTypeTypeParameter: ["name", "constraint", "defaultValue"]
        };
        function _traverse(node, parentNode, property, onEnter, onLeave) {
          onEnter?.(node, parentNode, property);
          let keysToVisit = visitorKeys[node.type];
          for (let key of keysToVisit) {
            let value2 = node[key];
            if (value2 !== void 0)
              if (Array.isArray(value2))
                for (let element of value2)
                  _traverse(element, node, key, onEnter, onLeave);
              else
                _traverse(value2, node, key, onEnter, onLeave);
          }
          onLeave?.(node, parentNode, property);
        }
        function traverse(node, onEnter, onLeave) {
          _traverse(node, void 0, void 0, onEnter, onLeave);
        }
        exports2.catharsisTransform = catharsisTransform, exports2.identityTransformRules = identityTransformRules, exports2.jtpTransform = jtpTransform, exports2.parse = parse32, exports2.stringify = stringify22, exports2.stringifyRules = stringifyRules2, exports2.transform = transform, exports2.traverse = traverse, exports2.tryParse = tryParse, exports2.visitorKeys = visitorKeys;
      }));
    }
  });
  var TypeSystem = ((TypeSystem2) => (TypeSystem2.JAVASCRIPT = "JavaScript", TypeSystem2.FLOW = "Flow", TypeSystem2.TYPESCRIPT = "TypeScript", TypeSystem2.UNKNOWN = "Unknown", TypeSystem2))(TypeSystem || {});
  var Markers;
  (function(Markers2) {
    Markers2.start = "/**", Markers2.nostart = "/***", Markers2.delim = "*", Markers2.end = "*/";
  })(Markers = Markers || (Markers = {}));
  function join(tokens2) {
    return tokens2.start + tokens2.delimiter + tokens2.postDelimiter + tokens2.tag + tokens2.postTag + tokens2.type + tokens2.postType + tokens2.name + tokens2.postName + tokens2.description + tokens2.end + tokens2.lineEnd;
  }
  function getStringifier() {
    return (block) => block.source.map(({ tokens: tokens2 }) => join(tokens2)).join(`
`);
  }
  var zeroWidth = {
    line: 0,
    start: 0,
    delimiter: 0,
    postDelimiter: 0,
    tag: 0,
    postTag: 0,
    name: 0,
    postName: 0,
    type: 0,
    postType: 0,
    description: 0,
    end: 0,
    lineEnd: 0
  }, fields = Object.keys(zeroWidth);
  var stringify = getStringifier(), import_jsdoc_type_pratt_parser = __toESM(require_dist(), 1);
  var jsdocStringifyRules = (0, import_jsdoc_type_pratt_parser.stringifyRules)(), originalJsdocStringifyObject = jsdocStringifyRules.JsdocTypeObject;
  jsdocStringifyRules.JsdocTypeAny = () => "any";
  jsdocStringifyRules.JsdocTypeObject = (result, transform) => `(${originalJsdocStringifyObject(result, transform)})`;
  jsdocStringifyRules.JsdocTypeOptional = (result, transform) => transform(result.element);
  jsdocStringifyRules.JsdocTypeNullable = (result, transform) => transform(result.element);
  jsdocStringifyRules.JsdocTypeNotNullable = (result, transform) => transform(result.element);
  jsdocStringifyRules.JsdocTypeUnion = (result, transform) => result.elements.map(transform).join("|");
  var combineParameters2 = (...parameterSets) => {
    let mergeKeys = {}, definedParametersSets = parameterSets.filter(Boolean), combined = definedParametersSets.reduce((acc, parameters2) => (Object.entries(parameters2).forEach(([key, value2]) => {
      let existing = acc[key];
      Array.isArray(value2) || typeof existing > "u" ? acc[key] = value2 : isPlainObject(value2) && isPlainObject(existing) ? mergeKeys[key] = !0 : typeof value2 < "u" && (acc[key] = value2);
    }), acc), {});
    return Object.keys(mergeKeys).forEach((key) => {
      let mergeValues = definedParametersSets.filter(Boolean).map((p4) => p4[key]).filter((value2) => typeof value2 < "u");
      mergeValues.every((value2) => isPlainObject(value2)) ? combined[key] = combineParameters2(...mergeValues) : combined[key] = mergeValues[mergeValues.length - 1];
    }), combined;
  };
  var ADDON_ID6 = "storybook/docs", PANEL_ID3 = `${ADDON_ID6}/panel`;
  var SNIPPET_RENDERED = `${ADDON_ID6}/snippet-rendered`, SourceType = ((SourceType2) => (SourceType2.AUTO = "auto", SourceType2.CODE = "code", SourceType2.DYNAMIC = "dynamic", SourceType2))(SourceType || {});

  // node_modules/storybook/dist/_browser-chunks/chunk-IYCKG66Y.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_NZMVUW5T();

  // node_modules/storybook/dist/_browser-chunks/chunk-IWQGIXJS.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var isProduction = !1, prefix = "Invariant failed";
  function invariant(condition, message) {
    if (!condition) {
      if (isProduction)
        throw new Error(prefix);
      var provided = typeof message == "function" ? message() : message, value2 = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
      throw new Error(value2);
    }
  }

  // node_modules/storybook/dist/_browser-chunks/chunk-ZCFV7BZB.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_A242L54C();
  var require_memoizerific = __commonJS({
    "../../node_modules/memoizerific/memoizerific.js"(exports, module) {
      (function(f4) {
        if (typeof exports == "object" && typeof module < "u")
          module.exports = f4();
        else if (typeof define == "function" && define.amd)
          define([], f4);
        else {
          var g3;
          typeof window < "u" || typeof window < "u" ? g3 = window : typeof self < "u" ? g3 = self : g3 = this, g3.memoizerific = f4();
        }
      })(function() {
        var define2, module2, exports2;
        return (function e(t, n2, r2) {
          function s4(o22, u3) {
            if (!n2[o22]) {
              if (!t[o22]) {
                var a3 = typeof __require2 == "function" && __require2;
                if (!u3 && a3) return a3(o22, !0);
                if (i3) return i3(o22, !0);
                var f4 = new Error("Cannot find module '" + o22 + "'");
                throw f4.code = "MODULE_NOT_FOUND", f4;
              }
              var l2 = n2[o22] = { exports: {} };
              t[o22][0].call(l2.exports, function(e2) {
                var n22 = t[o22][1][e2];
                return s4(n22 || e2);
              }, l2, l2.exports, e, t, n2, r2);
            }
            return n2[o22].exports;
          }
          for (var i3 = typeof __require2 == "function" && __require2, o2 = 0; o2 < r2.length; o2++) s4(r2[o2]);
          return s4;
        })({ 1: [function(_dereq_, module3, exports3) {
          module3.exports = function(forceSimilar) {
            if (typeof Map != "function" || forceSimilar) {
              var Similar = _dereq_("./similar");
              return new Similar();
            } else
              return /* @__PURE__ */ new Map();
          };
        }, { "./similar": 2 }], 2: [function(_dereq_, module3, exports3) {
          function Similar() {
            return this.list = [], this.lastItem = void 0, this.size = 0, this;
          }
          Similar.prototype.get = function(key) {
            var index2;
            if (this.lastItem && this.isEqual(this.lastItem.key, key))
              return this.lastItem.val;
            if (index2 = this.indexOf(key), index2 >= 0)
              return this.lastItem = this.list[index2], this.list[index2].val;
          }, Similar.prototype.set = function(key, val) {
            var index2;
            return this.lastItem && this.isEqual(this.lastItem.key, key) ? (this.lastItem.val = val, this) : (index2 = this.indexOf(key), index2 >= 0 ? (this.lastItem = this.list[index2], this.list[index2].val = val, this) : (this.lastItem = { key, val }, this.list.push(this.lastItem), this.size++, this));
          }, Similar.prototype.delete = function(key) {
            var index2;
            if (this.lastItem && this.isEqual(this.lastItem.key, key) && (this.lastItem = void 0), index2 = this.indexOf(key), index2 >= 0)
              return this.size--, this.list.splice(index2, 1)[0];
          }, Similar.prototype.has = function(key) {
            var index2;
            return this.lastItem && this.isEqual(this.lastItem.key, key) ? !0 : (index2 = this.indexOf(key), index2 >= 0 ? (this.lastItem = this.list[index2], !0) : !1);
          }, Similar.prototype.forEach = function(callback, thisArg) {
            var i3;
            for (i3 = 0; i3 < this.size; i3++)
              callback.call(thisArg || this, this.list[i3].val, this.list[i3].key, this);
          }, Similar.prototype.indexOf = function(key) {
            var i3;
            for (i3 = 0; i3 < this.size; i3++)
              if (this.isEqual(this.list[i3].key, key))
                return i3;
            return -1;
          }, Similar.prototype.isEqual = function(val1, val2) {
            return val1 === val2 || val1 !== val1 && val2 !== val2;
          }, module3.exports = Similar;
        }, {}], 3: [function(_dereq_, module3, exports3) {
          var MapOrSimilar = _dereq_("map-or-similar");
          module3.exports = function(limit) {
            var cache = new MapOrSimilar(!1), lru = [];
            return function(fn2) {
              var memoizerific = function() {
                var currentCache = cache, newMap, fnResult, argsLengthMinusOne = arguments.length - 1, lruPath = Array(argsLengthMinusOne + 1), isMemoized = !0, i3;
                if ((memoizerific.numArgs || memoizerific.numArgs === 0) && memoizerific.numArgs !== argsLengthMinusOne + 1)
                  throw new Error("Memoizerific functions should always be called with the same number of arguments");
                for (i3 = 0; i3 < argsLengthMinusOne; i3++) {
                  if (lruPath[i3] = {
                    cacheItem: currentCache,
                    arg: arguments[i3]
                  }, currentCache.has(arguments[i3])) {
                    currentCache = currentCache.get(arguments[i3]);
                    continue;
                  }
                  isMemoized = !1, newMap = new MapOrSimilar(!1), currentCache.set(arguments[i3], newMap), currentCache = newMap;
                }
                return isMemoized && (currentCache.has(arguments[argsLengthMinusOne]) ? fnResult = currentCache.get(arguments[argsLengthMinusOne]) : isMemoized = !1), isMemoized || (fnResult = fn2.apply(null, arguments), currentCache.set(arguments[argsLengthMinusOne], fnResult)), limit > 0 && (lruPath[argsLengthMinusOne] = {
                  cacheItem: currentCache,
                  arg: arguments[argsLengthMinusOne]
                }, isMemoized ? moveToMostRecentLru(lru, lruPath) : lru.push(lruPath), lru.length > limit && removeCachedResult(lru.shift())), memoizerific.wasMemoized = isMemoized, memoizerific.numArgs = argsLengthMinusOne + 1, fnResult;
              };
              return memoizerific.limit = limit, memoizerific.wasMemoized = !1, memoizerific.cache = cache, memoizerific.lru = lru, memoizerific;
            };
          };
          function moveToMostRecentLru(lru, lruPath) {
            var lruLen = lru.length, lruPathLen = lruPath.length, isMatch, i3, ii;
            for (i3 = 0; i3 < lruLen; i3++) {
              for (isMatch = !0, ii = 0; ii < lruPathLen; ii++)
                if (!isEqual2(lru[i3][ii].arg, lruPath[ii].arg)) {
                  isMatch = !1;
                  break;
                }
              if (isMatch)
                break;
            }
            lru.push(lru.splice(i3, 1)[0]);
          }
          function removeCachedResult(removedLru) {
            var removedLruLen = removedLru.length, currentLru = removedLru[removedLruLen - 1], tmp, i3;
            for (currentLru.cacheItem.delete(currentLru.arg), i3 = removedLruLen - 2; i3 >= 0 && (currentLru = removedLru[i3], tmp = currentLru.cacheItem.get(currentLru.arg), !tmp || !tmp.size); i3--)
              currentLru.cacheItem.delete(currentLru.arg);
          }
          function isEqual2(val1, val2) {
            return val1 === val2 || val1 !== val1 && val2 !== val2;
          }
        }, { "map-or-similar": 1 }] }, {}, [3])(3);
      });
    }
  });

  // node_modules/storybook/dist/_browser-chunks/chunk-2N4WE3KZ.js
  init_chunk_A242L54C();

  // global-externals:storybook/internal/channels
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var channels_default = __STORYBOOK_CHANNELS__, { Channel, HEARTBEAT_INTERVAL, HEARTBEAT_MAX_LATENCY, PostMessageTransport, WebsocketTransport, createBrowserChannel } = __STORYBOOK_CHANNELS__;

  // node_modules/storybook/dist/_browser-chunks/chunk-2N4WE3KZ.js
  function mockChannel2() {
    let transport = {
      setHandler: () => {
      },
      send: () => {
      }
    };
    return new Channel({ transport });
  }
  var AddonStore = class {
    constructor() {
      this.getChannel = () => {
        if (!this.channel) {
          let channel = mockChannel2();
          return this.setChannel(channel), channel;
        }
        return this.channel;
      }, this.ready = () => this.promise, this.hasChannel = () => !!this.channel, this.setChannel = (channel) => {
        this.channel = channel, this.resolve();
      }, this.promise = new Promise((res) => {
        this.resolve = () => res(this.getChannel());
      });
    }
  }, KEY = "__STORYBOOK_ADDONS_PREVIEW";
  function getAddonsStore() {
    return scope[KEY] || (scope[KEY] = new AddonStore()), scope[KEY];
  }
  var addons2 = getAddonsStore();
  var areDepsEqual = (deps, nextDeps) => deps.length === nextDeps.length && deps.every((dep, i3) => dep === nextDeps[i3]), invalidHooksError = () => new Error("Storybook preview hooks can only be called inside decorators and story functions.");
  function getHooksContextOrNull() {
    return scope.STORYBOOK_HOOKS_CONTEXT || null;
  }
  function getHooksContextOrThrow() {
    let hooks = getHooksContextOrNull();
    if (hooks == null)
      throw invalidHooksError();
    return hooks;
  }
  function useHook(name, callback, deps) {
    let hooks = getHooksContextOrThrow();
    if (hooks.currentPhase === "MOUNT") {
      deps != null && !Array.isArray(deps) && logger.warn(
        `${name} received a final argument that is not an array (instead, received ${deps}). When specified, the final argument must be an array.`
      );
      let hook = { name, deps };
      return hooks.currentHooks.push(hook), callback(hook), hook;
    }
    if (hooks.currentPhase === "UPDATE") {
      let hook = hooks.getNextHook();
      if (hook == null)
        throw new Error("Rendered more hooks than during the previous render.");
      return hook.name !== name && logger.warn(
        `Storybook has detected a change in the order of Hooks${hooks.currentDecoratorName ? ` called by ${hooks.currentDecoratorName}` : ""}. This will lead to bugs and errors if not fixed.`
      ), deps != null && hook.deps == null && logger.warn(
        `${name} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`
      ), deps != null && hook.deps != null && deps.length !== hook.deps.length && logger.warn(`The final argument passed to ${name} changed size between renders. The order and size of this array must remain constant.
Previous: ${hook.deps}
Incoming: ${deps}`), (deps == null || hook.deps == null || !areDepsEqual(deps, hook.deps)) && (callback(hook), hook.deps = deps), hook;
    }
    throw invalidHooksError();
  }
  function useMemoLike(name, nextCreate, deps) {
    let { memoizedState } = useHook(
      name,
      (hook) => {
        hook.memoizedState = nextCreate();
      },
      deps
    );
    return memoizedState;
  }
  function useMemo2(nextCreate, deps) {
    return useMemoLike("useMemo", nextCreate, deps);
  }
  function useEffect2(create2, deps) {
    let hooks = getHooksContextOrThrow(), effect = useMemoLike("useEffect", () => ({ create: create2 }), deps);
    hooks.currentEffects.includes(effect) || hooks.currentEffects.push(effect);
  }
  var import_memoizerific2 = __toESM(require_memoizerific(), 1);
  var import_memoizerific = __toESM(require_memoizerific(), 1), getImportPathMap = (0, import_memoizerific.default)(1)(
    (entries) => Object.values(entries).reduce(
      (acc, entry) => (acc[entry.importPath] = acc[entry.importPath] || entry, acc),
      {}
    )
  );
  var deprecatedStoryAnnotation = dedent`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
  var inferType = (value2, name, visited) => {
    let type = typeof value2;
    switch (type) {
      case "boolean":
      case "string":
      case "number":
      case "function":
      case "symbol":
        return { name: type };
      default:
        break;
    }
    return value2 ? visited.has(value2) ? (logger.warn(dedent`
        We've detected a cycle in arg '${name}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args
      `), { name: "other", value: "cyclic object" }) : (visited.add(value2), Array.isArray(value2) ? { name: "array", value: value2.length > 0 ? inferType(value2[0], name, new Set(visited)) : { name: "other", value: "unknown" } } : { name: "object", value: mapValues(value2, (field) => inferType(field, name, new Set(visited))) }) : { name: "object", value: {} };
  }, inferArgTypes = (context) => {
    let { id: id2, argTypes: userArgTypes = {}, initialArgs = {} } = context, argTypes = mapValues(initialArgs, (arg, key) => ({
      name: key,
      type: inferType(arg, `${id2}.${key}`, /* @__PURE__ */ new Set())
    })), userArgTypesNames = mapValues(userArgTypes, (argType, key) => ({
      name: key
    }));
    return combineParameters2(argTypes, userArgTypesNames, userArgTypes);
  };
  inferArgTypes.secondPass = !0;
  var matches = (name, descriptor) => Array.isArray(descriptor) ? descriptor.includes(name) : name.match(descriptor), filterArgTypes = (argTypes, include, exclude) => !include && !exclude ? argTypes : argTypes && pickBy(argTypes, (argType, key) => {
    let name = argType.name || key.toString();
    return !!(!include || matches(name, include)) && (!exclude || !matches(name, exclude));
  }), inferControl = (argType, name, matchers) => {
    let { type, options } = argType;
    if (type) {
      if (matchers.color && matchers.color.test(name)) {
        let controlType = type.name;
        if (controlType === "string")
          return { control: { type: "color" } };
        controlType !== "enum" && logger.warn(
          `Addon controls: Control of type color only supports string, received "${controlType}" instead`
        );
      }
      if (matchers.date && matchers.date.test(name))
        return { control: { type: "date" } };
      switch (type.name) {
        case "array":
          return { control: { type: "object" } };
        case "boolean":
          return { control: { type: "boolean" } };
        case "string":
          return { control: { type: "text" } };
        case "number":
          return { control: { type: "number" } };
        case "enum": {
          let { value: value2 } = type;
          return { control: { type: value2?.length <= 5 ? "radio" : "select" }, options: value2 };
        }
        case "function":
        case "symbol":
          return null;
        default:
          return { control: { type: options ? "select" : "object" } };
      }
    }
  }, inferControls = (context) => {
    let {
      argTypes,
      parameters: { __isArgsStory, controls: { include = null, exclude = null, matchers = {} } = {} }
    } = context;
    if (!__isArgsStory)
      return argTypes;
    let filteredArgTypes = filterArgTypes(argTypes, include, exclude), withControls = mapValues(filteredArgTypes, (argType, name) => argType?.type && inferControl(argType, name.toString(), matchers));
    return combineParameters2(withControls, filteredArgTypes);
  };
  inferControls.secondPass = !0;
  var PREPARE_ABORTED = new Error("prepareAborted"), { AbortController: AbortController2 } = globalThis;
  var { fetch } = scope;
  var import_picoquery2 = __toESM(require_main(), 1), import_picoquery = __toESM(require_main(), 1);
  var { history, document: document2 } = scope;
  var import_ansi_to_html = __toESM(require_ansi_to_html(), 1), import_picoquery3 = __toESM(require_main(), 1), { document: document3 } = scope;
  var Mode = ((Mode2) => (Mode2.MAIN = "MAIN", Mode2.NOPREVIEW = "NOPREVIEW", Mode2.PREPARING_STORY = "PREPARING_STORY", Mode2.PREPARING_DOCS = "PREPARING_DOCS", Mode2.ERROR = "ERROR", Mode2))(Mode || {});
  var ansiConverter = new import_ansi_to_html.default({
    escapeXML: !0
  });
  var { document: document4 } = scope;

  // node_modules/storybook/dist/csf/index.js
  init_chunk_NZMVUW5T();

  // node_modules/storybook/dist/_browser-chunks/chunk-KJHJLCBK.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var ADDON_ID7 = "storybook/highlight", HIGHLIGHT = `${ADDON_ID7}/add`, REMOVE_HIGHLIGHT = `${ADDON_ID7}/remove`, RESET_HIGHLIGHT = `${ADDON_ID7}/reset`, SCROLL_INTO_VIEW = `${ADDON_ID7}/scroll-into-view`, MAX_Z_INDEX = 2147483647, MIN_TOUCH_AREA_SIZE = 28;

  // node_modules/storybook/dist/_browser-chunks/chunk-ECQ75MKQ.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/storybook/dist/_browser-chunks/chunk-EUVGDK4H.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/storybook/dist/preview-api/index.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_NZMVUW5T();
  init_chunk_A242L54C();

  // node_modules/storybook/dist/_browser-chunks/chunk-EUVGDK4H.js
  var config = {
    depth: 10,
    clearOnStoryChange: !0,
    limit: 50
  };
  var findProto = (obj, callback) => {
    let proto = Object.getPrototypeOf(obj);
    return !proto || callback(proto) ? proto : findProto(proto, callback);
  }, isReactSyntheticEvent = (e) => !!(typeof e == "object" && e && findProto(e, (proto) => /^Synthetic(?:Base)?Event$/.test(proto.constructor.name)) && typeof e.persist == "function"), serializeArg = (a3) => {
    if (isReactSyntheticEvent(a3)) {
      let e = Object.create(
        a3.constructor.prototype,
        Object.getOwnPropertyDescriptors(a3)
      );
      e.persist();
      let viewDescriptor = Object.getOwnPropertyDescriptor(e, "view"), view = viewDescriptor?.value;
      return typeof view == "object" && view?.constructor.name === "Window" && Object.defineProperty(e, "view", {
        ...viewDescriptor,
        value: Object.create(view.constructor.prototype)
      }), e;
    }
    return a3;
  };
  function action(name, options = {}) {
    let actionOptions = {
      ...config,
      ...options
    }, handler = function(...args) {
      if (options.implicit) {
        let storyRenderer = ("__STORYBOOK_PREVIEW__" in scope ? scope.__STORYBOOK_PREVIEW__ : void 0)?.storyRenders.find(
          (render) => render.phase === "playing" || render.phase === "rendering"
        );
        if (storyRenderer) {
          let deprecated = !globalThis?.FEATURES?.disallowImplicitActionsInRenderV8, error = new ImplicitActionsDuringRendering({
            phase: storyRenderer.phase,
            name,
            deprecated
          });
          if (deprecated)
            console.warn(error);
          else
            throw error;
        }
      }
      let channel = addons2.getChannel(), id2 = Date.now().toString(36) + Math.random().toString(36).substring(2), minDepth = 5, serializedArgs = args.map(serializeArg), normalizedArgs = args.length > 1 ? serializedArgs : serializedArgs[0], actionDisplayToEmit = {
        id: id2,
        count: 0,
        data: { name, args: normalizedArgs },
        options: {
          ...actionOptions,
          maxDepth: minDepth + (actionOptions.depth || 3)
        }
      };
      channel.emit(EVENT_ID, actionDisplayToEmit);
    };
    return handler.isAction = !0, handler.implicit = options.implicit, handler;
  }

  // node_modules/storybook/dist/csf/index.js
  init_chunk_A242L54C();

  // global-externals:storybook/test
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var test_default = __STORYBOOK_TEST__, { buildQueries, clearAllMocks, configure, createEvent, expect, findAllByAltText, findAllByDisplayValue, findAllByLabelText, findAllByPlaceholderText, findAllByRole, findAllByTestId, findAllByText, findAllByTitle, findByAltText, findByDisplayValue, findByLabelText, findByPlaceholderText, findByRole, findByTestId, findByText, findByTitle, fireEvent, fn, getAllByAltText, getAllByDisplayValue, getAllByLabelText, getAllByPlaceholderText, getAllByRole, getAllByTestId, getAllByText, getAllByTitle, getByAltText, getByDisplayValue, getByLabelText, getByPlaceholderText, getByRole, getByTestId, getByText, getByTitle, getConfig, getDefaultNormalizer, getElementError, getNodeText, getQueriesForElement, getRoles, getSuggestedQuery, isInaccessible, isMockFunction, logDOM, logRoles, mocked, mocks, onMockCall, prettyDOM, prettyFormat, queries, queryAllByAltText, queryAllByAttribute, queryAllByDisplayValue, queryAllByLabelText, queryAllByPlaceholderText, queryAllByRole, queryAllByTestId, queryAllByText, queryAllByTitle, queryByAltText, queryByAttribute, queryByDisplayValue, queryByLabelText, queryByPlaceholderText, queryByRole, queryByTestId, queryByText, queryByTitle, queryHelpers, resetAllMocks, restoreAllMocks, sb, screen, spyOn, uninstrumentedUserEvent, userEvent, waitFor, waitForElementToBeRemoved, within } = __STORYBOOK_TEST__;

  // node_modules/storybook/dist/instrumenter/index.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/storybook/dist/_browser-chunks/chunk-Q5RYDXT3.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var f = {
    reset: [0, 0],
    bold: [1, 22, "\x1B[22m\x1B[1m"],
    dim: [2, 22, "\x1B[22m\x1B[2m"],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29],
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    gray: [90, 39],
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    blackBright: [90, 39],
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39],
    bgBlackBright: [100, 49],
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }, h = Object.entries(f);
  function a(n2) {
    return String(n2);
  }
  a.open = "";
  a.close = "";
  var B = h.reduce(
    (n2, [e]) => (n2[e] = a, n2),
    { isColorSupported: !1 }
  );
  function C(n2 = !1) {
    let e = typeof process < "u" ? process : void 0, i3 = e?.env || {}, g3 = e?.argv || [];
    return !("NO_COLOR" in i3 || g3.includes("--no-color")) && ("FORCE_COLOR" in i3 || g3.includes("--color") || e?.platform === "win32" || n2 && i3.TERM !== "dumb" || "CI" in i3) || typeof window < "u" && !!window.chrome;
  }
  function p(n2 = !1) {
    let e = C(n2), i3 = (r2, t, c3, o2) => {
      let l2 = "", s22 = 0;
      do
        l2 += r2.substring(s22, o2) + c3, s22 = o2 + t.length, o2 = r2.indexOf(t, s22);
      while (~o2);
      return l2 + r2.substring(s22);
    }, g3 = (r2, t, c3 = r2) => {
      let o2 = (l2) => {
        let s22 = String(l2), b3 = s22.indexOf(t, r2.length);
        return ~b3 ? r2 + i3(s22, t, c3, b3) + t : r2 + s22 + t;
      };
      return o2.open = r2, o2.close = t, o2;
    }, u3 = {
      isColorSupported: e
    }, d3 = (r2) => `\x1B[${r2}m`;
    for (let [r2, t] of h)
      u3[r2] = e ? g3(
        d3(t[0]),
        d3(t[1]),
        t[2]
      ) : a;
    return u3;
  }
  var s = p();
  function _mergeNamespaces(n2, m22) {
    return m22.forEach(function(e) {
      e && typeof e != "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k3) {
        if (k3 !== "default" && !(k3 in n2)) {
          var d3 = Object.getOwnPropertyDescriptor(e, k3);
          Object.defineProperty(n2, k3, d3.get ? d3 : {
            enumerable: !0,
            get: function() {
              return e[k3];
            }
          });
        }
      });
    }), Object.freeze(n2);
  }
  function getKeysOfEnumerableProperties(object2, compareKeys) {
    let rawKeys = Object.keys(object2), keys = compareKeys === null ? rawKeys : rawKeys.sort(compareKeys);
    if (Object.getOwnPropertySymbols)
      for (let symbol of Object.getOwnPropertySymbols(object2))
        Object.getOwnPropertyDescriptor(object2, symbol).enumerable && keys.push(symbol);
    return keys;
  }
  function printIteratorEntries(iterator, config2, indentation, depth, refs, printer2, separator = ": ") {
    let result = "", width = 0, current = iterator.next();
    if (!current.done) {
      result += config2.spacingOuter;
      let indentationNext = indentation + config2.indent;
      for (; !current.done; ) {
        if (result += indentationNext, width++ === config2.maxWidth) {
          result += "\u2026";
          break;
        }
        let name = printer2(current.value[0], config2, indentationNext, depth, refs), value2 = printer2(current.value[1], config2, indentationNext, depth, refs);
        result += name + separator + value2, current = iterator.next(), current.done ? config2.min || (result += ",") : result += `,${config2.spacingInner}`;
      }
      result += config2.spacingOuter + indentation;
    }
    return result;
  }
  function printIteratorValues(iterator, config2, indentation, depth, refs, printer2) {
    let result = "", width = 0, current = iterator.next();
    if (!current.done) {
      result += config2.spacingOuter;
      let indentationNext = indentation + config2.indent;
      for (; !current.done; ) {
        if (result += indentationNext, width++ === config2.maxWidth) {
          result += "\u2026";
          break;
        }
        result += printer2(current.value, config2, indentationNext, depth, refs), current = iterator.next(), current.done ? config2.min || (result += ",") : result += `,${config2.spacingInner}`;
      }
      result += config2.spacingOuter + indentation;
    }
    return result;
  }
  function printListItems(list, config2, indentation, depth, refs, printer2) {
    let result = "";
    list = list instanceof ArrayBuffer ? new DataView(list) : list;
    let isDataView = (l2) => l2 instanceof DataView, length = isDataView(list) ? list.byteLength : list.length;
    if (length > 0) {
      result += config2.spacingOuter;
      let indentationNext = indentation + config2.indent;
      for (let i3 = 0; i3 < length; i3++) {
        if (result += indentationNext, i3 === config2.maxWidth) {
          result += "\u2026";
          break;
        }
        (isDataView(list) || i3 in list) && (result += printer2(isDataView(list) ? list.getInt8(i3) : list[i3], config2, indentationNext, depth, refs)), i3 < length - 1 ? result += `,${config2.spacingInner}` : config2.min || (result += ",");
      }
      result += config2.spacingOuter + indentation;
    }
    return result;
  }
  function printObjectProperties(val, config2, indentation, depth, refs, printer2) {
    let result = "", keys = getKeysOfEnumerableProperties(val, config2.compareKeys);
    if (keys.length > 0) {
      result += config2.spacingOuter;
      let indentationNext = indentation + config2.indent;
      for (let i3 = 0; i3 < keys.length; i3++) {
        let key = keys[i3], name = printer2(key, config2, indentationNext, depth, refs), value2 = printer2(val[key], config2, indentationNext, depth, refs);
        result += `${indentationNext + name}: ${value2}`, i3 < keys.length - 1 ? result += `,${config2.spacingInner}` : config2.min || (result += ",");
      }
      result += config2.spacingOuter + indentation;
    }
    return result;
  }
  var asymmetricMatcher = typeof Symbol == "function" && Symbol.for ? /* @__PURE__ */ Symbol.for("jest.asymmetricMatcher") : 1267621, SPACE$2 = " ", serialize$5 = (val, config2, indentation, depth, refs, printer2) => {
    let stringedValue = val.toString();
    if (stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining")
      return ++depth > config2.maxDepth ? `[${stringedValue}]` : `${stringedValue + SPACE$2}[${printListItems(val.sample, config2, indentation, depth, refs, printer2)}]`;
    if (stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining")
      return ++depth > config2.maxDepth ? `[${stringedValue}]` : `${stringedValue + SPACE$2}{${printObjectProperties(val.sample, config2, indentation, depth, refs, printer2)}}`;
    if (stringedValue === "StringMatching" || stringedValue === "StringNotMatching" || stringedValue === "StringContaining" || stringedValue === "StringNotContaining")
      return stringedValue + SPACE$2 + printer2(val.sample, config2, indentation, depth, refs);
    if (typeof val.toAsymmetricMatcher != "function")
      throw new TypeError(`Asymmetric matcher ${val.constructor.name} does not implement toAsymmetricMatcher()`);
    return val.toAsymmetricMatcher();
  }, test$5 = (val) => val && val.$$typeof === asymmetricMatcher, plugin$5 = {
    serialize: serialize$5,
    test: test$5
  }, SPACE$1 = " ", OBJECT_NAMES = /* @__PURE__ */ new Set(["DOMStringMap", "NamedNodeMap"]), ARRAY_REGEXP = /^(?:HTML\w*Collection|NodeList)$/;
  function testName(name) {
    return OBJECT_NAMES.has(name) || ARRAY_REGEXP.test(name);
  }
  var test$4 = (val) => val && val.constructor && !!val.constructor.name && testName(val.constructor.name);
  function isNamedNodeMap(collection) {
    return collection.constructor.name === "NamedNodeMap";
  }
  var serialize$4 = (collection, config2, indentation, depth, refs, printer2) => {
    let name = collection.constructor.name;
    return ++depth > config2.maxDepth ? `[${name}]` : (config2.min ? "" : name + SPACE$1) + (OBJECT_NAMES.has(name) ? `{${printObjectProperties(isNamedNodeMap(collection) ? [...collection].reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}) : { ...collection }, config2, indentation, depth, refs, printer2)}}` : `[${printListItems([...collection], config2, indentation, depth, refs, printer2)}]`);
  }, plugin$4 = {
    serialize: serialize$4,
    test: test$4
  };
  function escapeHTML(str) {
    return str.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
  }
  function printProps(keys, props, config2, indentation, depth, refs, printer2) {
    let indentationNext = indentation + config2.indent, colors3 = config2.colors;
    return keys.map((key) => {
      let value2 = props[key], printed = printer2(value2, config2, indentationNext, depth, refs);
      return typeof value2 != "string" && (printed.includes(`
`) && (printed = config2.spacingOuter + indentationNext + printed + config2.spacingOuter + indentation), printed = `{${printed}}`), `${config2.spacingInner + indentation + colors3.prop.open + key + colors3.prop.close}=${colors3.value.open}${printed}${colors3.value.close}`;
    }).join("");
  }
  function printChildren(children, config2, indentation, depth, refs, printer2) {
    return children.map((child) => config2.spacingOuter + indentation + (typeof child == "string" ? printText(child, config2) : printer2(child, config2, indentation, depth, refs))).join("");
  }
  function printText(text, config2) {
    let contentColor = config2.colors.content;
    return contentColor.open + escapeHTML(text) + contentColor.close;
  }
  function printComment(comment, config2) {
    let commentColor = config2.colors.comment;
    return `${commentColor.open}<!--${escapeHTML(comment)}-->${commentColor.close}`;
  }
  function printElement(type, printedProps, printedChildren, config2, indentation) {
    let tagColor = config2.colors.tag;
    return `${tagColor.open}<${type}${printedProps && tagColor.close + printedProps + config2.spacingOuter + indentation + tagColor.open}${printedChildren ? `>${tagColor.close}${printedChildren}${config2.spacingOuter}${indentation}${tagColor.open}</${type}` : `${printedProps && !config2.min ? "" : " "}/`}>${tagColor.close}`;
  }
  function printElementAsLeaf(type, config2) {
    let tagColor = config2.colors.tag;
    return `${tagColor.open}<${type}${tagColor.close} \u2026${tagColor.open} />${tagColor.close}`;
  }
  var ELEMENT_NODE = 1, TEXT_NODE = 3, COMMENT_NODE = 8, FRAGMENT_NODE = 11, ELEMENT_REGEXP = /^(?:(?:HTML|SVG)\w*)?Element$/;
  function testHasAttribute(val) {
    try {
      return typeof val.hasAttribute == "function" && val.hasAttribute("is");
    } catch {
      return !1;
    }
  }
  function testNode(val) {
    let constructorName = val.constructor.name, { nodeType, tagName } = val, isCustomElement = typeof tagName == "string" && tagName.includes("-") || testHasAttribute(val);
    return nodeType === ELEMENT_NODE && (ELEMENT_REGEXP.test(constructorName) || isCustomElement) || nodeType === TEXT_NODE && constructorName === "Text" || nodeType === COMMENT_NODE && constructorName === "Comment" || nodeType === FRAGMENT_NODE && constructorName === "DocumentFragment";
  }
  var test$3 = (val) => {
    var _val$constructor;
    return (val == null || (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) && testNode(val);
  };
  function nodeIsText(node) {
    return node.nodeType === TEXT_NODE;
  }
  function nodeIsComment(node) {
    return node.nodeType === COMMENT_NODE;
  }
  function nodeIsFragment(node) {
    return node.nodeType === FRAGMENT_NODE;
  }
  var serialize$3 = (node, config2, indentation, depth, refs, printer2) => {
    if (nodeIsText(node))
      return printText(node.data, config2);
    if (nodeIsComment(node))
      return printComment(node.data, config2);
    let type = nodeIsFragment(node) ? "DocumentFragment" : node.tagName.toLowerCase();
    return ++depth > config2.maxDepth ? printElementAsLeaf(type, config2) : printElement(type, printProps(nodeIsFragment(node) ? [] : Array.from(node.attributes, (attr) => attr.name).sort(), nodeIsFragment(node) ? {} : [...node.attributes].reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}), config2, indentation + config2.indent, depth, refs, printer2), printChildren(Array.prototype.slice.call(node.childNodes || node.children), config2, indentation + config2.indent, depth, refs, printer2), config2, indentation);
  }, plugin$3 = {
    serialize: serialize$3,
    test: test$3
  }, IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@", IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@", IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@", IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@", IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@", IS_RECORD_SENTINEL = "@@__IMMUTABLE_RECORD__@@", IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@", IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@", IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@", getImmutableName = (name) => `Immutable.${name}`, printAsLeaf = (name) => `[${name}]`, SPACE = " ", LAZY = "\u2026";
  function printImmutableEntries(val, config2, indentation, depth, refs, printer2, type) {
    return ++depth > config2.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}{${printIteratorEntries(val.entries(), config2, indentation, depth, refs, printer2)}}`;
  }
  function getRecordEntries(val) {
    let i3 = 0;
    return { next() {
      if (i3 < val._keys.length) {
        let key = val._keys[i3++];
        return {
          done: !1,
          value: [key, val.get(key)]
        };
      }
      return {
        done: !0,
        value: void 0
      };
    } };
  }
  function printImmutableRecord(val, config2, indentation, depth, refs, printer2) {
    let name = getImmutableName(val._name || "Record");
    return ++depth > config2.maxDepth ? printAsLeaf(name) : `${name + SPACE}{${printIteratorEntries(getRecordEntries(val), config2, indentation, depth, refs, printer2)}}`;
  }
  function printImmutableSeq(val, config2, indentation, depth, refs, printer2) {
    let name = getImmutableName("Seq");
    return ++depth > config2.maxDepth ? printAsLeaf(name) : val[IS_KEYED_SENTINEL] ? `${name + SPACE}{${val._iter || val._object ? printIteratorEntries(val.entries(), config2, indentation, depth, refs, printer2) : LAZY}}` : `${name + SPACE}[${val._iter || val._array || val._collection || val._iterable ? printIteratorValues(val.values(), config2, indentation, depth, refs, printer2) : LAZY}]`;
  }
  function printImmutableValues(val, config2, indentation, depth, refs, printer2, type) {
    return ++depth > config2.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}[${printIteratorValues(val.values(), config2, indentation, depth, refs, printer2)}]`;
  }
  var serialize$2 = (val, config2, indentation, depth, refs, printer2) => val[IS_MAP_SENTINEL] ? printImmutableEntries(val, config2, indentation, depth, refs, printer2, val[IS_ORDERED_SENTINEL] ? "OrderedMap" : "Map") : val[IS_LIST_SENTINEL] ? printImmutableValues(val, config2, indentation, depth, refs, printer2, "List") : val[IS_SET_SENTINEL] ? printImmutableValues(val, config2, indentation, depth, refs, printer2, val[IS_ORDERED_SENTINEL] ? "OrderedSet" : "Set") : val[IS_STACK_SENTINEL] ? printImmutableValues(val, config2, indentation, depth, refs, printer2, "Stack") : val[IS_SEQ_SENTINEL] ? printImmutableSeq(val, config2, indentation, depth, refs, printer2) : printImmutableRecord(val, config2, indentation, depth, refs, printer2), test$2 = (val) => val && (val[IS_ITERABLE_SENTINEL] === !0 || val[IS_RECORD_SENTINEL] === !0), plugin$2 = {
    serialize: serialize$2,
    test: test$2
  };
  function getDefaultExportFromCjs(x3) {
    return x3 && x3.__esModule && Object.prototype.hasOwnProperty.call(x3, "default") ? x3.default : x3;
  }
  var reactIs$1 = { exports: {} };
  var reactIs_development$1 = {}, hasRequiredReactIs_development$1;
  function requireReactIs_development$1() {
    return hasRequiredReactIs_development$1 || (hasRequiredReactIs_development$1 = 1, (function() {
      function typeOf(object2) {
        if (typeof object2 == "object" && object2 !== null) {
          var $$typeof = object2.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              switch (object2 = object2.type, object2) {
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                case REACT_VIEW_TRANSITION_TYPE:
                  return object2;
                default:
                  switch (object2 = object2 && object2.$$typeof, object2) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                      return object2;
                    case REACT_CONSUMER_TYPE:
                      return object2;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
      }
      var REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for("react.memo"), REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = /* @__PURE__ */ Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = /* @__PURE__ */ Symbol.for("react.client.reference");
      reactIs_development$1.ContextConsumer = REACT_CONSUMER_TYPE, reactIs_development$1.ContextProvider = REACT_CONTEXT_TYPE, reactIs_development$1.Element = REACT_ELEMENT_TYPE, reactIs_development$1.ForwardRef = REACT_FORWARD_REF_TYPE, reactIs_development$1.Fragment = REACT_FRAGMENT_TYPE, reactIs_development$1.Lazy = REACT_LAZY_TYPE, reactIs_development$1.Memo = REACT_MEMO_TYPE, reactIs_development$1.Portal = REACT_PORTAL_TYPE, reactIs_development$1.Profiler = REACT_PROFILER_TYPE, reactIs_development$1.StrictMode = REACT_STRICT_MODE_TYPE, reactIs_development$1.Suspense = REACT_SUSPENSE_TYPE, reactIs_development$1.SuspenseList = REACT_SUSPENSE_LIST_TYPE, reactIs_development$1.isContextConsumer = function(object2) {
        return typeOf(object2) === REACT_CONSUMER_TYPE;
      }, reactIs_development$1.isContextProvider = function(object2) {
        return typeOf(object2) === REACT_CONTEXT_TYPE;
      }, reactIs_development$1.isElement = function(object2) {
        return typeof object2 == "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
      }, reactIs_development$1.isForwardRef = function(object2) {
        return typeOf(object2) === REACT_FORWARD_REF_TYPE;
      }, reactIs_development$1.isFragment = function(object2) {
        return typeOf(object2) === REACT_FRAGMENT_TYPE;
      }, reactIs_development$1.isLazy = function(object2) {
        return typeOf(object2) === REACT_LAZY_TYPE;
      }, reactIs_development$1.isMemo = function(object2) {
        return typeOf(object2) === REACT_MEMO_TYPE;
      }, reactIs_development$1.isPortal = function(object2) {
        return typeOf(object2) === REACT_PORTAL_TYPE;
      }, reactIs_development$1.isProfiler = function(object2) {
        return typeOf(object2) === REACT_PROFILER_TYPE;
      }, reactIs_development$1.isStrictMode = function(object2) {
        return typeOf(object2) === REACT_STRICT_MODE_TYPE;
      }, reactIs_development$1.isSuspense = function(object2) {
        return typeOf(object2) === REACT_SUSPENSE_TYPE;
      }, reactIs_development$1.isSuspenseList = function(object2) {
        return typeOf(object2) === REACT_SUSPENSE_LIST_TYPE;
      }, reactIs_development$1.isValidElementType = function(type) {
        return typeof type == "string" || typeof type == "function" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type == "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0);
      }, reactIs_development$1.typeOf = typeOf;
    })()), reactIs_development$1;
  }
  var hasRequiredReactIs$1;
  function requireReactIs$1() {
    return hasRequiredReactIs$1 || (hasRequiredReactIs$1 = 1, reactIs$1.exports = requireReactIs_development$1()), reactIs$1.exports;
  }
  var reactIsExports$1 = requireReactIs$1(), index$1 = getDefaultExportFromCjs(reactIsExports$1), ReactIs19 = _mergeNamespaces({
    __proto__: null,
    default: index$1
  }, [reactIsExports$1]), reactIs = { exports: {} };
  var reactIs_development = {}, hasRequiredReactIs_development;
  function requireReactIs_development() {
    return hasRequiredReactIs_development || (hasRequiredReactIs_development = 1, (function() {
      var REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for("react.element"), REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = /* @__PURE__ */ Symbol.for("react.provider"), REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for("react.context"), REACT_SERVER_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for("react.server_context"), REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for("react.memo"), REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = /* @__PURE__ */ Symbol.for("react.offscreen"), enableScopeAPI = !1, enableCacheElement = !1, enableTransitionTracing = !1, enableLegacyHidden = !1, enableDebugTracing = !1, REACT_MODULE_REFERENCE;
      REACT_MODULE_REFERENCE = /* @__PURE__ */ Symbol.for("react.module.reference");
      function isValidElementType(type) {
        return !!(typeof type == "string" || typeof type == "function" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing || typeof type == "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0));
      }
      function typeOf(object2) {
        if (typeof object2 == "object" && object2 !== null) {
          var $$typeof = object2.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object2.type;
              switch (type) {
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                  return type;
                default:
                  var $$typeofType = type && type.$$typeof;
                  switch ($$typeofType) {
                    case REACT_SERVER_CONTEXT_TYPE:
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
      }
      var ContextConsumer = REACT_CONTEXT_TYPE, ContextProvider = REACT_PROVIDER_TYPE, Element2 = REACT_ELEMENT_TYPE, ForwardRef = REACT_FORWARD_REF_TYPE, Fragment2 = REACT_FRAGMENT_TYPE, Lazy = REACT_LAZY_TYPE, Memo = REACT_MEMO_TYPE, Portal = REACT_PORTAL_TYPE, Profiler2 = REACT_PROFILER_TYPE, StrictMode2 = REACT_STRICT_MODE_TYPE, Suspense2 = REACT_SUSPENSE_TYPE, SuspenseList = REACT_SUSPENSE_LIST_TYPE, hasWarnedAboutDeprecatedIsAsyncMode = !1, hasWarnedAboutDeprecatedIsConcurrentMode = !1;
      function isAsyncMode(object2) {
        return hasWarnedAboutDeprecatedIsAsyncMode || (hasWarnedAboutDeprecatedIsAsyncMode = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
      }
      function isConcurrentMode(object2) {
        return hasWarnedAboutDeprecatedIsConcurrentMode || (hasWarnedAboutDeprecatedIsConcurrentMode = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
      }
      function isContextConsumer(object2) {
        return typeOf(object2) === REACT_CONTEXT_TYPE;
      }
      function isContextProvider(object2) {
        return typeOf(object2) === REACT_PROVIDER_TYPE;
      }
      function isElement(object2) {
        return typeof object2 == "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
      }
      function isForwardRef(object2) {
        return typeOf(object2) === REACT_FORWARD_REF_TYPE;
      }
      function isFragment(object2) {
        return typeOf(object2) === REACT_FRAGMENT_TYPE;
      }
      function isLazy(object2) {
        return typeOf(object2) === REACT_LAZY_TYPE;
      }
      function isMemo(object2) {
        return typeOf(object2) === REACT_MEMO_TYPE;
      }
      function isPortal(object2) {
        return typeOf(object2) === REACT_PORTAL_TYPE;
      }
      function isProfiler(object2) {
        return typeOf(object2) === REACT_PROFILER_TYPE;
      }
      function isStrictMode(object2) {
        return typeOf(object2) === REACT_STRICT_MODE_TYPE;
      }
      function isSuspense(object2) {
        return typeOf(object2) === REACT_SUSPENSE_TYPE;
      }
      function isSuspenseList(object2) {
        return typeOf(object2) === REACT_SUSPENSE_LIST_TYPE;
      }
      reactIs_development.ContextConsumer = ContextConsumer, reactIs_development.ContextProvider = ContextProvider, reactIs_development.Element = Element2, reactIs_development.ForwardRef = ForwardRef, reactIs_development.Fragment = Fragment2, reactIs_development.Lazy = Lazy, reactIs_development.Memo = Memo, reactIs_development.Portal = Portal, reactIs_development.Profiler = Profiler2, reactIs_development.StrictMode = StrictMode2, reactIs_development.Suspense = Suspense2, reactIs_development.SuspenseList = SuspenseList, reactIs_development.isAsyncMode = isAsyncMode, reactIs_development.isConcurrentMode = isConcurrentMode, reactIs_development.isContextConsumer = isContextConsumer, reactIs_development.isContextProvider = isContextProvider, reactIs_development.isElement = isElement, reactIs_development.isForwardRef = isForwardRef, reactIs_development.isFragment = isFragment, reactIs_development.isLazy = isLazy, reactIs_development.isMemo = isMemo, reactIs_development.isPortal = isPortal, reactIs_development.isProfiler = isProfiler, reactIs_development.isStrictMode = isStrictMode, reactIs_development.isSuspense = isSuspense, reactIs_development.isSuspenseList = isSuspenseList, reactIs_development.isValidElementType = isValidElementType, reactIs_development.typeOf = typeOf;
    })()), reactIs_development;
  }
  var hasRequiredReactIs;
  function requireReactIs() {
    return hasRequiredReactIs || (hasRequiredReactIs = 1, reactIs.exports = requireReactIs_development()), reactIs.exports;
  }
  var reactIsExports = requireReactIs(), index = getDefaultExportFromCjs(reactIsExports), ReactIs18 = _mergeNamespaces({
    __proto__: null,
    default: index
  }, [reactIsExports]), reactIsMethods = [
    "isAsyncMode",
    "isConcurrentMode",
    "isContextConsumer",
    "isContextProvider",
    "isElement",
    "isForwardRef",
    "isFragment",
    "isLazy",
    "isMemo",
    "isPortal",
    "isProfiler",
    "isStrictMode",
    "isSuspense",
    "isSuspenseList",
    "isValidElementType"
  ], ReactIs = Object.fromEntries(reactIsMethods.map((m22) => [m22, (v3) => ReactIs18[m22](v3) || ReactIs19[m22](v3)]));
  function getChildren(arg, children = []) {
    if (Array.isArray(arg))
      for (let item of arg)
        getChildren(item, children);
    else arg != null && arg !== !1 && arg !== "" && children.push(arg);
    return children;
  }
  function getType(element) {
    let type = element.type;
    if (typeof type == "string")
      return type;
    if (typeof type == "function")
      return type.displayName || type.name || "Unknown";
    if (ReactIs.isFragment(element))
      return "React.Fragment";
    if (ReactIs.isSuspense(element))
      return "React.Suspense";
    if (typeof type == "object" && type !== null) {
      if (ReactIs.isContextProvider(element))
        return "Context.Provider";
      if (ReactIs.isContextConsumer(element))
        return "Context.Consumer";
      if (ReactIs.isForwardRef(element)) {
        if (type.displayName)
          return type.displayName;
        let functionName = type.render.displayName || type.render.name || "";
        return functionName === "" ? "ForwardRef" : `ForwardRef(${functionName})`;
      }
      if (ReactIs.isMemo(element)) {
        let functionName = type.displayName || type.type.displayName || type.type.name || "";
        return functionName === "" ? "Memo" : `Memo(${functionName})`;
      }
    }
    return "UNDEFINED";
  }
  function getPropKeys$1(element) {
    let { props } = element;
    return Object.keys(props).filter((key) => key !== "children" && props[key] !== void 0).sort();
  }
  var serialize$1 = (element, config2, indentation, depth, refs, printer2) => ++depth > config2.maxDepth ? printElementAsLeaf(getType(element), config2) : printElement(getType(element), printProps(getPropKeys$1(element), element.props, config2, indentation + config2.indent, depth, refs, printer2), printChildren(getChildren(element.props.children), config2, indentation + config2.indent, depth, refs, printer2), config2, indentation), test$1 = (val) => val != null && ReactIs.isElement(val), plugin$1 = {
    serialize: serialize$1,
    test: test$1
  }, testSymbol = typeof Symbol == "function" && Symbol.for ? /* @__PURE__ */ Symbol.for("react.test.json") : 245830487;
  function getPropKeys(object2) {
    let { props } = object2;
    return props ? Object.keys(props).filter((key) => props[key] !== void 0).sort() : [];
  }
  var serialize = (object2, config2, indentation, depth, refs, printer2) => ++depth > config2.maxDepth ? printElementAsLeaf(object2.type, config2) : printElement(object2.type, object2.props ? printProps(getPropKeys(object2), object2.props, config2, indentation + config2.indent, depth, refs, printer2) : "", object2.children ? printChildren(object2.children, config2, indentation + config2.indent, depth, refs, printer2) : "", config2, indentation), test = (val) => val && val.$$typeof === testSymbol, plugin = {
    serialize,
    test
  }, toString = Object.prototype.toString, toISOString = Date.prototype.toISOString, errorToString = Error.prototype.toString, regExpToString = RegExp.prototype.toString;
  function getConstructorName(val) {
    return typeof val.constructor == "function" && val.constructor.name || "Object";
  }
  function isWindow(val) {
    return typeof window < "u" && val === window;
  }
  var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/, NEWLINE_REGEXP = /\n/g, PrettyFormatPluginError = class extends Error {
    constructor(message, stack) {
      super(message), this.stack = stack, this.name = this.constructor.name;
    }
  };
  function isToStringedArrayType(toStringed) {
    return toStringed === "[object Array]" || toStringed === "[object ArrayBuffer]" || toStringed === "[object DataView]" || toStringed === "[object Float32Array]" || toStringed === "[object Float64Array]" || toStringed === "[object Int8Array]" || toStringed === "[object Int16Array]" || toStringed === "[object Int32Array]" || toStringed === "[object Uint8Array]" || toStringed === "[object Uint8ClampedArray]" || toStringed === "[object Uint16Array]" || toStringed === "[object Uint32Array]";
  }
  function printNumber(val) {
    return Object.is(val, -0) ? "-0" : String(val);
  }
  function printBigInt(val) {
    return `${val}n`;
  }
  function printFunction(val, printFunctionName) {
    return printFunctionName ? `[Function ${val.name || "anonymous"}]` : "[Function]";
  }
  function printSymbol(val) {
    return String(val).replace(SYMBOL_REGEXP, "Symbol($1)");
  }
  function printError(val) {
    return `[${errorToString.call(val)}]`;
  }
  function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
    if (val === !0 || val === !1)
      return `${val}`;
    if (val === void 0)
      return "undefined";
    if (val === null)
      return "null";
    let typeOf = typeof val;
    if (typeOf === "number")
      return printNumber(val);
    if (typeOf === "bigint")
      return printBigInt(val);
    if (typeOf === "string")
      return escapeString ? `"${val.replaceAll(/"|\\/g, "\\$&")}"` : `"${val}"`;
    if (typeOf === "function")
      return printFunction(val, printFunctionName);
    if (typeOf === "symbol")
      return printSymbol(val);
    let toStringed = toString.call(val);
    return toStringed === "[object WeakMap]" ? "WeakMap {}" : toStringed === "[object WeakSet]" ? "WeakSet {}" : toStringed === "[object Function]" || toStringed === "[object GeneratorFunction]" ? printFunction(val, printFunctionName) : toStringed === "[object Symbol]" ? printSymbol(val) : toStringed === "[object Date]" ? Number.isNaN(+val) ? "Date { NaN }" : toISOString.call(val) : toStringed === "[object Error]" ? printError(val) : toStringed === "[object RegExp]" ? escapeRegex ? regExpToString.call(val).replaceAll(/[$()*+.?[\\\]^{|}]/g, "\\$&") : regExpToString.call(val) : val instanceof Error ? printError(val) : null;
  }
  function printComplexValue(val, config2, indentation, depth, refs, hasCalledToJSON) {
    if (refs.includes(val))
      return "[Circular]";
    refs = [...refs], refs.push(val);
    let hitMaxDepth = ++depth > config2.maxDepth, min = config2.min;
    if (config2.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON == "function" && !hasCalledToJSON)
      return printer(val.toJSON(), config2, indentation, depth, refs, !0);
    let toStringed = toString.call(val);
    return toStringed === "[object Arguments]" ? hitMaxDepth ? "[Arguments]" : `${min ? "" : "Arguments "}[${printListItems(val, config2, indentation, depth, refs, printer)}]` : isToStringedArrayType(toStringed) ? hitMaxDepth ? `[${val.constructor.name}]` : `${min || !config2.printBasicPrototype && val.constructor.name === "Array" ? "" : `${val.constructor.name} `}[${printListItems(val, config2, indentation, depth, refs, printer)}]` : toStringed === "[object Map]" ? hitMaxDepth ? "[Map]" : `Map {${printIteratorEntries(val.entries(), config2, indentation, depth, refs, printer, " => ")}}` : toStringed === "[object Set]" ? hitMaxDepth ? "[Set]" : `Set {${printIteratorValues(val.values(), config2, indentation, depth, refs, printer)}}` : hitMaxDepth || isWindow(val) ? `[${getConstructorName(val)}]` : `${min || !config2.printBasicPrototype && getConstructorName(val) === "Object" ? "" : `${getConstructorName(val)} `}{${printObjectProperties(val, config2, indentation, depth, refs, printer)}}`;
  }
  var ErrorPlugin = {
    test: (val) => val && val instanceof Error,
    serialize(val, config2, indentation, depth, refs, printer2) {
      if (refs.includes(val))
        return "[Circular]";
      refs = [...refs, val];
      let hitMaxDepth = ++depth > config2.maxDepth, { message, cause, ...rest } = val, entries = {
        message,
        ...typeof cause < "u" ? { cause } : {},
        ...val instanceof AggregateError ? { errors: val.errors } : {},
        ...rest
      }, name = val.name !== "Error" ? val.name : getConstructorName(val);
      return hitMaxDepth ? `[${name}]` : `${name} {${printIteratorEntries(Object.entries(entries).values(), config2, indentation, depth, refs, printer2)}}`;
    }
  };
  function isNewPlugin(plugin2) {
    return plugin2.serialize != null;
  }
  function printPlugin(plugin2, val, config2, indentation, depth, refs) {
    let printed;
    try {
      printed = isNewPlugin(plugin2) ? plugin2.serialize(val, config2, indentation, depth, refs, printer) : plugin2.print(val, (valChild) => printer(valChild, config2, indentation, depth, refs), (str) => {
        let indentationNext = indentation + config2.indent;
        return indentationNext + str.replaceAll(NEWLINE_REGEXP, `
${indentationNext}`);
      }, {
        edgeSpacing: config2.spacingOuter,
        min: config2.min,
        spacing: config2.spacingInner
      }, config2.colors);
    } catch (error) {
      throw new PrettyFormatPluginError(error.message, error.stack);
    }
    if (typeof printed != "string")
      throw new TypeError(`pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`);
    return printed;
  }
  function findPlugin(plugins2, val) {
    for (let plugin2 of plugins2)
      try {
        if (plugin2.test(val))
          return plugin2;
      } catch (error) {
        throw new PrettyFormatPluginError(error.message, error.stack);
      }
    return null;
  }
  function printer(val, config2, indentation, depth, refs, hasCalledToJSON) {
    let plugin2 = findPlugin(config2.plugins, val);
    if (plugin2 !== null)
      return printPlugin(plugin2, val, config2, indentation, depth, refs);
    let basicResult = printBasicValue(val, config2.printFunctionName, config2.escapeRegex, config2.escapeString);
    return basicResult !== null ? basicResult : printComplexValue(val, config2, indentation, depth, refs, hasCalledToJSON);
  }
  var DEFAULT_THEME = {
    comment: "gray",
    content: "reset",
    prop: "yellow",
    tag: "cyan",
    value: "green"
  }, DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME), DEFAULT_OPTIONS = {
    callToJSON: !0,
    compareKeys: void 0,
    escapeRegex: !1,
    escapeString: !0,
    highlight: !1,
    indent: 2,
    maxDepth: Number.POSITIVE_INFINITY,
    maxWidth: Number.POSITIVE_INFINITY,
    min: !1,
    plugins: [],
    printBasicPrototype: !0,
    printFunctionName: !0,
    theme: DEFAULT_THEME
  };
  function validateOptions(options) {
    for (let key of Object.keys(options))
      if (!Object.prototype.hasOwnProperty.call(DEFAULT_OPTIONS, key))
        throw new Error(`pretty-format: Unknown option "${key}".`);
    if (options.min && options.indent !== void 0 && options.indent !== 0)
      throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
  }
  function getColorsHighlight() {
    return DEFAULT_THEME_KEYS.reduce((colors3, key) => {
      let value2 = DEFAULT_THEME[key], color2 = value2 && s[value2];
      if (color2 && typeof color2.close == "string" && typeof color2.open == "string")
        colors3[key] = color2;
      else
        throw new Error(`pretty-format: Option "theme" has a key "${key}" whose value "${value2}" is undefined in ansi-styles.`);
      return colors3;
    }, /* @__PURE__ */ Object.create(null));
  }
  function getColorsEmpty() {
    return DEFAULT_THEME_KEYS.reduce((colors3, key) => (colors3[key] = {
      close: "",
      open: ""
    }, colors3), /* @__PURE__ */ Object.create(null));
  }
  function getPrintFunctionName(options) {
    return options?.printFunctionName ?? DEFAULT_OPTIONS.printFunctionName;
  }
  function getEscapeRegex(options) {
    return options?.escapeRegex ?? DEFAULT_OPTIONS.escapeRegex;
  }
  function getEscapeString(options) {
    return options?.escapeString ?? DEFAULT_OPTIONS.escapeString;
  }
  function getConfig2(options) {
    return {
      callToJSON: options?.callToJSON ?? DEFAULT_OPTIONS.callToJSON,
      colors: options?.highlight ? getColorsHighlight() : getColorsEmpty(),
      compareKeys: typeof options?.compareKeys == "function" || options?.compareKeys === null ? options.compareKeys : DEFAULT_OPTIONS.compareKeys,
      escapeRegex: getEscapeRegex(options),
      escapeString: getEscapeString(options),
      indent: options?.min ? "" : createIndent(options?.indent ?? DEFAULT_OPTIONS.indent),
      maxDepth: options?.maxDepth ?? DEFAULT_OPTIONS.maxDepth,
      maxWidth: options?.maxWidth ?? DEFAULT_OPTIONS.maxWidth,
      min: options?.min ?? DEFAULT_OPTIONS.min,
      plugins: options?.plugins ?? DEFAULT_OPTIONS.plugins,
      printBasicPrototype: options?.printBasicPrototype ?? !0,
      printFunctionName: getPrintFunctionName(options),
      spacingInner: options?.min ? " " : `
`,
      spacingOuter: options?.min ? "" : `
`
    };
  }
  function createIndent(indent) {
    return Array.from({ length: indent + 1 }).join(" ");
  }
  function format2(val, options) {
    if (options && (validateOptions(options), options.plugins)) {
      let plugin2 = findPlugin(options.plugins, val);
      if (plugin2 !== null)
        return printPlugin(plugin2, val, getConfig2(options), "", 0, []);
    }
    let basicResult = printBasicValue(val, getPrintFunctionName(options), getEscapeRegex(options), getEscapeString(options));
    return basicResult !== null ? basicResult : printComplexValue(val, getConfig2(options), "", 0, []);
  }
  var plugins = {
    AsymmetricMatcher: plugin$5,
    DOMCollection: plugin$4,
    DOMElement: plugin$3,
    Immutable: plugin$2,
    ReactElement: plugin$1,
    ReactTestComponent: plugin,
    Error: ErrorPlugin
  }, ansiColors = {
    bold: ["1", "22"],
    dim: ["2", "22"],
    italic: ["3", "23"],
    underline: ["4", "24"],
    // 5 & 6 are blinking
    inverse: ["7", "27"],
    hidden: ["8", "28"],
    strike: ["9", "29"],
    // 10-20 are fonts
    // 21-29 are resets for 1-9
    black: ["30", "39"],
    red: ["31", "39"],
    green: ["32", "39"],
    yellow: ["33", "39"],
    blue: ["34", "39"],
    magenta: ["35", "39"],
    cyan: ["36", "39"],
    white: ["37", "39"],
    brightblack: ["30;1", "39"],
    brightred: ["31;1", "39"],
    brightgreen: ["32;1", "39"],
    brightyellow: ["33;1", "39"],
    brightblue: ["34;1", "39"],
    brightmagenta: ["35;1", "39"],
    brightcyan: ["36;1", "39"],
    brightwhite: ["37;1", "39"],
    grey: ["90", "39"]
  }, styles = {
    special: "cyan",
    number: "yellow",
    bigint: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    symbol: "green",
    date: "magenta",
    regexp: "red"
  }, truncator = "\u2026";
  function colorise(value2, styleType) {
    let color2 = ansiColors[styles[styleType]] || ansiColors[styleType] || "";
    return color2 ? `\x1B[${color2[0]}m${String(value2)}\x1B[${color2[1]}m` : String(value2);
  }
  function normaliseOptions({
    showHidden = !1,
    depth = 2,
    colors: colors3 = !1,
    customInspect = !0,
    showProxy = !1,
    maxArrayLength = 1 / 0,
    breakLength = 1 / 0,
    seen = [],
    // eslint-disable-next-line no-shadow
    truncate: truncate2 = 1 / 0,
    stylize = String
  } = {}, inspect3) {
    let options = {
      showHidden: !!showHidden,
      depth: Number(depth),
      colors: !!colors3,
      customInspect: !!customInspect,
      showProxy: !!showProxy,
      maxArrayLength: Number(maxArrayLength),
      breakLength: Number(breakLength),
      truncate: Number(truncate2),
      seen,
      inspect: inspect3,
      stylize
    };
    return options.colors && (options.stylize = colorise), options;
  }
  function isHighSurrogate(char) {
    return char >= "\uD800" && char <= "\uDBFF";
  }
  function truncate(string, length, tail = truncator) {
    string = String(string);
    let tailLength = tail.length, stringLength = string.length;
    if (tailLength > length && stringLength > tailLength)
      return tail;
    if (stringLength > length && stringLength > tailLength) {
      let end = length - tailLength;
      return end > 0 && isHighSurrogate(string[end - 1]) && (end = end - 1), `${string.slice(0, end)}${tail}`;
    }
    return string;
  }
  function inspectList(list, options, inspectItem, separator = ", ") {
    inspectItem = inspectItem || options.inspect;
    let size = list.length;
    if (size === 0)
      return "";
    let originalLength = options.truncate, output = "", peek = "", truncated = "";
    for (let i3 = 0; i3 < size; i3 += 1) {
      let last = i3 + 1 === list.length, secondToLast = i3 + 2 === list.length;
      truncated = `${truncator}(${list.length - i3})`;
      let value2 = list[i3];
      options.truncate = originalLength - output.length - (last ? 0 : separator.length);
      let string = peek || inspectItem(value2, options) + (last ? "" : separator), nextLength = output.length + string.length, truncatedLength = nextLength + truncated.length;
      if (last && nextLength > originalLength && output.length + truncated.length <= originalLength || !last && !secondToLast && truncatedLength > originalLength || (peek = last ? "" : inspectItem(list[i3 + 1], options) + (secondToLast ? "" : separator), !last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength))
        break;
      if (output += string, !last && !secondToLast && nextLength + peek.length >= originalLength) {
        truncated = `${truncator}(${list.length - i3 - 1})`;
        break;
      }
      truncated = "";
    }
    return `${output}${truncated}`;
  }
  function quoteComplexKey(key) {
    return key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? key : JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
  }
  function inspectProperty([key, value2], options) {
    return options.truncate -= 2, typeof key == "string" ? key = quoteComplexKey(key) : typeof key != "number" && (key = `[${options.inspect(key, options)}]`), options.truncate -= key.length, value2 = options.inspect(value2, options), `${key}: ${value2}`;
  }
  function inspectArray(array2, options) {
    let nonIndexProperties = Object.keys(array2).slice(array2.length);
    if (!array2.length && !nonIndexProperties.length)
      return "[]";
    options.truncate -= 4;
    let listContents = inspectList(array2, options);
    options.truncate -= listContents.length;
    let propertyContents = "";
    return nonIndexProperties.length && (propertyContents = inspectList(nonIndexProperties.map((key) => [key, array2[key]]), options, inspectProperty)), `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ""} ]`;
  }
  var getArrayName = (array2) => typeof Buffer == "function" && array2 instanceof Buffer ? "Buffer" : array2[Symbol.toStringTag] ? array2[Symbol.toStringTag] : array2.constructor.name;
  function inspectTypedArray(array2, options) {
    let name = getArrayName(array2);
    options.truncate -= name.length + 4;
    let nonIndexProperties = Object.keys(array2).slice(array2.length);
    if (!array2.length && !nonIndexProperties.length)
      return `${name}[]`;
    let output = "";
    for (let i3 = 0; i3 < array2.length; i3++) {
      let string = `${options.stylize(truncate(array2[i3], options.truncate), "number")}${i3 === array2.length - 1 ? "" : ", "}`;
      if (options.truncate -= string.length, array2[i3] !== array2.length && options.truncate <= 3) {
        output += `${truncator}(${array2.length - array2[i3] + 1})`;
        break;
      }
      output += string;
    }
    let propertyContents = "";
    return nonIndexProperties.length && (propertyContents = inspectList(nonIndexProperties.map((key) => [key, array2[key]]), options, inspectProperty)), `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ""} ]`;
  }
  function inspectDate(dateObject, options) {
    let stringRepresentation = dateObject.toJSON();
    if (stringRepresentation === null)
      return "Invalid Date";
    let split = stringRepresentation.split("T"), date = split[0];
    return options.stylize(`${date}T${truncate(split[1], options.truncate - date.length - 1)}`, "date");
  }
  function inspectFunction(func, options) {
    let functionType = func[Symbol.toStringTag] || "Function", name = func.name;
    return name ? options.stylize(`[${functionType} ${truncate(name, options.truncate - 11)}]`, "special") : options.stylize(`[${functionType}]`, "special");
  }
  function inspectMapEntry([key, value2], options) {
    return options.truncate -= 4, key = options.inspect(key, options), options.truncate -= key.length, value2 = options.inspect(value2, options), `${key} => ${value2}`;
  }
  function mapToEntries(map) {
    let entries = [];
    return map.forEach((value2, key) => {
      entries.push([key, value2]);
    }), entries;
  }
  function inspectMap(map, options) {
    return map.size === 0 ? "Map{}" : (options.truncate -= 7, `Map{ ${inspectList(mapToEntries(map), options, inspectMapEntry)} }`);
  }
  var isNaN2 = Number.isNaN || ((i3) => i3 !== i3);
  function inspectNumber(number, options) {
    return isNaN2(number) ? options.stylize("NaN", "number") : number === 1 / 0 ? options.stylize("Infinity", "number") : number === -1 / 0 ? options.stylize("-Infinity", "number") : number === 0 ? options.stylize(1 / number === 1 / 0 ? "+0" : "-0", "number") : options.stylize(truncate(String(number), options.truncate), "number");
  }
  function inspectBigInt(number, options) {
    let nums = truncate(number.toString(), options.truncate - 1);
    return nums !== truncator && (nums += "n"), options.stylize(nums, "bigint");
  }
  function inspectRegExp(value2, options) {
    let flags = value2.toString().split("/")[2], sourceLength = options.truncate - (2 + flags.length), source = value2.source;
    return options.stylize(`/${truncate(source, sourceLength)}/${flags}`, "regexp");
  }
  function arrayFromSet(set) {
    let values = [];
    return set.forEach((value2) => {
      values.push(value2);
    }), values;
  }
  function inspectSet(set, options) {
    return set.size === 0 ? "Set{}" : (options.truncate -= 7, `Set{ ${inspectList(arrayFromSet(set), options)} }`);
  }
  var stringEscapeChars = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), escapeCharacters = {
    "\b": "\\b",
    "	": "\\t",
    "\n": "\\n",
    "\f": "\\f",
    "\r": "\\r",
    "'": "\\'",
    "\\": "\\\\"
  }, hex = 16, unicodeLength = 4;
  function escape(char) {
    return escapeCharacters[char] || `\\u${`0000${char.charCodeAt(0).toString(hex)}`.slice(-unicodeLength)}`;
  }
  function inspectString(string, options) {
    return stringEscapeChars.test(string) && (string = string.replace(stringEscapeChars, escape)), options.stylize(`'${truncate(string, options.truncate - 2)}'`, "string");
  }
  function inspectSymbol(value2) {
    return "description" in Symbol.prototype ? value2.description ? `Symbol(${value2.description})` : "Symbol()" : value2.toString();
  }
  var getPromiseValue = () => "Promise{\u2026}";
  try {
    let { getPromiseDetails, kPending, kRejected } = process.binding("util");
    Array.isArray(getPromiseDetails(Promise.resolve())) && (getPromiseValue = (value2, options) => {
      let [state3, innerValue] = getPromiseDetails(value2);
      return state3 === kPending ? "Promise{<pending>}" : `Promise${state3 === kRejected ? "!" : ""}{${options.inspect(innerValue, options)}}`;
    });
  } catch {
  }
  var promise_default = getPromiseValue;
  function inspectObject(object2, options) {
    let properties = Object.getOwnPropertyNames(object2), symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object2) : [];
    if (properties.length === 0 && symbols.length === 0)
      return "{}";
    if (options.truncate -= 4, options.seen = options.seen || [], options.seen.includes(object2))
      return "[Circular]";
    options.seen.push(object2);
    let propertyContents = inspectList(properties.map((key) => [key, object2[key]]), options, inspectProperty), symbolContents = inspectList(symbols.map((key) => [key, object2[key]]), options, inspectProperty);
    options.seen.pop();
    let sep = "";
    return propertyContents && symbolContents && (sep = ", "), `{ ${propertyContents}${sep}${symbolContents} }`;
  }
  var toStringTag = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : !1;
  function inspectClass(value2, options) {
    let name = "";
    return toStringTag && toStringTag in value2 && (name = value2[toStringTag]), name = name || value2.constructor.name, (!name || name === "_class") && (name = "<Anonymous Class>"), options.truncate -= name.length, `${name}${inspectObject(value2, options)}`;
  }
  function inspectArguments(args, options) {
    return args.length === 0 ? "Arguments[]" : (options.truncate -= 13, `Arguments[ ${inspectList(args, options)} ]`);
  }
  var errorKeys = [
    "stack",
    "line",
    "column",
    "name",
    "message",
    "fileName",
    "lineNumber",
    "columnNumber",
    "number",
    "description",
    "cause"
  ];
  function inspectObject2(error, options) {
    let properties = Object.getOwnPropertyNames(error).filter((key) => errorKeys.indexOf(key) === -1), name = error.name;
    options.truncate -= name.length;
    let message = "";
    if (typeof error.message == "string" ? message = truncate(error.message, options.truncate) : properties.unshift("message"), message = message ? `: ${message}` : "", options.truncate -= message.length + 5, options.seen = options.seen || [], options.seen.includes(error))
      return "[Circular]";
    options.seen.push(error);
    let propertyContents = inspectList(properties.map((key) => [key, error[key]]), options, inspectProperty);
    return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : ""}`;
  }
  function inspectAttribute([key, value2], options) {
    return options.truncate -= 3, value2 ? `${options.stylize(String(key), "yellow")}=${options.stylize(`"${value2}"`, "string")}` : `${options.stylize(String(key), "yellow")}`;
  }
  function inspectNodeCollection(collection, options) {
    return inspectList(collection, options, inspectNode, `
`);
  }
  function inspectNode(node, options) {
    switch (node.nodeType) {
      case 1:
        return inspectHTML(node, options);
      case 3:
        return options.inspect(node.data, options);
      default:
        return options.inspect(node, options);
    }
  }
  function inspectHTML(element, options) {
    let properties = element.getAttributeNames(), name = element.tagName.toLowerCase(), head = options.stylize(`<${name}`, "special"), headClose = options.stylize(">", "special"), tail = options.stylize(`</${name}>`, "special");
    options.truncate -= name.length * 2 + 5;
    let propertyContents = "";
    properties.length > 0 && (propertyContents += " ", propertyContents += inspectList(properties.map((key) => [key, element.getAttribute(key)]), options, inspectAttribute, " ")), options.truncate -= propertyContents.length;
    let truncate2 = options.truncate, children = inspectNodeCollection(element.children, options);
    return children && children.length > truncate2 && (children = `${truncator}(${element.children.length})`), `${head}${propertyContents}${headClose}${children}${tail}`;
  }
  var symbolsSupported = typeof Symbol == "function" && typeof Symbol.for == "function", chaiInspect = symbolsSupported ? /* @__PURE__ */ Symbol.for("chai/inspect") : "@@chai/inspect", nodeInspect = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom"), constructorMap = /* @__PURE__ */ new WeakMap(), stringTagMap = {}, baseTypesMap = {
    undefined: (value2, options) => options.stylize("undefined", "undefined"),
    null: (value2, options) => options.stylize("null", "null"),
    boolean: (value2, options) => options.stylize(String(value2), "boolean"),
    Boolean: (value2, options) => options.stylize(String(value2), "boolean"),
    number: inspectNumber,
    Number: inspectNumber,
    bigint: inspectBigInt,
    BigInt: inspectBigInt,
    string: inspectString,
    String: inspectString,
    function: inspectFunction,
    Function: inspectFunction,
    symbol: inspectSymbol,
    // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
    Symbol: inspectSymbol,
    Array: inspectArray,
    Date: inspectDate,
    Map: inspectMap,
    Set: inspectSet,
    RegExp: inspectRegExp,
    Promise: promise_default,
    // WeakSet, WeakMap are totally opaque to us
    WeakSet: (value2, options) => options.stylize("WeakSet{\u2026}", "special"),
    WeakMap: (value2, options) => options.stylize("WeakMap{\u2026}", "special"),
    Arguments: inspectArguments,
    Int8Array: inspectTypedArray,
    Uint8Array: inspectTypedArray,
    Uint8ClampedArray: inspectTypedArray,
    Int16Array: inspectTypedArray,
    Uint16Array: inspectTypedArray,
    Int32Array: inspectTypedArray,
    Uint32Array: inspectTypedArray,
    Float32Array: inspectTypedArray,
    Float64Array: inspectTypedArray,
    Generator: () => "",
    DataView: () => "",
    ArrayBuffer: () => "",
    Error: inspectObject2,
    HTMLCollection: inspectNodeCollection,
    NodeList: inspectNodeCollection
  }, inspectCustom = (value2, options, type) => chaiInspect in value2 && typeof value2[chaiInspect] == "function" ? value2[chaiInspect](options) : nodeInspect in value2 && typeof value2[nodeInspect] == "function" ? value2[nodeInspect](options.depth, options) : "inspect" in value2 && typeof value2.inspect == "function" ? value2.inspect(options.depth, options) : "constructor" in value2 && constructorMap.has(value2.constructor) ? constructorMap.get(value2.constructor)(value2, options) : stringTagMap[type] ? stringTagMap[type](value2, options) : "", toString2 = Object.prototype.toString;
  function inspect(value2, opts = {}) {
    let options = normaliseOptions(opts, inspect), { customInspect } = options, type = value2 === null ? "null" : typeof value2;
    if (type === "object" && (type = toString2.call(value2).slice(8, -1)), type in baseTypesMap)
      return baseTypesMap[type](value2, options);
    if (customInspect && value2) {
      let output = inspectCustom(value2, options, type);
      if (output)
        return typeof output == "string" ? output : inspect(output, options);
    }
    let proto = value2 ? Object.getPrototypeOf(value2) : !1;
    return proto === Object.prototype || proto === null ? inspectObject(value2, options) : value2 && typeof HTMLElement == "function" && value2 instanceof HTMLElement ? inspectHTML(value2, options) : "constructor" in value2 ? value2.constructor !== Object ? inspectClass(value2, options) : inspectObject(value2, options) : value2 === Object(value2) ? inspectObject(value2, options) : options.stylize(String(value2), type);
  }
  var { AsymmetricMatcher, DOMCollection, DOMElement, Immutable, ReactElement, ReactTestComponent } = plugins, PLUGINS = [
    ReactTestComponent,
    ReactElement,
    DOMElement,
    DOMCollection,
    Immutable,
    AsymmetricMatcher
  ];
  function stringify2(object2, maxDepth = 10, { maxLength, ...options } = {}) {
    let MAX_LENGTH = maxLength ?? 1e4, result;
    try {
      result = format2(object2, {
        maxDepth,
        escapeString: !1,
        plugins: PLUGINS,
        ...options
      });
    } catch {
      result = format2(object2, {
        callToJSON: !1,
        maxDepth,
        escapeString: !1,
        plugins: PLUGINS,
        ...options
      });
    }
    return result.length >= MAX_LENGTH && maxDepth > 1 ? stringify2(object2, Math.floor(Math.min(maxDepth, Number.MAX_SAFE_INTEGER) / 2), {
      maxLength,
      ...options
    }) : result;
  }
  var formatRegExp = /%[sdjifoOc%]/g;
  function format22(...args) {
    if (typeof args[0] != "string") {
      let objects = [];
      for (let i22 = 0; i22 < args.length; i22++)
        objects.push(inspect2(args[i22], {
          depth: 0,
          colors: !1
        }));
      return objects.join(" ");
    }
    let len = args.length, i3 = 1, template = args[0], str = String(template).replace(formatRegExp, (x3) => {
      if (x3 === "%%")
        return "%";
      if (i3 >= len)
        return x3;
      switch (x3) {
        case "%s": {
          let value2 = args[i3++];
          return typeof value2 == "bigint" ? `${value2.toString()}n` : typeof value2 == "number" && value2 === 0 && 1 / value2 < 0 ? "-0" : typeof value2 == "object" && value2 !== null ? typeof value2.toString == "function" && value2.toString !== Object.prototype.toString ? value2.toString() : inspect2(value2, {
            depth: 0,
            colors: !1
          }) : String(value2);
        }
        case "%d": {
          let value2 = args[i3++];
          return typeof value2 == "bigint" ? `${value2.toString()}n` : Number(value2).toString();
        }
        case "%i": {
          let value2 = args[i3++];
          return typeof value2 == "bigint" ? `${value2.toString()}n` : Number.parseInt(String(value2)).toString();
        }
        case "%f":
          return Number.parseFloat(String(args[i3++])).toString();
        case "%o":
          return inspect2(args[i3++], {
            showHidden: !0,
            showProxy: !0
          });
        case "%O":
          return inspect2(args[i3++]);
        case "%c":
          return i3++, "";
        case "%j":
          try {
            return JSON.stringify(args[i3++]);
          } catch (err) {
            let m22 = err.message;
            if (m22.includes("circular structure") || m22.includes("cyclic structures") || m22.includes("cyclic object"))
              return "[Circular]";
            throw err;
          }
        default:
          return x3;
      }
    });
    for (let x3 = args[i3]; i3 < len; x3 = args[++i3])
      x3 === null || typeof x3 != "object" ? str += ` ${x3}` : str += ` ${inspect2(x3)}`;
    return str;
  }
  function inspect2(obj, options = {}) {
    return options.truncate === 0 && (options.truncate = Number.POSITIVE_INFINITY), inspect(obj, options);
  }
  function getDefaultExportFromCjs2(x3) {
    return x3 && x3.__esModule && Object.prototype.hasOwnProperty.call(x3, "default") ? x3.default : x3;
  }
  function isFinalObj(obj) {
    return obj === Object.prototype || obj === Function.prototype || obj === RegExp.prototype;
  }
  function getType2(value2) {
    return Object.prototype.toString.apply(value2).slice(8, -1);
  }
  function collectOwnProperties(obj, collector) {
    let collect = typeof collector == "function" ? collector : (key) => collector.add(key);
    Object.getOwnPropertyNames(obj).forEach(collect), Object.getOwnPropertySymbols(obj).forEach(collect);
  }
  function getOwnProperties(obj) {
    let ownProps = /* @__PURE__ */ new Set();
    return isFinalObj(obj) ? [] : (collectOwnProperties(obj, ownProps), Array.from(ownProps));
  }
  var defaultCloneOptions = { forceWritable: !1 };
  function deepClone(val, options = defaultCloneOptions) {
    return clone(val, /* @__PURE__ */ new WeakMap(), options);
  }
  function clone(val, seen, options = defaultCloneOptions) {
    let k3, out;
    if (seen.has(val))
      return seen.get(val);
    if (Array.isArray(val)) {
      for (out = Array.from({ length: k3 = val.length }), seen.set(val, out); k3--; )
        out[k3] = clone(val[k3], seen, options);
      return out;
    }
    if (Object.prototype.toString.call(val) === "[object Object]") {
      out = Object.create(Object.getPrototypeOf(val)), seen.set(val, out);
      let props = getOwnProperties(val);
      for (let k22 of props) {
        let descriptor = Object.getOwnPropertyDescriptor(val, k22);
        if (!descriptor)
          continue;
        let cloned = clone(val[k22], seen, options);
        options.forceWritable ? Object.defineProperty(out, k22, {
          enumerable: descriptor.enumerable,
          configurable: !0,
          writable: !0,
          value: cloned
        }) : "get" in descriptor ? Object.defineProperty(out, k22, {
          ...descriptor,
          get() {
            return cloned;
          }
        }) : Object.defineProperty(out, k22, {
          ...descriptor,
          value: cloned
        });
      }
      return out;
    }
    return val;
  }
  var DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0, Diff = class {
    0;
    1;
    constructor(op, text) {
      this[0] = op, this[1] = text;
    }
  };
  function diff_commonPrefix(text1, text2) {
    if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0))
      return 0;
    let pointermin = 0, pointermax = Math.min(text1.length, text2.length), pointermid = pointermax, pointerstart = 0;
    for (; pointermin < pointermid; )
      text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid) ? (pointermin = pointermid, pointerstart = pointermin) : pointermax = pointermid, pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    return pointermid;
  }
  function diff_commonSuffix(text1, text2) {
    if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1))
      return 0;
    let pointermin = 0, pointermax = Math.min(text1.length, text2.length), pointermid = pointermax, pointerend = 0;
    for (; pointermin < pointermid; )
      text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend) ? (pointermin = pointermid, pointerend = pointermin) : pointermax = pointermid, pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    return pointermid;
  }
  function diff_commonOverlap_(text1, text2) {
    let text1_length = text1.length, text2_length = text2.length;
    if (text1_length === 0 || text2_length === 0)
      return 0;
    text1_length > text2_length ? text1 = text1.substring(text1_length - text2_length) : text1_length < text2_length && (text2 = text2.substring(0, text1_length));
    let text_length = Math.min(text1_length, text2_length);
    if (text1 === text2)
      return text_length;
    let best = 0, length = 1;
    for (; ; ) {
      let pattern = text1.substring(text_length - length), found = text2.indexOf(pattern);
      if (found === -1)
        return best;
      length += found, (found === 0 || text1.substring(text_length - length) === text2.substring(0, length)) && (best = length, length++);
    }
  }
  function diff_cleanupSemantic(diffs) {
    let changes = !1, equalities = [], equalitiesLength = 0, lastEquality = null, pointer2 = 0, length_insertions1 = 0, length_deletions1 = 0, length_insertions2 = 0, length_deletions2 = 0;
    for (; pointer2 < diffs.length; )
      diffs[pointer2][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer2, length_insertions1 = length_insertions2, length_deletions1 = length_deletions2, length_insertions2 = 0, length_deletions2 = 0, lastEquality = diffs[pointer2][1]) : (diffs[pointer2][0] === DIFF_INSERT ? length_insertions2 += diffs[pointer2][1].length : length_deletions2 += diffs[pointer2][1].length, lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, new Diff(DIFF_DELETE, lastEquality)), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer2 = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, length_insertions1 = 0, length_deletions1 = 0, length_insertions2 = 0, length_deletions2 = 0, lastEquality = null, changes = !0)), pointer2++;
    for (changes && diff_cleanupMerge(diffs), diff_cleanupSemanticLossless(diffs), pointer2 = 1; pointer2 < diffs.length; ) {
      if (diffs[pointer2 - 1][0] === DIFF_DELETE && diffs[pointer2][0] === DIFF_INSERT) {
        let deletion = diffs[pointer2 - 1][1], insertion = diffs[pointer2][1], overlap_length1 = diff_commonOverlap_(deletion, insertion), overlap_length2 = diff_commonOverlap_(insertion, deletion);
        overlap_length1 >= overlap_length2 ? (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) && (diffs.splice(pointer2, 0, new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1))), diffs[pointer2 - 1][1] = deletion.substring(0, deletion.length - overlap_length1), diffs[pointer2 + 1][1] = insertion.substring(overlap_length1), pointer2++) : (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) && (diffs.splice(pointer2, 0, new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2))), diffs[pointer2 - 1][0] = DIFF_INSERT, diffs[pointer2 - 1][1] = insertion.substring(0, insertion.length - overlap_length2), diffs[pointer2 + 1][0] = DIFF_DELETE, diffs[pointer2 + 1][1] = deletion.substring(overlap_length2), pointer2++), pointer2++;
      }
      pointer2++;
    }
  }
  var nonAlphaNumericRegex_ = /[^a-z0-9]/i, whitespaceRegex_ = /\s/, linebreakRegex_ = /[\r\n]/, blanklineEndRegex_ = /\n\r?\n$/, blanklineStartRegex_ = /^\r?\n\r?\n/;
  function diff_cleanupSemanticLossless(diffs) {
    let pointer2 = 1;
    for (; pointer2 < diffs.length - 1; ) {
      if (diffs[pointer2 - 1][0] === DIFF_EQUAL && diffs[pointer2 + 1][0] === DIFF_EQUAL) {
        let equality1 = diffs[pointer2 - 1][1], edit = diffs[pointer2][1], equality2 = diffs[pointer2 + 1][1], commonOffset = diff_commonSuffix(equality1, edit);
        if (commonOffset) {
          let commonString = edit.substring(edit.length - commonOffset);
          equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;
        }
        let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
        for (; edit.charAt(0) === equality2.charAt(0); ) {
          equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);
          let score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
          score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);
        }
        diffs[pointer2 - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer2 - 1][1] = bestEquality1 : (diffs.splice(pointer2 - 1, 1), pointer2--), diffs[pointer2][1] = bestEdit, bestEquality2 ? diffs[pointer2 + 1][1] = bestEquality2 : (diffs.splice(pointer2 + 1, 1), pointer2--));
      }
      pointer2++;
    }
  }
  function diff_cleanupMerge(diffs) {
    diffs.push(new Diff(DIFF_EQUAL, ""));
    let pointer2 = 0, count_delete = 0, count_insert = 0, text_delete = "", text_insert = "", commonlength;
    for (; pointer2 < diffs.length; )
      switch (diffs[pointer2][0]) {
        case DIFF_INSERT:
          count_insert++, text_insert += diffs[pointer2][1], pointer2++;
          break;
        case DIFF_DELETE:
          count_delete++, text_delete += diffs[pointer2][1], pointer2++;
          break;
        case DIFF_EQUAL:
          count_delete + count_insert > 1 ? (count_delete !== 0 && count_insert !== 0 && (commonlength = diff_commonPrefix(text_insert, text_delete), commonlength !== 0 && (pointer2 - count_delete - count_insert > 0 && diffs[pointer2 - count_delete - count_insert - 1][0] === DIFF_EQUAL ? diffs[pointer2 - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength) : (diffs.splice(0, 0, new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength))), pointer2++), text_insert = text_insert.substring(commonlength), text_delete = text_delete.substring(commonlength)), commonlength = diff_commonSuffix(text_insert, text_delete), commonlength !== 0 && (diffs[pointer2][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer2][1], text_insert = text_insert.substring(0, text_insert.length - commonlength), text_delete = text_delete.substring(0, text_delete.length - commonlength))), pointer2 -= count_delete + count_insert, diffs.splice(pointer2, count_delete + count_insert), text_delete.length && (diffs.splice(pointer2, 0, new Diff(DIFF_DELETE, text_delete)), pointer2++), text_insert.length && (diffs.splice(pointer2, 0, new Diff(DIFF_INSERT, text_insert)), pointer2++), pointer2++) : pointer2 !== 0 && diffs[pointer2 - 1][0] === DIFF_EQUAL ? (diffs[pointer2 - 1][1] += diffs[pointer2][1], diffs.splice(pointer2, 1)) : pointer2++, count_insert = 0, count_delete = 0, text_delete = "", text_insert = "";
          break;
      }
    diffs[diffs.length - 1][1] === "" && diffs.pop();
    let changes = !1;
    for (pointer2 = 1; pointer2 < diffs.length - 1; )
      diffs[pointer2 - 1][0] === DIFF_EQUAL && diffs[pointer2 + 1][0] === DIFF_EQUAL && (diffs[pointer2][1].substring(diffs[pointer2][1].length - diffs[pointer2 - 1][1].length) === diffs[pointer2 - 1][1] ? (diffs[pointer2][1] = diffs[pointer2 - 1][1] + diffs[pointer2][1].substring(0, diffs[pointer2][1].length - diffs[pointer2 - 1][1].length), diffs[pointer2 + 1][1] = diffs[pointer2 - 1][1] + diffs[pointer2 + 1][1], diffs.splice(pointer2 - 1, 1), changes = !0) : diffs[pointer2][1].substring(0, diffs[pointer2 + 1][1].length) === diffs[pointer2 + 1][1] && (diffs[pointer2 - 1][1] += diffs[pointer2 + 1][1], diffs[pointer2][1] = diffs[pointer2][1].substring(diffs[pointer2 + 1][1].length) + diffs[pointer2 + 1][1], diffs.splice(pointer2 + 1, 1), changes = !0)), pointer2++;
    changes && diff_cleanupMerge(diffs);
  }
  function diff_cleanupSemanticScore_(one, two) {
    if (!one || !two)
      return 6;
    let char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_), lineBreak1 = whitespace1 && char1.match(linebreakRegex_), lineBreak2 = whitespace2 && char2.match(linebreakRegex_), blankLine1 = lineBreak1 && one.match(blanklineEndRegex_), blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
    return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;
  }
  var NO_DIFF_MESSAGE = "Compared values have no visual difference.", SIMILAR_MESSAGE = "Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.", build = {}, hasRequiredBuild;
  function requireBuild() {
    if (hasRequiredBuild) return build;
    hasRequiredBuild = 1, Object.defineProperty(build, "__esModule", {
      value: !0
    }), build.default = diffSequence;
    let pkg = "diff-sequences", NOT_YET_SET = 0, countCommonItemsF = (aIndex, aEnd, bIndex, bEnd, isCommon) => {
      let nCommon = 0;
      for (; aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex); )
        aIndex += 1, bIndex += 1, nCommon += 1;
      return nCommon;
    }, countCommonItemsR = (aStart, aIndex, bStart, bIndex, isCommon) => {
      let nCommon = 0;
      for (; aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex); )
        aIndex -= 1, bIndex -= 1, nCommon += 1;
      return nCommon;
    }, extendPathsF = (d3, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF) => {
      let iF = 0, kF = -d3, aFirst = aIndexesF[iF], aIndexPrev1 = aFirst;
      aIndexesF[iF] += countCommonItemsF(
        aFirst + 1,
        aEnd,
        bF + aFirst - kF + 1,
        bEnd,
        isCommon
      );
      let nF = d3 < iMaxF ? d3 : iMaxF;
      for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {
        if (iF !== d3 && aIndexPrev1 < aIndexesF[iF])
          aFirst = aIndexesF[iF];
        else if (aFirst = aIndexPrev1 + 1, aEnd <= aFirst)
          return iF - 1;
        aIndexPrev1 = aIndexesF[iF], aIndexesF[iF] = aFirst + countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
      }
      return iMaxF;
    }, extendPathsR = (d3, aStart, bStart, bR, isCommon, aIndexesR, iMaxR) => {
      let iR = 0, kR = d3, aFirst = aIndexesR[iR], aIndexPrev1 = aFirst;
      aIndexesR[iR] -= countCommonItemsR(
        aStart,
        aFirst - 1,
        bStart,
        bR + aFirst - kR - 1,
        isCommon
      );
      let nR = d3 < iMaxR ? d3 : iMaxR;
      for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {
        if (iR !== d3 && aIndexesR[iR] < aIndexPrev1)
          aFirst = aIndexesR[iR];
        else if (aFirst = aIndexPrev1 - 1, aFirst < aStart)
          return iR - 1;
        aIndexPrev1 = aIndexesR[iR], aIndexesR[iR] = aFirst - countCommonItemsR(
          aStart,
          aFirst - 1,
          bStart,
          bR + aFirst - kR - 1,
          isCommon
        );
      }
      return iMaxR;
    }, extendOverlappablePathsF = (d3, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
      let bF = bStart - aStart, aLength = aEnd - aStart, baDeltaLength = bEnd - bStart - aLength, kMinOverlapF = -baDeltaLength - (d3 - 1), kMaxOverlapF = -baDeltaLength + (d3 - 1), aIndexPrev1 = NOT_YET_SET, nF = d3 < iMaxF ? d3 : iMaxF;
      for (let iF = 0, kF = -d3; iF <= nF; iF += 1, kF += 2) {
        let insert = iF === 0 || iF !== d3 && aIndexPrev1 < aIndexesF[iF], aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1, aFirst = insert ? aLastPrev : aLastPrev + 1, bFirst = bF + aFirst - kF, nCommonF = countCommonItemsF(
          aFirst + 1,
          aEnd,
          bFirst + 1,
          bEnd,
          isCommon
        ), aLast = aFirst + nCommonF;
        if (aIndexPrev1 = aIndexesF[iF], aIndexesF[iF] = aLast, kMinOverlapF <= kF && kF <= kMaxOverlapF) {
          let iR = (d3 - 1 - (kF + baDeltaLength)) / 2;
          if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {
            let bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1), nCommonR = countCommonItemsR(
              aStart,
              aLastPrev,
              bStart,
              bLastPrev,
              isCommon
            ), aIndexPrevFirst = aLastPrev - nCommonR, bIndexPrevFirst = bLastPrev - nCommonR, aEndPreceding = aIndexPrevFirst + 1, bEndPreceding = bIndexPrevFirst + 1;
            division.nChangePreceding = d3 - 1, d3 - 1 === aEndPreceding + bEndPreceding - aStart - bStart ? (division.aEndPreceding = aStart, division.bEndPreceding = bStart) : (division.aEndPreceding = aEndPreceding, division.bEndPreceding = bEndPreceding), division.nCommonPreceding = nCommonR, nCommonR !== 0 && (division.aCommonPreceding = aEndPreceding, division.bCommonPreceding = bEndPreceding), division.nCommonFollowing = nCommonF, nCommonF !== 0 && (division.aCommonFollowing = aFirst + 1, division.bCommonFollowing = bFirst + 1);
            let aStartFollowing = aLast + 1, bStartFollowing = bFirst + nCommonF + 1;
            return division.nChangeFollowing = d3 - 1, d3 - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing ? (division.aStartFollowing = aEnd, division.bStartFollowing = bEnd) : (division.aStartFollowing = aStartFollowing, division.bStartFollowing = bStartFollowing), !0;
          }
        }
      }
      return !1;
    }, extendOverlappablePathsR = (d3, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
      let bR = bEnd - aEnd, aLength = aEnd - aStart, baDeltaLength = bEnd - bStart - aLength, kMinOverlapR = baDeltaLength - d3, kMaxOverlapR = baDeltaLength + d3, aIndexPrev1 = NOT_YET_SET, nR = d3 < iMaxR ? d3 : iMaxR;
      for (let iR = 0, kR = d3; iR <= nR; iR += 1, kR -= 2) {
        let insert = iR === 0 || iR !== d3 && aIndexesR[iR] < aIndexPrev1, aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1, aFirst = insert ? aLastPrev : aLastPrev - 1, bFirst = bR + aFirst - kR, nCommonR = countCommonItemsR(
          aStart,
          aFirst - 1,
          bStart,
          bFirst - 1,
          isCommon
        ), aLast = aFirst - nCommonR;
        if (aIndexPrev1 = aIndexesR[iR], aIndexesR[iR] = aLast, kMinOverlapR <= kR && kR <= kMaxOverlapR) {
          let iF = (d3 + (kR - baDeltaLength)) / 2;
          if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {
            let bLast = bFirst - nCommonR;
            if (division.nChangePreceding = d3, d3 === aLast + bLast - aStart - bStart ? (division.aEndPreceding = aStart, division.bEndPreceding = bStart) : (division.aEndPreceding = aLast, division.bEndPreceding = bLast), division.nCommonPreceding = nCommonR, nCommonR !== 0 && (division.aCommonPreceding = aLast, division.bCommonPreceding = bLast), division.nChangeFollowing = d3 - 1, d3 === 1)
              division.nCommonFollowing = 0, division.aStartFollowing = aEnd, division.bStartFollowing = bEnd;
            else {
              let bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1), nCommonF = countCommonItemsF(
                aLastPrev,
                aEnd,
                bLastPrev,
                bEnd,
                isCommon
              );
              division.nCommonFollowing = nCommonF, nCommonF !== 0 && (division.aCommonFollowing = aLastPrev, division.bCommonFollowing = bLastPrev);
              let aStartFollowing = aLastPrev + nCommonF, bStartFollowing = bLastPrev + nCommonF;
              d3 - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing ? (division.aStartFollowing = aEnd, division.bStartFollowing = bEnd) : (division.aStartFollowing = aStartFollowing, division.bStartFollowing = bStartFollowing);
            }
            return !0;
          }
        }
      }
      return !1;
    }, divide = (nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division) => {
      let bF = bStart - aStart, bR = bEnd - aEnd, aLength = aEnd - aStart, bLength = bEnd - bStart, baDeltaLength = bLength - aLength, iMaxF = aLength, iMaxR = aLength;
      if (aIndexesF[0] = aStart - 1, aIndexesR[0] = aEnd, baDeltaLength % 2 === 0) {
        let dMin = (nChange || baDeltaLength) / 2, dMax = (aLength + bLength) / 2;
        for (let d3 = 1; d3 <= dMax; d3 += 1)
          if (iMaxF = extendPathsF(d3, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF), d3 < dMin)
            iMaxR = extendPathsR(d3, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);
          else if (
            // If a reverse path overlaps a forward path in the same diagonal,
            // return a division of the index intervals at the middle change.
            extendOverlappablePathsR(
              d3,
              aStart,
              aEnd,
              bStart,
              bEnd,
              isCommon,
              aIndexesF,
              iMaxF,
              aIndexesR,
              iMaxR,
              division
            )
          )
            return;
      } else {
        let dMin = ((nChange || baDeltaLength) + 1) / 2, dMax = (aLength + bLength + 1) / 2, d3 = 1;
        for (iMaxF = extendPathsF(d3, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF), d3 += 1; d3 <= dMax; d3 += 1)
          if (iMaxR = extendPathsR(
            d3 - 1,
            aStart,
            bStart,
            bR,
            isCommon,
            aIndexesR,
            iMaxR
          ), d3 < dMin)
            iMaxF = extendPathsF(d3, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
          else if (
            // If a forward path overlaps a reverse path in the same diagonal,
            // return a division of the index intervals at the middle change.
            extendOverlappablePathsF(
              d3,
              aStart,
              aEnd,
              bStart,
              bEnd,
              isCommon,
              aIndexesF,
              iMaxF,
              aIndexesR,
              iMaxR,
              division
            )
          )
            return;
      }
      throw new Error(
        `${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`
      );
    }, findSubsequences = (nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division) => {
      if (bEnd - bStart < aEnd - aStart) {
        if (transposed = !transposed, transposed && callbacks.length === 1) {
          let { foundSubsequence: foundSubsequence2, isCommon: isCommon2 } = callbacks[0];
          callbacks[1] = {
            foundSubsequence: (nCommon, bCommon, aCommon) => {
              foundSubsequence2(nCommon, aCommon, bCommon);
            },
            isCommon: (bIndex, aIndex) => isCommon2(aIndex, bIndex)
          };
        }
        let tStart = aStart, tEnd = aEnd;
        aStart = bStart, aEnd = bEnd, bStart = tStart, bEnd = tEnd;
      }
      let { foundSubsequence, isCommon } = callbacks[transposed ? 1 : 0];
      divide(
        nChange,
        aStart,
        aEnd,
        bStart,
        bEnd,
        isCommon,
        aIndexesF,
        aIndexesR,
        division
      );
      let {
        nChangePreceding,
        aEndPreceding,
        bEndPreceding,
        nCommonPreceding,
        aCommonPreceding,
        bCommonPreceding,
        nCommonFollowing,
        aCommonFollowing,
        bCommonFollowing,
        nChangeFollowing,
        aStartFollowing,
        bStartFollowing
      } = division;
      aStart < aEndPreceding && bStart < bEndPreceding && findSubsequences(
        nChangePreceding,
        aStart,
        aEndPreceding,
        bStart,
        bEndPreceding,
        transposed,
        callbacks,
        aIndexesF,
        aIndexesR,
        division
      ), nCommonPreceding !== 0 && foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding), nCommonFollowing !== 0 && foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing), aStartFollowing < aEnd && bStartFollowing < bEnd && findSubsequences(
        nChangeFollowing,
        aStartFollowing,
        aEnd,
        bStartFollowing,
        bEnd,
        transposed,
        callbacks,
        aIndexesF,
        aIndexesR,
        division
      );
    }, validateLength = (name, arg) => {
      if (typeof arg != "number")
        throw new TypeError(`${pkg}: ${name} typeof ${typeof arg} is not a number`);
      if (!Number.isSafeInteger(arg))
        throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);
      if (arg < 0)
        throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);
    }, validateCallback = (name, arg) => {
      let type = typeof arg;
      if (type !== "function")
        throw new TypeError(`${pkg}: ${name} typeof ${type} is not a function`);
    };
    function diffSequence(aLength, bLength, isCommon, foundSubsequence) {
      validateLength("aLength", aLength), validateLength("bLength", bLength), validateCallback("isCommon", isCommon), validateCallback("foundSubsequence", foundSubsequence);
      let nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);
      if (nCommonF !== 0 && foundSubsequence(nCommonF, 0, 0), aLength !== nCommonF || bLength !== nCommonF) {
        let aStart = nCommonF, bStart = nCommonF, nCommonR = countCommonItemsR(
          aStart,
          aLength - 1,
          bStart,
          bLength - 1,
          isCommon
        ), aEnd = aLength - nCommonR, bEnd = bLength - nCommonR, nCommonFR = nCommonF + nCommonR;
        aLength !== nCommonFR && bLength !== nCommonFR && findSubsequences(
          0,
          aStart,
          aEnd,
          bStart,
          bEnd,
          !1,
          [
            {
              foundSubsequence,
              isCommon
            }
          ],
          [NOT_YET_SET],
          [NOT_YET_SET],
          {
            aCommonFollowing: NOT_YET_SET,
            aCommonPreceding: NOT_YET_SET,
            aEndPreceding: NOT_YET_SET,
            aStartFollowing: NOT_YET_SET,
            bCommonFollowing: NOT_YET_SET,
            bCommonPreceding: NOT_YET_SET,
            bEndPreceding: NOT_YET_SET,
            bStartFollowing: NOT_YET_SET,
            nChangeFollowing: NOT_YET_SET,
            nChangePreceding: NOT_YET_SET,
            nCommonFollowing: NOT_YET_SET,
            nCommonPreceding: NOT_YET_SET
          }
        ), nCommonR !== 0 && foundSubsequence(nCommonR, aEnd, bEnd);
      }
    }
    return build;
  }
  var buildExports = requireBuild(), diffSequences = getDefaultExportFromCjs2(buildExports);
  function formatTrailingSpaces(line, trailingSpaceFormatter) {
    return line.replace(/\s+$/, (match) => trailingSpaceFormatter(match));
  }
  function printDiffLine(line, isFirstOrLast, color2, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) {
    return line.length !== 0 ? color2(`${indicator} ${formatTrailingSpaces(line, trailingSpaceFormatter)}`) : indicator !== " " ? color2(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color2(`${indicator} ${emptyFirstOrLastLinePlaceholder}`) : "";
  }
  function printDeleteLine(line, isFirstOrLast, { aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
    return printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
  }
  function printInsertLine(line, isFirstOrLast, { bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
    return printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
  }
  function printCommonLine(line, isFirstOrLast, { commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
    return printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
  }
  function createPatchMark(aStart, aEnd, bStart, bEnd, { patchColor }) {
    return patchColor(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`);
  }
  function joinAlignedDiffsNoExpand(diffs, options) {
    let iLength = diffs.length, nContextLines = options.contextLines, nContextLines2 = nContextLines + nContextLines, jLength = iLength, hasExcessAtStartOrEnd = !1, nExcessesBetweenChanges = 0, i3 = 0;
    for (; i3 !== iLength; ) {
      let iStart = i3;
      for (; i3 !== iLength && diffs[i3][0] === DIFF_EQUAL; )
        i3 += 1;
      if (iStart !== i3)
        if (iStart === 0)
          i3 > nContextLines && (jLength -= i3 - nContextLines, hasExcessAtStartOrEnd = !0);
        else if (i3 === iLength) {
          let n2 = i3 - iStart;
          n2 > nContextLines && (jLength -= n2 - nContextLines, hasExcessAtStartOrEnd = !0);
        } else {
          let n2 = i3 - iStart;
          n2 > nContextLines2 && (jLength -= n2 - nContextLines2, nExcessesBetweenChanges += 1);
        }
      for (; i3 !== iLength && diffs[i3][0] !== DIFF_EQUAL; )
        i3 += 1;
    }
    let hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;
    nExcessesBetweenChanges !== 0 ? jLength += nExcessesBetweenChanges + 1 : hasExcessAtStartOrEnd && (jLength += 1);
    let jLast = jLength - 1, lines = [], jPatchMark = 0;
    hasPatch && lines.push("");
    let aStart = 0, bStart = 0, aEnd = 0, bEnd = 0, pushCommonLine = (line) => {
      let j2 = lines.length;
      lines.push(printCommonLine(line, j2 === 0 || j2 === jLast, options)), aEnd += 1, bEnd += 1;
    }, pushDeleteLine = (line) => {
      let j2 = lines.length;
      lines.push(printDeleteLine(line, j2 === 0 || j2 === jLast, options)), aEnd += 1;
    }, pushInsertLine = (line) => {
      let j2 = lines.length;
      lines.push(printInsertLine(line, j2 === 0 || j2 === jLast, options)), bEnd += 1;
    };
    for (i3 = 0; i3 !== iLength; ) {
      let iStart = i3;
      for (; i3 !== iLength && diffs[i3][0] === DIFF_EQUAL; )
        i3 += 1;
      if (iStart !== i3)
        if (iStart === 0) {
          i3 > nContextLines && (iStart = i3 - nContextLines, aStart = iStart, bStart = iStart, aEnd = aStart, bEnd = bStart);
          for (let iCommon = iStart; iCommon !== i3; iCommon += 1)
            pushCommonLine(diffs[iCommon][1]);
        } else if (i3 === iLength) {
          let iEnd = i3 - iStart > nContextLines ? iStart + nContextLines : i3;
          for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1)
            pushCommonLine(diffs[iCommon][1]);
        } else {
          let nCommon = i3 - iStart;
          if (nCommon > nContextLines2) {
            let iEnd = iStart + nContextLines;
            for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1)
              pushCommonLine(diffs[iCommon][1]);
            lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options), jPatchMark = lines.length, lines.push("");
            let nOmit = nCommon - nContextLines2;
            aStart = aEnd + nOmit, bStart = bEnd + nOmit, aEnd = aStart, bEnd = bStart;
            for (let iCommon = i3 - nContextLines; iCommon !== i3; iCommon += 1)
              pushCommonLine(diffs[iCommon][1]);
          } else
            for (let iCommon = iStart; iCommon !== i3; iCommon += 1)
              pushCommonLine(diffs[iCommon][1]);
        }
      for (; i3 !== iLength && diffs[i3][0] === DIFF_DELETE; )
        pushDeleteLine(diffs[i3][1]), i3 += 1;
      for (; i3 !== iLength && diffs[i3][0] === DIFF_INSERT; )
        pushInsertLine(diffs[i3][1]), i3 += 1;
    }
    return hasPatch && (lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options)), lines.join(`
`);
  }
  function joinAlignedDiffsExpand(diffs, options) {
    return diffs.map((diff2, i3, diffs2) => {
      let line = diff2[1], isFirstOrLast = i3 === 0 || i3 === diffs2.length - 1;
      switch (diff2[0]) {
        case DIFF_DELETE:
          return printDeleteLine(line, isFirstOrLast, options);
        case DIFF_INSERT:
          return printInsertLine(line, isFirstOrLast, options);
        default:
          return printCommonLine(line, isFirstOrLast, options);
      }
    }).join(`
`);
  }
  var noColor = (string) => string, DIFF_CONTEXT_DEFAULT = 5, DIFF_TRUNCATE_THRESHOLD_DEFAULT = 0;
  function getDefaultOptions() {
    return {
      aAnnotation: "Expected",
      aColor: s.green,
      aIndicator: "-",
      bAnnotation: "Received",
      bColor: s.red,
      bIndicator: "+",
      changeColor: s.inverse,
      changeLineTrailingSpaceColor: noColor,
      commonColor: s.dim,
      commonIndicator: " ",
      commonLineTrailingSpaceColor: noColor,
      compareKeys: void 0,
      contextLines: DIFF_CONTEXT_DEFAULT,
      emptyFirstOrLastLinePlaceholder: "",
      expand: !1,
      includeChangeCounts: !1,
      omitAnnotationLines: !1,
      patchColor: s.yellow,
      printBasicPrototype: !1,
      truncateThreshold: DIFF_TRUNCATE_THRESHOLD_DEFAULT,
      truncateAnnotation: "... Diff result is truncated",
      truncateAnnotationColor: noColor
    };
  }
  function getCompareKeys(compareKeys) {
    return compareKeys && typeof compareKeys == "function" ? compareKeys : void 0;
  }
  function getContextLines(contextLines) {
    return typeof contextLines == "number" && Number.isSafeInteger(contextLines) && contextLines >= 0 ? contextLines : DIFF_CONTEXT_DEFAULT;
  }
  function normalizeDiffOptions(options = {}) {
    return {
      ...getDefaultOptions(),
      ...options,
      compareKeys: getCompareKeys(options.compareKeys),
      contextLines: getContextLines(options.contextLines)
    };
  }
  function isEmptyString(lines) {
    return lines.length === 1 && lines[0].length === 0;
  }
  function countChanges(diffs) {
    let a22 = 0, b3 = 0;
    return diffs.forEach((diff2) => {
      switch (diff2[0]) {
        case DIFF_DELETE:
          a22 += 1;
          break;
        case DIFF_INSERT:
          b3 += 1;
          break;
      }
    }), {
      a: a22,
      b: b3
    };
  }
  function printAnnotation({ aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator, includeChangeCounts, omitAnnotationLines }, changeCounts) {
    if (omitAnnotationLines)
      return "";
    let aRest = "", bRest = "";
    if (includeChangeCounts) {
      let aCount = String(changeCounts.a), bCount = String(changeCounts.b), baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length, aAnnotationPadding = " ".repeat(Math.max(0, baAnnotationLengthDiff)), bAnnotationPadding = " ".repeat(Math.max(0, -baAnnotationLengthDiff)), baCountLengthDiff = bCount.length - aCount.length, aCountPadding = " ".repeat(Math.max(0, baCountLengthDiff)), bCountPadding = " ".repeat(Math.max(0, -baCountLengthDiff));
      aRest = `${aAnnotationPadding}  ${aIndicator} ${aCountPadding}${aCount}`, bRest = `${bAnnotationPadding}  ${bIndicator} ${bCountPadding}${bCount}`;
    }
    let a22 = `${aIndicator} ${aAnnotation}${aRest}`, b3 = `${bIndicator} ${bAnnotation}${bRest}`;
    return `${aColor(a22)}
${bColor(b3)}

`;
  }
  function printDiffLines(diffs, truncated, options) {
    return printAnnotation(options, countChanges(diffs)) + (options.expand ? joinAlignedDiffsExpand(diffs, options) : joinAlignedDiffsNoExpand(diffs, options)) + (truncated ? options.truncateAnnotationColor(`
${options.truncateAnnotation}`) : "");
  }
  function diffLinesUnified(aLines, bLines, options) {
    let normalizedOptions = normalizeDiffOptions(options), [diffs, truncated] = diffLinesRaw(isEmptyString(aLines) ? [] : aLines, isEmptyString(bLines) ? [] : bLines, normalizedOptions);
    return printDiffLines(diffs, truncated, normalizedOptions);
  }
  function diffLinesUnified2(aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options) {
    if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare) && (aLinesDisplay = [], aLinesCompare = []), isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare) && (bLinesDisplay = [], bLinesCompare = []), aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length)
      return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);
    let [diffs, truncated] = diffLinesRaw(aLinesCompare, bLinesCompare, options), aIndex = 0, bIndex = 0;
    return diffs.forEach((diff2) => {
      switch (diff2[0]) {
        case DIFF_DELETE:
          diff2[1] = aLinesDisplay[aIndex], aIndex += 1;
          break;
        case DIFF_INSERT:
          diff2[1] = bLinesDisplay[bIndex], bIndex += 1;
          break;
        default:
          diff2[1] = bLinesDisplay[bIndex], aIndex += 1, bIndex += 1;
      }
    }), printDiffLines(diffs, truncated, normalizeDiffOptions(options));
  }
  function diffLinesRaw(aLines, bLines, options) {
    let truncate2 = options?.truncateThreshold ?? !1, truncateThreshold = Math.max(Math.floor(options?.truncateThreshold ?? 0), 0), aLength = truncate2 ? Math.min(aLines.length, truncateThreshold) : aLines.length, bLength = truncate2 ? Math.min(bLines.length, truncateThreshold) : bLines.length, truncated = aLength !== aLines.length || bLength !== bLines.length, isCommon = (aIndex2, bIndex2) => aLines[aIndex2] === bLines[bIndex2], diffs = [], aIndex = 0, bIndex = 0;
    for (diffSequences(aLength, bLength, isCommon, (nCommon, aCommon, bCommon) => {
      for (; aIndex !== aCommon; aIndex += 1)
        diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
      for (; bIndex !== bCommon; bIndex += 1)
        diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
      for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1)
        diffs.push(new Diff(DIFF_EQUAL, bLines[bIndex]));
    }); aIndex !== aLength; aIndex += 1)
      diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
    for (; bIndex !== bLength; bIndex += 1)
      diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
    return [diffs, truncated];
  }
  function getType3(value2) {
    if (value2 === void 0)
      return "undefined";
    if (value2 === null)
      return "null";
    if (Array.isArray(value2))
      return "array";
    if (typeof value2 == "boolean")
      return "boolean";
    if (typeof value2 == "function")
      return "function";
    if (typeof value2 == "number")
      return "number";
    if (typeof value2 == "string")
      return "string";
    if (typeof value2 == "bigint")
      return "bigint";
    if (typeof value2 == "object") {
      if (value2 != null) {
        if (value2.constructor === RegExp)
          return "regexp";
        if (value2.constructor === Map)
          return "map";
        if (value2.constructor === Set)
          return "set";
        if (value2.constructor === Date)
          return "date";
      }
      return "object";
    } else if (typeof value2 == "symbol")
      return "symbol";
    throw new Error(`value of unknown type: ${value2}`);
  }
  function getNewLineSymbol(string) {
    return string.includes(`\r
`) ? `\r
` : `
`;
  }
  function diffStrings(a22, b3, options) {
    let truncate2 = options?.truncateThreshold ?? !1, truncateThreshold = Math.max(Math.floor(options?.truncateThreshold ?? 0), 0), aLength = a22.length, bLength = b3.length;
    if (truncate2) {
      let aMultipleLines = a22.includes(`
`), bMultipleLines = b3.includes(`
`), aNewLineSymbol = getNewLineSymbol(a22), bNewLineSymbol = getNewLineSymbol(b3), _a = aMultipleLines ? `${a22.split(aNewLineSymbol, truncateThreshold).join(aNewLineSymbol)}
` : a22, _b = bMultipleLines ? `${b3.split(bNewLineSymbol, truncateThreshold).join(bNewLineSymbol)}
` : b3;
      aLength = _a.length, bLength = _b.length;
    }
    let truncated = aLength !== a22.length || bLength !== b3.length, isCommon = (aIndex2, bIndex2) => a22[aIndex2] === b3[bIndex2], aIndex = 0, bIndex = 0, diffs = [];
    return diffSequences(aLength, bLength, isCommon, (nCommon, aCommon, bCommon) => {
      aIndex !== aCommon && diffs.push(new Diff(DIFF_DELETE, a22.slice(aIndex, aCommon))), bIndex !== bCommon && diffs.push(new Diff(DIFF_INSERT, b3.slice(bIndex, bCommon))), aIndex = aCommon + nCommon, bIndex = bCommon + nCommon, diffs.push(new Diff(DIFF_EQUAL, b3.slice(bCommon, bIndex)));
    }), aIndex !== aLength && diffs.push(new Diff(DIFF_DELETE, a22.slice(aIndex))), bIndex !== bLength && diffs.push(new Diff(DIFF_INSERT, b3.slice(bIndex))), [diffs, truncated];
  }
  function concatenateRelevantDiffs(op, diffs, changeColor) {
    return diffs.reduce((reduced, diff2) => reduced + (diff2[0] === DIFF_EQUAL ? diff2[1] : diff2[0] === op && diff2[1].length !== 0 ? changeColor(diff2[1]) : ""), "");
  }
  var ChangeBuffer = class {
    op;
    line;
    lines;
    changeColor;
    constructor(op, changeColor) {
      this.op = op, this.line = [], this.lines = [], this.changeColor = changeColor;
    }
    pushSubstring(substring) {
      this.pushDiff(new Diff(this.op, substring));
    }
    pushLine() {
      this.lines.push(this.line.length !== 1 ? new Diff(this.op, concatenateRelevantDiffs(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] : new Diff(this.op, this.line[0][1])), this.line.length = 0;
    }
    isLineEmpty() {
      return this.line.length === 0;
    }
    // Minor input to buffer.
    pushDiff(diff2) {
      this.line.push(diff2);
    }
    // Main input to buffer.
    align(diff2) {
      let string = diff2[1];
      if (string.includes(`
`)) {
        let substrings = string.split(`
`), iLast = substrings.length - 1;
        substrings.forEach((substring, i3) => {
          i3 < iLast ? (this.pushSubstring(substring), this.pushLine()) : substring.length !== 0 && this.pushSubstring(substring);
        });
      } else
        this.pushDiff(diff2);
    }
    // Output from buffer.
    moveLinesTo(lines) {
      this.isLineEmpty() || this.pushLine(), lines.push(...this.lines), this.lines.length = 0;
    }
  }, CommonBuffer = class {
    deleteBuffer;
    insertBuffer;
    lines;
    constructor(deleteBuffer, insertBuffer) {
      this.deleteBuffer = deleteBuffer, this.insertBuffer = insertBuffer, this.lines = [];
    }
    pushDiffCommonLine(diff2) {
      this.lines.push(diff2);
    }
    pushDiffChangeLines(diff2) {
      let isDiffEmpty = diff2[1].length === 0;
      (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) && this.deleteBuffer.pushDiff(diff2), (!isDiffEmpty || this.insertBuffer.isLineEmpty()) && this.insertBuffer.pushDiff(diff2);
    }
    flushChangeLines() {
      this.deleteBuffer.moveLinesTo(this.lines), this.insertBuffer.moveLinesTo(this.lines);
    }
    // Input to buffer.
    align(diff2) {
      let op = diff2[0], string = diff2[1];
      if (string.includes(`
`)) {
        let substrings = string.split(`
`), iLast = substrings.length - 1;
        substrings.forEach((substring, i3) => {
          if (i3 === 0) {
            let subdiff = new Diff(op, substring);
            this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty() ? (this.flushChangeLines(), this.pushDiffCommonLine(subdiff)) : (this.pushDiffChangeLines(subdiff), this.flushChangeLines());
          } else i3 < iLast ? this.pushDiffCommonLine(new Diff(op, substring)) : substring.length !== 0 && this.pushDiffChangeLines(new Diff(op, substring));
        });
      } else
        this.pushDiffChangeLines(diff2);
    }
    // Output from buffer.
    getLines() {
      return this.flushChangeLines(), this.lines;
    }
  };
  function getAlignedDiffs(diffs, changeColor) {
    let deleteBuffer = new ChangeBuffer(DIFF_DELETE, changeColor), insertBuffer = new ChangeBuffer(DIFF_INSERT, changeColor), commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);
    return diffs.forEach((diff2) => {
      switch (diff2[0]) {
        case DIFF_DELETE:
          deleteBuffer.align(diff2);
          break;
        case DIFF_INSERT:
          insertBuffer.align(diff2);
          break;
        default:
          commonBuffer.align(diff2);
      }
    }), commonBuffer.getLines();
  }
  function hasCommonDiff(diffs, isMultiline) {
    if (isMultiline) {
      let iLast = diffs.length - 1;
      return diffs.some((diff2, i3) => diff2[0] === DIFF_EQUAL && (i3 !== iLast || diff2[1] !== `
`));
    }
    return diffs.some((diff2) => diff2[0] === DIFF_EQUAL);
  }
  function diffStringsUnified(a22, b3, options) {
    if (a22 !== b3 && a22.length !== 0 && b3.length !== 0) {
      let isMultiline = a22.includes(`
`) || b3.includes(`
`), [diffs, truncated] = diffStringsRaw(isMultiline ? `${a22}
` : a22, isMultiline ? `${b3}
` : b3, !0, options);
      if (hasCommonDiff(diffs, isMultiline)) {
        let optionsNormalized = normalizeDiffOptions(options), lines = getAlignedDiffs(diffs, optionsNormalized.changeColor);
        return printDiffLines(lines, truncated, optionsNormalized);
      }
    }
    return diffLinesUnified(a22.split(`
`), b3.split(`
`), options);
  }
  function diffStringsRaw(a22, b3, cleanup, options) {
    let [diffs, truncated] = diffStrings(a22, b3, options);
    return cleanup && diff_cleanupSemantic(diffs), [diffs, truncated];
  }
  function getCommonMessage(message, options) {
    let { commonColor } = normalizeDiffOptions(options);
    return commonColor(message);
  }
  var { AsymmetricMatcher: AsymmetricMatcher2, DOMCollection: DOMCollection2, DOMElement: DOMElement2, Immutable: Immutable2, ReactElement: ReactElement2, ReactTestComponent: ReactTestComponent2 } = plugins, PLUGINS2 = [
    ReactTestComponent2,
    ReactElement2,
    DOMElement2,
    DOMCollection2,
    Immutable2,
    AsymmetricMatcher2,
    plugins.Error
  ], FORMAT_OPTIONS = {
    maxDepth: 20,
    plugins: PLUGINS2
  }, FALLBACK_FORMAT_OPTIONS = {
    callToJSON: !1,
    maxDepth: 8,
    plugins: PLUGINS2
  };
  function diff(a22, b3, options) {
    if (Object.is(a22, b3))
      return "";
    let aType = getType3(a22), expectedType = aType, omitDifference = !1;
    if (aType === "object" && typeof a22.asymmetricMatch == "function") {
      if (a22.$$typeof !== /* @__PURE__ */ Symbol.for("jest.asymmetricMatcher") || typeof a22.getExpectedType != "function")
        return;
      expectedType = a22.getExpectedType(), omitDifference = expectedType === "string";
    }
    if (expectedType !== getType3(b3)) {
      let truncate2 = function(s22) {
        return s22.length <= MAX_LENGTH ? s22 : `${s22.slice(0, MAX_LENGTH)}...`;
      }, { aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator } = normalizeDiffOptions(options), formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options), aDisplay = format2(a22, formatOptions), bDisplay = format2(b3, formatOptions), MAX_LENGTH = 1e5;
      aDisplay = truncate2(aDisplay), bDisplay = truncate2(bDisplay);
      let aDiff = `${aColor(`${aIndicator} ${aAnnotation}:`)} 
${aDisplay}`, bDiff = `${bColor(`${bIndicator} ${bAnnotation}:`)} 
${bDisplay}`;
      return `${aDiff}

${bDiff}`;
    }
    if (!omitDifference)
      switch (aType) {
        case "string":
          return diffLinesUnified(a22.split(`
`), b3.split(`
`), options);
        case "boolean":
        case "number":
          return comparePrimitive(a22, b3, options);
        case "map":
          return compareObjects(sortMap(a22), sortMap(b3), options);
        case "set":
          return compareObjects(sortSet(a22), sortSet(b3), options);
        default:
          return compareObjects(a22, b3, options);
      }
  }
  function comparePrimitive(a22, b3, options) {
    let aFormat = format2(a22, FORMAT_OPTIONS), bFormat = format2(b3, FORMAT_OPTIONS);
    return aFormat === bFormat ? "" : diffLinesUnified(aFormat.split(`
`), bFormat.split(`
`), options);
  }
  function sortMap(map) {
    return new Map(Array.from(map.entries()).sort());
  }
  function sortSet(set) {
    return new Set(Array.from(set.values()).sort());
  }
  function compareObjects(a22, b3, options) {
    let difference, hasThrown = !1;
    try {
      let formatOptions = getFormatOptions(FORMAT_OPTIONS, options);
      difference = getObjectsDifference(a22, b3, formatOptions, options);
    } catch {
      hasThrown = !0;
    }
    let noDiffMessage = getCommonMessage(NO_DIFF_MESSAGE, options);
    if (difference === void 0 || difference === noDiffMessage) {
      let formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);
      difference = getObjectsDifference(a22, b3, formatOptions, options), difference !== noDiffMessage && !hasThrown && (difference = `${getCommonMessage(SIMILAR_MESSAGE, options)}

${difference}`);
    }
    return difference;
  }
  function getFormatOptions(formatOptions, options) {
    let { compareKeys, printBasicPrototype, maxDepth } = normalizeDiffOptions(options);
    return {
      ...formatOptions,
      compareKeys,
      printBasicPrototype,
      maxDepth: maxDepth ?? formatOptions.maxDepth
    };
  }
  function getObjectsDifference(a22, b3, formatOptions, options) {
    let formatOptionsZeroIndent = {
      ...formatOptions,
      indent: 0
    }, aCompare = format2(a22, formatOptionsZeroIndent), bCompare = format2(b3, formatOptionsZeroIndent);
    if (aCompare === bCompare)
      return getCommonMessage(NO_DIFF_MESSAGE, options);
    {
      let aDisplay = format2(a22, formatOptions), bDisplay = format2(b3, formatOptions);
      return diffLinesUnified2(aDisplay.split(`
`), bDisplay.split(`
`), aCompare.split(`
`), bCompare.split(`
`), options);
    }
  }
  var MAX_DIFF_STRING_LENGTH = 2e4;
  function isAsymmetricMatcher(data) {
    return getType2(data) === "Object" && typeof data.asymmetricMatch == "function";
  }
  function isReplaceable(obj1, obj2) {
    let obj1Type = getType2(obj1), obj2Type = getType2(obj2);
    return obj1Type === obj2Type && (obj1Type === "Object" || obj1Type === "Array");
  }
  function printDiffOrStringify(received, expected, options) {
    let { aAnnotation, bAnnotation } = normalizeDiffOptions(options);
    if (typeof expected == "string" && typeof received == "string" && expected.length > 0 && received.length > 0 && expected.length <= MAX_DIFF_STRING_LENGTH && received.length <= MAX_DIFF_STRING_LENGTH && expected !== received) {
      if (expected.includes(`
`) || received.includes(`
`))
        return diffStringsUnified(expected, received, options);
      let [diffs] = diffStringsRaw(expected, received, !0), hasCommonDiff2 = diffs.some((diff2) => diff2[0] === DIFF_EQUAL), printLabel = getLabelPrinter(aAnnotation, bAnnotation), expectedLine = printLabel(aAnnotation) + printExpected(getCommonAndChangedSubstrings(diffs, DIFF_DELETE, hasCommonDiff2)), receivedLine = printLabel(bAnnotation) + printReceived(getCommonAndChangedSubstrings(diffs, DIFF_INSERT, hasCommonDiff2));
      return `${expectedLine}
${receivedLine}`;
    }
    let clonedExpected = deepClone(expected, { forceWritable: !0 }), clonedReceived = deepClone(received, { forceWritable: !0 }), { replacedExpected, replacedActual } = replaceAsymmetricMatcher(clonedReceived, clonedExpected);
    return diff(replacedExpected, replacedActual, options);
  }
  function replaceAsymmetricMatcher(actual, expected, actualReplaced = /* @__PURE__ */ new WeakSet(), expectedReplaced = /* @__PURE__ */ new WeakSet()) {
    return actual instanceof Error && expected instanceof Error && typeof actual.cause < "u" && typeof expected.cause > "u" ? (delete actual.cause, {
      replacedActual: actual,
      replacedExpected: expected
    }) : isReplaceable(actual, expected) ? actualReplaced.has(actual) || expectedReplaced.has(expected) ? {
      replacedActual: actual,
      replacedExpected: expected
    } : (actualReplaced.add(actual), expectedReplaced.add(expected), getOwnProperties(expected).forEach((key) => {
      let expectedValue = expected[key], actualValue = actual[key];
      if (isAsymmetricMatcher(expectedValue))
        expectedValue.asymmetricMatch(actualValue) && (actual[key] = expectedValue);
      else if (isAsymmetricMatcher(actualValue))
        actualValue.asymmetricMatch(expectedValue) && (expected[key] = actualValue);
      else if (isReplaceable(actualValue, expectedValue)) {
        let replaced = replaceAsymmetricMatcher(actualValue, expectedValue, actualReplaced, expectedReplaced);
        actual[key] = replaced.replacedActual, expected[key] = replaced.replacedExpected;
      }
    }), {
      replacedActual: actual,
      replacedExpected: expected
    }) : {
      replacedActual: actual,
      replacedExpected: expected
    };
  }
  function getLabelPrinter(...strings) {
    let maxLength = strings.reduce((max, string) => string.length > max ? string.length : max, 0);
    return (string) => `${string}: ${" ".repeat(maxLength - string.length)}`;
  }
  var SPACE_SYMBOL = "\xB7";
  function replaceTrailingSpaces(text) {
    return text.replace(/\s+$/gm, (spaces) => SPACE_SYMBOL.repeat(spaces.length));
  }
  function printReceived(object2) {
    return s.red(replaceTrailingSpaces(stringify2(object2)));
  }
  function printExpected(value2) {
    return s.green(replaceTrailingSpaces(stringify2(value2)));
  }
  function getCommonAndChangedSubstrings(diffs, op, hasCommonDiff2) {
    return diffs.reduce((reduced, diff2) => reduced + (diff2[0] === DIFF_EQUAL ? diff2[1] : diff2[0] === op ? hasCommonDiff2 ? s.inverse(diff2[1]) : diff2[1] : ""), "");
  }
  var IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@", IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
  function isImmutable(v3) {
    return v3 && (v3[IS_COLLECTION_SYMBOL] || v3[IS_RECORD_SYMBOL]);
  }
  var OBJECT_PROTO = Object.getPrototypeOf({});
  function getUnserializableMessage(err) {
    return err instanceof Error ? `<unserializable>: ${err.message}` : typeof err == "string" ? `<unserializable>: ${err}` : "<unserializable>";
  }
  function serializeValue(val, seen = /* @__PURE__ */ new WeakMap()) {
    if (!val || typeof val == "string")
      return val;
    if (val instanceof Error && "toJSON" in val && typeof val.toJSON == "function") {
      let jsonValue = val.toJSON();
      return jsonValue && jsonValue !== val && typeof jsonValue == "object" && (typeof val.message == "string" && safe(() => jsonValue.message ?? (jsonValue.message = val.message)), typeof val.stack == "string" && safe(() => jsonValue.stack ?? (jsonValue.stack = val.stack)), typeof val.name == "string" && safe(() => jsonValue.name ?? (jsonValue.name = val.name)), val.cause != null && safe(() => jsonValue.cause ?? (jsonValue.cause = serializeValue(val.cause, seen)))), serializeValue(jsonValue, seen);
    }
    if (typeof val == "function")
      return `Function<${val.name || "anonymous"}>`;
    if (typeof val == "symbol")
      return val.toString();
    if (typeof val != "object")
      return val;
    if (typeof Buffer < "u" && val instanceof Buffer)
      return `<Buffer(${val.length}) ...>`;
    if (typeof Uint8Array < "u" && val instanceof Uint8Array)
      return `<Uint8Array(${val.length}) ...>`;
    if (isImmutable(val))
      return serializeValue(val.toJSON(), seen);
    if (val instanceof Promise || val.constructor && val.constructor.prototype === "AsyncFunction")
      return "Promise";
    if (typeof Element < "u" && val instanceof Element)
      return val.tagName;
    if (typeof val.asymmetricMatch == "function")
      return `${val.toString()} ${format22(val.sample)}`;
    if (typeof val.toJSON == "function")
      return serializeValue(val.toJSON(), seen);
    if (seen.has(val))
      return seen.get(val);
    if (Array.isArray(val)) {
      let clone2 = new Array(val.length);
      return seen.set(val, clone2), val.forEach((e, i3) => {
        try {
          clone2[i3] = serializeValue(e, seen);
        } catch (err) {
          clone2[i3] = getUnserializableMessage(err);
        }
      }), clone2;
    } else {
      let clone2 = /* @__PURE__ */ Object.create(null);
      seen.set(val, clone2);
      let obj = val;
      for (; obj && obj !== OBJECT_PROTO; )
        Object.getOwnPropertyNames(obj).forEach((key) => {
          if (!(key in clone2))
            try {
              clone2[key] = serializeValue(val[key], seen);
            } catch (err) {
              delete clone2[key], clone2[key] = getUnserializableMessage(err);
            }
        }), obj = Object.getPrototypeOf(obj);
      return clone2;
    }
  }
  function safe(fn2) {
    try {
      return fn2();
    } catch {
    }
  }
  function normalizeErrorMessage(message) {
    return message.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, "");
  }
  function processError(_err, diffOptions, seen = /* @__PURE__ */ new WeakSet()) {
    if (!_err || typeof _err != "object")
      return { message: String(_err) };
    let err = _err;
    (err.showDiff || err.showDiff === void 0 && err.expected !== void 0 && err.actual !== void 0) && (err.diff = printDiffOrStringify(err.actual, err.expected, {
      ...diffOptions,
      ...err.diffOptions
    })), "expected" in err && typeof err.expected != "string" && (err.expected = stringify2(err.expected, 10)), "actual" in err && typeof err.actual != "string" && (err.actual = stringify2(err.actual, 10));
    try {
      typeof err.message == "string" && (err.message = normalizeErrorMessage(err.message));
    } catch {
    }
    try {
      !seen.has(err) && typeof err.cause == "object" && (seen.add(err), err.cause = processError(err.cause, diffOptions, seen));
    } catch {
    }
    try {
      return serializeValue(err);
    } catch (e) {
      return serializeValue(new Error(`Failed to fully serialize error: ${e?.message}
Inner error message: ${err?.message}`));
    }
  }

  // node_modules/storybook/dist/instrumenter/index.js
  init_chunk_A242L54C();
  var addons3 = globalThis.__STORYBOOK_ADDONS_PREVIEW, alreadyCompletedException = new Error(
    "This function ran after the play function completed. Did you forget to `await` it?"
  ), isObject = (o2) => Object.prototype.toString.call(o2) === "[object Object]", isModule = (o2) => Object.prototype.toString.call(o2) === "[object Module]", isInstrumentable = (o2) => {
    if (!isObject(o2) && !isModule(o2))
      return !1;
    if (o2.constructor === void 0)
      return !0;
    let proto = o2.constructor.prototype;
    return !!isObject(proto);
  }, construct = (obj) => {
    try {
      return new obj.constructor();
    } catch {
      return {};
    }
  }, getInitialState = () => ({
    renderPhase: "preparing",
    isDebugging: !1,
    isPlaying: !1,
    isLocked: !1,
    cursor: 0,
    calls: [],
    shadowCalls: [],
    callRefsByResult: /* @__PURE__ */ new Map(),
    chainedCallIds: /* @__PURE__ */ new Set(),
    ancestors: [],
    playUntil: void 0,
    resolvers: {},
    syncTimeout: void 0
  }), getRetainedState = (state3, isDebugging = !1) => {
    let calls = (isDebugging ? state3.shadowCalls : state3.calls).filter((call) => call.retain);
    if (!calls.length)
      return;
    let callRefsByResult = new Map(
      Array.from(state3.callRefsByResult.entries()).filter(([, ref]) => ref.retain)
    );
    return { cursor: calls.length, calls, callRefsByResult };
  }, Instrumenter = class {
    constructor() {
      this.detached = !1, this.initialized = !1, this.state = {}, this.loadParentWindowState = () => {
        try {
          this.state = scope.window?.parent?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};
        } catch {
          this.detached = !0;
        }
      }, this.updateParentWindowState = () => {
        try {
          scope.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;
        } catch {
          this.detached = !0;
        }
      }, this.loadParentWindowState();
      let resetState = ({
        storyId,
        renderPhase,
        isPlaying = !0,
        isDebugging = !1
      }) => {
        let state3 = this.getState(storyId);
        this.setState(storyId, {
          ...getInitialState(),
          ...getRetainedState(state3, isDebugging),
          renderPhase: renderPhase || state3.renderPhase,
          shadowCalls: isDebugging ? state3.shadowCalls : [],
          chainedCallIds: isDebugging ? state3.chainedCallIds : /* @__PURE__ */ new Set(),
          playUntil: isDebugging ? state3.playUntil : void 0,
          isPlaying,
          isDebugging
        }), this.sync(storyId);
      }, start = (channel) => ({ storyId, playUntil }) => {
        this.getState(storyId).isDebugging || this.setState(storyId, ({ calls }) => ({
          calls: [],
          shadowCalls: calls.map((call) => ({
            ...call,
            status: "waiting"
            /* WAITING */
          })),
          isDebugging: !0
        }));
        let log = this.getLog(storyId);
        this.setState(storyId, ({ shadowCalls }) => {
          if (playUntil || !log.length)
            return { playUntil };
          let firstRowIndex = shadowCalls.findIndex((call) => call.id === log[0].callId);
          return {
            playUntil: shadowCalls.slice(0, firstRowIndex).filter((call) => call.interceptable && !call.ancestors?.length).slice(-1)[0]?.id
          };
        }), channel.emit(FORCE_REMOUNT, { storyId, isDebugging: !0 });
      }, back = (channel) => ({ storyId }) => {
        let log = this.getLog(storyId).filter((call) => !call.ancestors?.length), last = log.reduceRight((res, item, index2) => res >= 0 || item.status === "waiting" ? res : index2, -1);
        start(channel)({ storyId, playUntil: log[last - 1]?.callId });
      }, goto = (channel) => ({ storyId, callId }) => {
        let { calls, shadowCalls, resolvers } = this.getState(storyId), call = calls.find(({ id: id2 }) => id2 === callId), shadowCall = shadowCalls.find(({ id: id2 }) => id2 === callId);
        if (!call && shadowCall && Object.values(resolvers).length > 0) {
          let nextId = this.getLog(storyId).find(
            (c3) => c3.status === "waiting"
            /* WAITING */
          )?.callId;
          shadowCall.id !== nextId && this.setState(storyId, { playUntil: shadowCall.id }), Object.values(resolvers).forEach((resolve) => resolve());
        } else
          start(channel)({ storyId, playUntil: callId });
      }, next = (channel) => ({ storyId }) => {
        let { resolvers } = this.getState(storyId);
        if (Object.values(resolvers).length > 0)
          Object.values(resolvers).forEach((resolve) => resolve());
        else {
          let nextId = this.getLog(storyId).find(
            (c3) => c3.status === "waiting"
            /* WAITING */
          )?.callId;
          nextId ? start(channel)({ storyId, playUntil: nextId }) : end({ storyId });
        }
      }, end = ({ storyId }) => {
        this.setState(storyId, { playUntil: void 0, isDebugging: !1 }), Object.values(this.getState(storyId).resolvers).forEach((resolve) => resolve());
      }, renderPhaseChanged = ({
        storyId,
        newPhase
      }) => {
        let { isDebugging } = this.getState(storyId);
        if (newPhase === "preparing" && isDebugging)
          return resetState({ storyId, renderPhase: newPhase, isDebugging });
        if (newPhase === "playing")
          return resetState({ storyId, renderPhase: newPhase, isDebugging });
        newPhase === "played" ? this.setState(storyId, {
          renderPhase: newPhase,
          isLocked: !1,
          isPlaying: !1,
          isDebugging: !1
        }) : newPhase === "errored" ? this.setState(storyId, {
          renderPhase: newPhase,
          isLocked: !1,
          isPlaying: !1
        }) : newPhase === "aborted" ? this.setState(storyId, {
          renderPhase: newPhase,
          isLocked: !0,
          isPlaying: !1
        }) : this.setState(storyId, {
          renderPhase: newPhase
        }), this.sync(storyId);
      };
      addons3 && addons3.ready().then(() => {
        this.channel = addons3.getChannel(), this.channel.on(FORCE_REMOUNT, resetState), this.channel.on(STORY_RENDER_PHASE_CHANGED, renderPhaseChanged), this.channel.on(SET_CURRENT_STORY, () => {
          this.initialized ? this.cleanup() : this.initialized = !0;
        }), this.channel.on(EVENTS3.START, start(this.channel)), this.channel.on(EVENTS3.BACK, back(this.channel)), this.channel.on(EVENTS3.GOTO, goto(this.channel)), this.channel.on(EVENTS3.NEXT, next(this.channel)), this.channel.on(EVENTS3.END, end);
      });
    }
    getState(storyId) {
      return this.state[storyId] || getInitialState();
    }
    setState(storyId, update) {
      if (storyId) {
        let state3 = this.getState(storyId), patch = typeof update == "function" ? update(state3) : update;
        this.state = { ...this.state, [storyId]: { ...state3, ...patch } }, this.updateParentWindowState();
      }
    }
    cleanup() {
      this.state = Object.entries(this.state).reduce(
        (acc, [storyId, state3]) => {
          let retainedState = getRetainedState(state3);
          return retainedState && (acc[storyId] = Object.assign(getInitialState(), retainedState)), acc;
        },
        {}
      );
      let payload = { controlStates: {
        detached: this.detached,
        start: !1,
        back: !1,
        goto: !1,
        next: !1,
        end: !1
      }, logItems: [] };
      this.channel?.emit(EVENTS3.SYNC, payload), this.updateParentWindowState();
    }
    getLog(storyId) {
      let { calls, shadowCalls } = this.getState(storyId), merged = [...shadowCalls];
      calls.forEach((call, index2) => {
        merged[index2] = call;
      });
      let seen = /* @__PURE__ */ new Set();
      return merged.reduceRight((acc, call) => (call.args.forEach((arg) => {
        arg?.__callId__ && seen.add(arg.__callId__);
      }), call.path.forEach((node) => {
        node.__callId__ && seen.add(node.__callId__);
      }), (call.interceptable || call.exception) && !seen.has(call.id) && (acc.unshift({ callId: call.id, status: call.status, ancestors: call.ancestors }), seen.add(call.id)), acc), []);
    }
    // Traverses the object structure to recursively patch all function properties.
    // Returns the original object, or a new object with the same constructor,
    // depending on whether it should mutate.
    instrument(obj, options, depth = 0) {
      if (!isInstrumentable(obj))
        return obj;
      let { mutate = !1, path = [] } = options, keys = options.getKeys ? options.getKeys(obj, depth) : Object.keys(obj);
      return depth += 1, keys.reduce(
        (acc, key) => {
          let descriptor = getPropertyDescriptor(obj, key);
          if (typeof descriptor?.get == "function") {
            if (descriptor.configurable) {
              let getter = () => descriptor?.get?.bind(obj)?.();
              Object.defineProperty(acc, key, {
                get: () => this.instrument(getter(), { ...options, path: path.concat(key) }, depth)
              });
            }
            return acc;
          }
          let value2 = obj[key];
          return typeof value2 != "function" ? (acc[key] = this.instrument(value2, { ...options, path: path.concat(key) }, depth), acc) : "__originalFn__" in value2 && typeof value2.__originalFn__ == "function" ? (acc[key] = value2, acc) : (acc[key] = (...args) => this.track(key, value2, obj, args, options), acc[key].__originalFn__ = value2, Object.defineProperty(acc[key], "name", { value: key, writable: !1 }), Object.keys(value2).length > 0 && Object.assign(
            acc[key],
            this.instrument({ ...value2 }, { ...options, path: path.concat(key) }, depth)
          ), acc);
        },
        mutate ? obj : construct(obj)
      );
    }
    // Monkey patch an object method to record calls.
    // Returns a function that invokes the original function, records the invocation ("call") and
    // returns the original result.
    track(method, fn2, object2, args, options) {
      let storyId = args?.[0]?.__storyId__ || scope.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId, { cursor, ancestors } = this.getState(storyId);
      this.setState(storyId, { cursor: cursor + 1 });
      let id2 = `${ancestors.slice(-1)[0] || storyId} [${cursor}] ${method}`, { path = [], intercept = !1, retain = !1 } = options, interceptable = typeof intercept == "function" ? intercept(method, path) : intercept, call = { id: id2, cursor, storyId, ancestors, path, method, args, interceptable, retain }, result = (interceptable && !ancestors.length ? this.intercept : this.invoke).call(this, fn2, object2, call, options);
      return this.instrument(result, { ...options, mutate: !0, path: [{ __callId__: call.id }] });
    }
    intercept(fn2, object2, call, options) {
      let { chainedCallIds, isDebugging, playUntil } = this.getState(call.storyId), isChainedUpon = chainedCallIds.has(call.id);
      return !isDebugging || isChainedUpon || playUntil ? (playUntil === call.id && this.setState(call.storyId, { playUntil: void 0 }), this.invoke(fn2, object2, call, options)) : new Promise((resolve) => {
        this.setState(call.storyId, ({ resolvers }) => ({
          isLocked: !1,
          resolvers: { ...resolvers, [call.id]: resolve }
        }));
      }).then(() => (this.setState(call.storyId, (state3) => {
        let { [call.id]: _3, ...resolvers } = state3.resolvers;
        return { isLocked: !0, resolvers };
      }), this.invoke(fn2, object2, call, options)));
    }
    invoke(fn2, object2, call, options) {
      let { callRefsByResult, renderPhase } = this.getState(call.storyId), maximumDepth = 25, serializeValues = (value2, depth, seen) => {
        if (seen.includes(value2))
          return "[Circular]";
        if (seen = [...seen, value2], depth > maximumDepth)
          return "...";
        if (callRefsByResult.has(value2))
          return callRefsByResult.get(value2);
        if (value2 instanceof Array)
          return value2.map((it) => serializeValues(it, ++depth, seen));
        if (value2 instanceof Date)
          return { __date__: { value: value2.toISOString() } };
        if (value2 instanceof Error) {
          let { name, message, stack } = value2;
          return { __error__: { name, message, stack } };
        }
        if (value2 instanceof RegExp) {
          let { flags, source } = value2;
          return { __regexp__: { flags, source } };
        }
        if (value2 instanceof scope.window?.HTMLElement) {
          let { prefix: prefix2, localName, id: id2, classList, innerText } = value2, classNames = Array.from(classList);
          return { __element__: { prefix: prefix2, localName, id: id2, classNames, innerText } };
        }
        return typeof value2 == "function" ? {
          __function__: { name: "getMockName" in value2 ? value2.getMockName() : value2.name }
        } : typeof value2 == "symbol" ? { __symbol__: { description: value2.description } } : typeof value2 == "object" && value2?.constructor?.name && value2?.constructor?.name !== "Object" ? { __class__: { name: value2.constructor.name } } : Object.prototype.toString.call(value2) === "[object Object]" ? Object.fromEntries(
          Object.entries(value2).map(([key, val]) => [key, serializeValues(val, ++depth, seen)])
        ) : value2;
      }, info = {
        ...call,
        args: call.args.map((arg) => serializeValues(arg, 0, []))
      };
      call.path.forEach((ref) => {
        ref?.__callId__ && this.setState(call.storyId, ({ chainedCallIds }) => ({
          chainedCallIds: new Set(Array.from(chainedCallIds).concat(ref.__callId__))
        }));
      });
      let handleException = (e) => {
        if (e instanceof Error) {
          let { name, message, stack, callId = call.id } = e, {
            showDiff = void 0,
            diff: diff2 = void 0,
            actual = void 0,
            expected = void 0
          } = e.name === "AssertionError" ? processError(e) : e, exception = { name, message, stack, callId, showDiff, diff: diff2, actual, expected };
          if (this.update({ ...info, status: "error", exception }), this.setState(call.storyId, (state3) => ({
            callRefsByResult: new Map([
              ...Array.from(state3.callRefsByResult.entries()),
              [e, { __callId__: call.id, retain: call.retain }]
            ])
          })), call.ancestors?.length)
            throw Object.prototype.hasOwnProperty.call(e, "callId") || Object.defineProperty(e, "callId", { value: call.id }), e;
        }
        throw e;
      };
      try {
        if (renderPhase === "played" && !call.retain)
          throw alreadyCompletedException;
        let finalArgs = (options.getArgs ? options.getArgs(call, this.getState(call.storyId)) : call.args).map((arg) => typeof arg != "function" || isClass(arg) || Object.keys(arg).length ? arg : (...args) => {
          let { cursor, ancestors } = this.getState(call.storyId);
          this.setState(call.storyId, { cursor: 0, ancestors: [...ancestors, call.id] });
          let restore = () => this.setState(call.storyId, { cursor, ancestors }), willRestore = !1;
          try {
            let res = arg(...args);
            return res instanceof Promise ? (willRestore = !0, res.finally(restore)) : res;
          } finally {
            willRestore || restore();
          }
        }), result = fn2.apply(object2, finalArgs);
        return result && ["object", "function", "symbol"].includes(typeof result) && this.setState(call.storyId, (state3) => ({
          callRefsByResult: new Map([
            ...Array.from(state3.callRefsByResult.entries()),
            [result, { __callId__: call.id, retain: call.retain }]
          ])
        })), this.update({
          ...info,
          status: result instanceof Promise ? "active" : "done"
          /* DONE */
        }), result instanceof Promise ? result.then((value2) => (this.update({
          ...info,
          status: "done"
          /* DONE */
        }), value2), handleException) : result;
      } catch (e) {
        return handleException(e);
      }
    }
    // Sends the call info to the manager and synchronizes the log.
    update(call) {
      this.channel?.emit(EVENTS3.CALL, call), this.setState(call.storyId, ({ calls }) => {
        let callsById = calls.concat(call).reduce((a3, c3) => Object.assign(a3, { [c3.id]: c3 }), {});
        return {
          // Calls are sorted to ensure parent calls always come before calls in their callback.
          calls: Object.values(callsById).sort(
            (a3, b3) => a3.id.localeCompare(b3.id, void 0, { numeric: !0 })
          )
        };
      }), this.sync(call.storyId);
    }
    // Builds a log of interceptable calls and control states and sends it to the manager.
    // Uses a 0ms debounce because this might get called many times in one tick.
    sync(storyId) {
      let synchronize = () => {
        let { isLocked, isPlaying } = this.getState(storyId), logItems = this.getLog(storyId), pausedAt = logItems.filter(({ ancestors }) => !ancestors.length).find(
          (item) => item.status === "waiting"
          /* WAITING */
        )?.callId, hasActive = logItems.some(
          (item) => item.status === "active"
          /* ACTIVE */
        );
        if (this.detached || isLocked || hasActive || logItems.length === 0) {
          let payload2 = { controlStates: {
            detached: this.detached,
            start: !1,
            back: !1,
            goto: !1,
            next: !1,
            end: !1
          }, logItems };
          this.channel?.emit(EVENTS3.SYNC, payload2);
          return;
        }
        let hasPrevious = logItems.some(
          (item) => item.status === "done" || item.status === "error"
          /* ERROR */
        ), payload = { controlStates: {
          detached: this.detached,
          start: hasPrevious,
          back: hasPrevious,
          goto: !0,
          next: isPlaying,
          end: isPlaying
        }, logItems, pausedAt };
        this.channel?.emit(EVENTS3.SYNC, payload);
      };
      this.setState(storyId, ({ syncTimeout }) => (clearTimeout(syncTimeout), { syncTimeout: setTimeout(synchronize, 0) }));
    }
  };
  function instrument(obj, options = {}) {
    try {
      let forceInstrument = !1, skipInstrument = !1;
      return scope.window?.location?.search?.includes("instrument=true") ? forceInstrument = !0 : scope.window?.location?.search?.includes("instrument=false") && (skipInstrument = !0), scope.window?.parent === scope.window && !forceInstrument || skipInstrument ? obj : (scope.window && !scope.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ && (scope.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new Instrumenter()), (scope.window?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__).instrument(obj, options));
    } catch (e) {
      return once.warn(e), obj;
    }
  }
  function getPropertyDescriptor(obj, propName) {
    let target = obj;
    for (; target != null; ) {
      let descriptor = Object.getOwnPropertyDescriptor(target, propName);
      if (descriptor)
        return descriptor;
      target = Object.getPrototypeOf(target);
    }
  }
  function isClass(obj) {
    if (typeof obj != "function")
      return !1;
    let descriptor = Object.getOwnPropertyDescriptor(obj, "prototype");
    return descriptor ? !descriptor.writable : !1;
  }

  // node_modules/storybook/dist/csf/index.js
  var require_tiny_isequal = __commonJS({
    "../../node_modules/@ngard/tiny-isequal/index.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.isEqual = /* @__PURE__ */ (function() {
        var e = Object.prototype.toString, r2 = Object.getPrototypeOf, t = Object.getOwnPropertySymbols ? function(e2) {
          return Object.keys(e2).concat(Object.getOwnPropertySymbols(e2));
        } : Object.keys;
        return function(n2, a3) {
          return (function n22(a22, c3, u3) {
            var i3, s4, l2, o2 = e.call(a22), f4 = e.call(c3);
            if (a22 === c3) return !0;
            if (a22 == null || c3 == null) return !1;
            if (u3.indexOf(a22) > -1 && u3.indexOf(c3) > -1) return !0;
            if (u3.push(a22, c3), o2 != f4 || (i3 = t(a22), s4 = t(c3), i3.length != s4.length || i3.some(function(e2) {
              return !n22(a22[e2], c3[e2], u3);
            }))) return !1;
            switch (o2.slice(8, -1)) {
              case "Symbol":
                return a22.valueOf() == c3.valueOf();
              case "Date":
              case "Number":
                return +a22 == +c3 || +a22 != +a22 && +c3 != +c3;
              case "RegExp":
              case "Function":
              case "String":
              case "Boolean":
                return "" + a22 == "" + c3;
              case "Set":
              case "Map":
                i3 = a22.entries(), s4 = c3.entries();
                do
                  if (!n22((l2 = i3.next()).value, s4.next().value, u3)) return !1;
                while (!l2.done);
                return !0;
              case "ArrayBuffer":
                a22 = new Uint8Array(a22), c3 = new Uint8Array(c3);
              case "DataView":
                a22 = new Uint8Array(a22.buffer), c3 = new Uint8Array(c3.buffer);
              case "Float32Array":
              case "Float64Array":
              case "Int8Array":
              case "Int16Array":
              case "Int32Array":
              case "Uint8Array":
              case "Uint16Array":
              case "Uint32Array":
              case "Uint8ClampedArray":
              case "Arguments":
              case "Array":
                if (a22.length != c3.length) return !1;
                for (l2 = 0; l2 < a22.length; l2++) if ((l2 in a22 || l2 in c3) && (l2 in a22 != l2 in c3 || !n22(a22[l2], c3[l2], u3))) return !1;
                return !0;
              case "Object":
                return n22(r2(a22), r2(c3), u3);
              default:
                return !1;
            }
          })(n2, a3, []);
        };
      })();
    }
  });
  var import_tiny_isequal = __toESM(require_tiny_isequal(), 1), count = (vals) => vals.map((v3) => typeof v3 < "u").filter(Boolean).length, testValue = (cond, value2) => {
    let { exists, eq, neq, truthy } = cond;
    if (count([exists, eq, neq, truthy]) > 1)
      throw new Error(`Invalid conditional test ${JSON.stringify({ exists, eq, neq })}`);
    if (typeof eq < "u")
      return (0, import_tiny_isequal.isEqual)(value2, eq);
    if (typeof neq < "u")
      return !(0, import_tiny_isequal.isEqual)(value2, neq);
    if (typeof exists < "u") {
      let valueExists = typeof value2 < "u";
      return exists ? valueExists : !valueExists;
    }
    return typeof truthy > "u" || truthy ? !!value2 : !value2;
  }, includeConditionalArg = (argType, args, globals) => {
    if (!argType.if)
      return !0;
    let { arg, global: global5 } = argType.if;
    if (count([arg, global5]) !== 1)
      throw new Error(`Invalid conditional value ${JSON.stringify({ arg, global: global5 })}`);
    let value2 = arg ? args[arg] : globals[global5];
    return testValue(argType.if, value2);
  }, addArgs_exports = {};
  __export2(addArgs_exports, {
    argsEnhancers: () => argsEnhancers
  });
  var isInInitialArgs = (name, initialArgs) => typeof initialArgs[name] > "u" && !(name in initialArgs), inferActionsFromArgTypesRegex = (context) => {
    let {
      initialArgs,
      argTypes,
      id: id2,
      parameters: { actions }
    } = context;
    if (!actions || actions.disable || !actions.argTypesRegex || !argTypes)
      return {};
    let argTypesRegex = new RegExp(actions.argTypesRegex);
    return Object.entries(argTypes).filter(
      ([name]) => !!argTypesRegex.test(name)
    ).reduce((acc, [name, argType]) => (isInInitialArgs(name, initialArgs) && (acc[name] = action(name, { implicit: !0, id: id2 })), acc), {});
  }, addActionsFromArgTypes = (context) => {
    let {
      initialArgs,
      argTypes,
      parameters: { actions }
    } = context;
    return actions?.disable || !argTypes ? {} : Object.entries(argTypes).filter(([name, argType]) => !!argType.action).reduce((acc, [name, argType]) => (isInInitialArgs(name, initialArgs) && (acc[name] = action(typeof argType.action == "string" ? argType.action : name)), acc), {});
  }, argsEnhancers = [
    addActionsFromArgTypes,
    inferActionsFromArgTypesRegex
  ], loaders_exports = {};
  __export2(loaders_exports, {
    loaders: () => loaders
  });
  var subscribed = !1, logActionsWhenMockCalled = (context) => {
    let { parameters: parameters2 } = context;
    parameters2?.actions?.disable || subscribed || (onMockCall((mock, args) => {
      let name = mock.getMockName();
      name !== "spy" && name !== "vi.fn()" && (!/^next\/.*::/.test(name) || [
        "next/router::useRouter()",
        "next/navigation::useRouter()",
        "next/navigation::redirect",
        "next/cache::",
        "next/headers::cookies().set",
        "next/headers::cookies().delete",
        "next/headers::headers().set",
        "next/headers::headers().delete"
      ].some((prefix2) => name.startsWith(prefix2))) && action(name)(args);
    }), subscribed = !0);
  }, loaders = [logActionsWhenMockCalled];
  var { document: document22 } = globalThis, isReduceMotionEnabled = () => globalThis?.matchMedia ? !!globalThis.matchMedia("(prefers-reduced-motion: reduce)")?.matches : !1, clearStyles = (selector) => {
    (Array.isArray(selector) ? selector : [selector]).forEach(clearStyle);
  }, clearStyle = (selector) => {
    if (!document22)
      return;
    let element = document22.getElementById(selector);
    element && element.parentElement && element.parentElement.removeChild(element);
  }, addGridStyle = (selector, css2) => {
    if (!document22)
      return;
    let existingStyle = document22.getElementById(selector);
    if (existingStyle)
      existingStyle.innerHTML !== css2 && (existingStyle.innerHTML = css2);
    else {
      let style = document22.createElement("style");
      style.setAttribute("id", selector), style.innerHTML = css2, document22.head.appendChild(style);
    }
  }, addBackgroundStyle = (selector, css2, storyId) => {
    if (!document22)
      return;
    let existingStyle = document22.getElementById(selector);
    if (existingStyle)
      existingStyle.innerHTML !== css2 && (existingStyle.innerHTML = css2);
    else {
      let style = document22.createElement("style");
      style.setAttribute("id", selector), style.innerHTML = css2;
      let gridStyleSelector = `addon-backgrounds-grid${storyId ? `-docs-${storyId}` : ""}`, existingGridStyle = document22.getElementById(gridStyleSelector);
      existingGridStyle ? existingGridStyle.parentElement?.insertBefore(style, existingGridStyle) : document22.head.appendChild(style);
    }
  }, defaultGrid = {
    cellSize: 100,
    cellAmount: 10,
    opacity: 0.8
  }, BG_SELECTOR_BASE = "addon-backgrounds", GRID_SELECTOR_BASE = "addon-backgrounds-grid", transitionStyle = isReduceMotionEnabled() ? "" : "transition: background-color 0.3s;", withBackgroundAndGrid = (StoryFn, context) => {
    let { globals = {}, parameters: parameters2 = {}, viewMode, id: id2 } = context, {
      options = DEFAULT_BACKGROUNDS,
      disable,
      grid = defaultGrid
    } = parameters2[PARAM_KEY] || {}, data = globals[PARAM_KEY] || {}, backgroundName = typeof data == "string" ? data : data?.value, item = backgroundName ? options[backgroundName] : void 0, value2 = typeof item == "string" ? item : item?.value || "transparent", showGrid = typeof data == "string" ? !1 : data.grid || !1, shownBackground = !!item && !disable, backgroundSelector = viewMode === "docs" ? `#anchor--${id2} .docs-story` : ".sb-show-main", gridSelector = viewMode === "docs" ? `#anchor--${id2} .docs-story` : ".sb-show-main", isLayoutPadded = parameters2.layout === void 0 || parameters2.layout === "padded", defaultOffset = viewMode === "docs" ? 20 : isLayoutPadded ? 16 : 0, { cellAmount, cellSize, opacity, offsetX = defaultOffset, offsetY = defaultOffset } = grid, backgroundSelectorId = viewMode === "docs" ? `${BG_SELECTOR_BASE}-docs-${id2}` : `${BG_SELECTOR_BASE}-color`, backgroundTarget = viewMode === "docs" ? id2 : null;
    useEffect2(() => {
      let backgroundStyles = `
    ${backgroundSelector} {
      background: ${value2} !important;
      ${transitionStyle}
      }`;
      if (!shownBackground) {
        clearStyles(backgroundSelectorId);
        return;
      }
      addBackgroundStyle(backgroundSelectorId, backgroundStyles, backgroundTarget);
    }, [backgroundSelector, backgroundSelectorId, backgroundTarget, shownBackground, value2]);
    let gridSelectorId = viewMode === "docs" ? `${GRID_SELECTOR_BASE}-docs-${id2}` : `${GRID_SELECTOR_BASE}`;
    return useEffect2(() => {
      if (!showGrid) {
        clearStyles(gridSelectorId);
        return;
      }
      let gridSize = [
        `${cellSize * cellAmount}px ${cellSize * cellAmount}px`,
        `${cellSize * cellAmount}px ${cellSize * cellAmount}px`,
        `${cellSize}px ${cellSize}px`,
        `${cellSize}px ${cellSize}px`
      ].join(", "), gridStyles = `
        ${gridSelector} {
          background-size: ${gridSize} !important;
          background-position: ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px !important;
          background-blend-mode: difference !important;
          background-image: linear-gradient(rgba(130, 130, 130, ${opacity}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${opacity}) 1px, transparent 1px),
           linear-gradient(rgba(130, 130, 130, ${opacity / 2}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${opacity / 2}) 1px, transparent 1px) !important;
        }
      `;
      addGridStyle(gridSelectorId, gridStyles);
    }, [cellAmount, cellSize, gridSelector, gridSelectorId, showGrid, offsetX, offsetY, opacity]), StoryFn();
  }, decorators = globalThis.FEATURES?.backgrounds ? [withBackgroundAndGrid] : [], parameters = {
    [PARAM_KEY]: {
      grid: {
        cellSize: 20,
        opacity: 0.5,
        cellAmount: 5
      },
      disable: !1
    }
  }, initialGlobals = {
    [PARAM_KEY]: { value: void 0, grid: !1 }
  };
  var { step } = instrument(
    {
      // It seems like the label is unused, but the instrumenter has access to it
      // The context will be bounded later in StoryRender, so that the user can write just:
      // await step("label", (context) => {
      //   // labeled step
      // });
      step: async (label, play, context) => play(context)
    },
    { intercept: !0 }
  );
  var iconPaths = {
    chevronLeft: [
      "M9.10355 10.1464C9.29882 10.3417 9.29882 10.6583 9.10355 10.8536C8.90829 11.0488 8.59171 11.0488 8.39645 10.8536L4.89645 7.35355C4.70118 7.15829 4.70118 6.84171 4.89645 6.64645L8.39645 3.14645C8.59171 2.95118 8.90829 2.95118 9.10355 3.14645C9.29882 3.34171 9.29882 3.65829 9.10355 3.85355L5.95711 7L9.10355 10.1464Z"
    ],
    chevronRight: [
      "M4.89645 10.1464C4.70118 10.3417 4.70118 10.6583 4.89645 10.8536C5.09171 11.0488 5.40829 11.0488 5.60355 10.8536L9.10355 7.35355C9.29882 7.15829 9.29882 6.84171 9.10355 6.64645L5.60355 3.14645C5.40829 2.95118 5.09171 2.95118 4.89645 3.14645C4.70118 3.34171 4.70118 3.65829 4.89645 3.85355L8.04289 7L4.89645 10.1464Z"
    ],
    info: [
      "M7 5.5a.5.5 0 01.5.5v4a.5.5 0 01-1 0V6a.5.5 0 01.5-.5zM7 4.5A.75.75 0 107 3a.75.75 0 000 1.5z",
      "M7 14A7 7 0 107 0a7 7 0 000 14zm0-1A6 6 0 107 1a6 6 0 000 12z"
    ],
    shareAlt: [
      "M2 1.004a1 1 0 00-1 1v10a1 1 0 001 1h10a1 1 0 001-1v-4.5a.5.5 0 00-1 0v4.5H2v-10h4.5a.5.5 0 000-1H2z",
      "M7.354 7.357L12 2.711v1.793a.5.5 0 001 0v-3a.5.5 0 00-.5-.5h-3a.5.5 0 100 1h1.793L6.646 6.65a.5.5 0 10.708.707z"
    ]
  }, svgElements = "svg,path,rect,circle,line,polyline,polygon,ellipse,text".split(","), createElement2 = (type, props = {}, children) => {
    let element = svgElements.includes(type) ? document.createElementNS("http://www.w3.org/2000/svg", type) : document.createElement(type);
    return Object.entries(props).forEach(([key, val]) => {
      /[A-Z]/.test(key) ? (key === "onClick" && (element.addEventListener("click", val), element.addEventListener("keydown", (e) => {
        (e.key === "Enter" || e.key === " ") && (e.preventDefault(), val());
      })), key === "onMouseEnter" && element.addEventListener("mouseenter", val), key === "onMouseLeave" && element.addEventListener("mouseleave", val)) : element.setAttribute(key, val);
    }), children?.forEach((child) => {
      if (!(child == null || child === !1))
        try {
          element.appendChild(child);
        } catch {
          element.appendChild(document.createTextNode(String(child)));
        }
    }), element;
  }, createIcon = (name) => iconPaths[name] && createElement2(
    "svg",
    { width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" },
    iconPaths[name].map(
      (d3) => createElement2("path", {
        fill: "currentColor",
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: d3
      })
    )
  ), normalizeOptions = (options) => {
    if ("elements" in options) {
      let { elements, color: color2, style } = options;
      return {
        id: void 0,
        priority: 0,
        selectors: elements,
        styles: {
          outline: `2px ${style} ${color2}`,
          outlineOffset: "2px",
          boxShadow: "0 0 0 6px rgba(255,255,255,0.6)"
        },
        menu: void 0
      };
    }
    let { menu, ...rest } = options;
    return {
      id: void 0,
      priority: 0,
      styles: {
        outline: "2px dashed #029cfd"
      },
      ...rest,
      menu: Array.isArray(menu) ? menu.every(Array.isArray) ? menu : [menu] : void 0
    };
  }, isFunction = (obj) => obj instanceof Function, state = /* @__PURE__ */ new Map(), listeners = /* @__PURE__ */ new Map(), teardowns = /* @__PURE__ */ new Map(), useStore = (initialValue) => {
    let key = /* @__PURE__ */ Symbol();
    return listeners.set(key, []), state.set(key, initialValue), { get: () => state.get(key), set: (update) => {
      let current = state.get(key), next = isFunction(update) ? update(current) : update;
      next !== current && (state.set(key, next), listeners.get(key)?.forEach((listener) => {
        teardowns.get(listener)?.(), teardowns.set(listener, listener(next));
      }));
    }, subscribe: (listener) => (listeners.get(key)?.push(listener), () => {
      let list = listeners.get(key);
      list && listeners.set(
        key,
        list.filter((l2) => l2 !== listener)
      );
    }), teardown: () => {
      listeners.get(key)?.forEach((listener) => {
        teardowns.get(listener)?.(), teardowns.delete(listener);
      }), listeners.delete(key), state.delete(key);
    } };
  }, mapElements = (highlights) => {
    let root = document.getElementById("storybook-root"), map = /* @__PURE__ */ new Map();
    for (let highlight2 of highlights) {
      let { priority = 0 } = highlight2;
      for (let selector of highlight2.selectors) {
        let elements = [
          ...document.querySelectorAll(
            // Elements matching the selector, excluding storybook elements and their descendants.
            // Necessary to find portaled elements (e.g. children of `body`).
            `:is(${selector}):not([id^="storybook-"], [id^="storybook-"] *, [class^="sb-"], [class^="sb-"] *)`
          ),
          // Elements matching the selector inside the storybook root, as these were excluded above.
          ...root?.querySelectorAll(selector) || []
        ];
        for (let element of elements) {
          let existing = map.get(element);
          (!existing || existing.priority <= priority) && map.set(element, {
            ...highlight2,
            priority,
            selectors: Array.from(new Set((existing?.selectors || []).concat(selector)))
          });
        }
      }
    }
    return map;
  }, mapBoxes = (elements) => Array.from(elements.entries()).map(([element, { selectors, styles: styles2, hoverStyles, focusStyles, menu }]) => {
    let { top, left, width, height } = element.getBoundingClientRect(), { position } = getComputedStyle(element);
    return {
      element,
      selectors,
      styles: styles2,
      hoverStyles,
      focusStyles,
      menu,
      top: position === "fixed" ? top : top + window.scrollY,
      left: position === "fixed" ? left : left + window.scrollX,
      width,
      height
    };
  }).sort((a3, b3) => b3.width * b3.height - a3.width * a3.height), isOverMenu = (menuElement, coordinates) => {
    let menu = menuElement.getBoundingClientRect(), { x: x3, y: y3 } = coordinates;
    return menu?.top && menu?.left && x3 >= menu.left && x3 <= menu.left + menu.width && y3 >= menu.top && y3 <= menu.top + menu.height;
  }, isTargeted = (box, boxElement, coordinates) => {
    if (!boxElement || !coordinates)
      return !1;
    let { left, top, width, height } = box;
    height < MIN_TOUCH_AREA_SIZE && (top = top - Math.round((MIN_TOUCH_AREA_SIZE - height) / 2), height = MIN_TOUCH_AREA_SIZE), width < MIN_TOUCH_AREA_SIZE && (left = left - Math.round((MIN_TOUCH_AREA_SIZE - width) / 2), width = MIN_TOUCH_AREA_SIZE), boxElement.style.position === "fixed" && (left += window.scrollX, top += window.scrollY);
    let { x: x3, y: y3 } = coordinates;
    return x3 >= left && x3 <= left + width && y3 >= top && y3 <= top + height;
  }, keepInViewport = (element, targetCoordinates, options = {}) => {
    let { x: x3, y: y3 } = targetCoordinates, { margin = 5, topOffset = 0, centered = !1 } = options, { scrollX, scrollY, innerHeight: windowHeight, innerWidth: windowWidth } = window, top = Math.min(
      element.style.position === "fixed" ? y3 - scrollY : y3,
      windowHeight - element.clientHeight - margin - topOffset + scrollY
    ), leftOffset = centered ? element.clientWidth / 2 : 0, left = element.style.position === "fixed" ? Math.max(Math.min(x3 - scrollX, windowWidth - leftOffset - margin), leftOffset + margin) : Math.max(
      Math.min(x3, windowWidth - leftOffset - margin + scrollX),
      leftOffset + margin + scrollX
    );
    Object.assign(element.style, {
      ...left !== x3 && { left: `${left}px` },
      ...top !== y3 && { top: `${top}px` }
    });
  }, showPopover = (element) => {
    window.HTMLElement.prototype.hasOwnProperty("showPopover") && element.showPopover();
  }, hidePopover = (element) => {
    window.HTMLElement.prototype.hasOwnProperty("showPopover") && element.hidePopover();
  }, getEventDetails = (target) => ({
    top: target.top,
    left: target.left,
    width: target.width,
    height: target.height,
    selectors: target.selectors,
    element: {
      attributes: Object.fromEntries(
        Array.from(target.element.attributes).map((attr) => [attr.name, attr.value])
      ),
      localName: target.element.localName,
      tagName: target.element.tagName,
      outerHTML: target.element.outerHTML
    }
  }), menuId = "storybook-highlights-menu", rootId = "storybook-highlights-root", storybookRootId = "storybook-root", useHighlights = (channel) => {
    if (globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED)
      return;
    globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED = !0;
    let { document: document32 } = globalThis, highlights = useStore([]), elements = useStore(/* @__PURE__ */ new Map()), boxes = useStore([]), clickCoords = useStore(), hoverCoords = useStore(), targets = useStore([]), hovered = useStore([]), focused = useStore(), selected = useStore(), root = document32.getElementById(rootId);
    highlights.subscribe(() => {
      root || (root = createElement2("div", { id: rootId }), document32.body.appendChild(root));
    }), highlights.subscribe((value2) => {
      let storybookRoot = document32.getElementById(storybookRootId);
      if (!storybookRoot)
        return;
      elements.set(mapElements(value2));
      let observer = new MutationObserver(() => elements.set(mapElements(value2)));
      return observer.observe(storybookRoot, { subtree: !0, childList: !0 }), () => {
        observer.disconnect();
      };
    }), elements.subscribe((value2) => {
      let updateBoxes = () => requestAnimationFrame(() => boxes.set(mapBoxes(value2))), observer = new ResizeObserver(updateBoxes);
      observer.observe(document32.body), Array.from(value2.keys()).forEach((element) => observer.observe(element));
      let scrollers = Array.from(document32.body.querySelectorAll("*")).filter((el) => {
        let { overflow, overflowX, overflowY } = window.getComputedStyle(el);
        return ["auto", "scroll"].some((o2) => [overflow, overflowX, overflowY].includes(o2));
      });
      return scrollers.forEach((element) => element.addEventListener("scroll", updateBoxes)), () => {
        observer.disconnect(), scrollers.forEach((element) => element.removeEventListener("scroll", updateBoxes));
      };
    }), elements.subscribe((value2) => {
      let sticky = Array.from(value2.keys()).filter(({ style }) => style.position === "sticky"), updateBoxes = () => requestAnimationFrame(() => {
        boxes.set(
          (current) => current.map((box) => {
            if (sticky.includes(box.element)) {
              let { top, left } = box.element.getBoundingClientRect();
              return { ...box, top: top + window.scrollY, left: left + window.scrollX };
            }
            return box;
          })
        );
      });
      return document32.addEventListener("scroll", updateBoxes), () => document32.removeEventListener("scroll", updateBoxes);
    }), elements.subscribe((value2) => {
      targets.set((t) => t.filter(({ element }) => value2.has(element)));
    }), targets.subscribe((value2) => {
      value2.length ? (selected.set((s4) => value2.some((t) => t.element === s4?.element) ? s4 : void 0), focused.set((s4) => value2.some((t) => t.element === s4?.element) ? s4 : void 0)) : (selected.set(void 0), focused.set(void 0), clickCoords.set(void 0));
    });
    let styleElementByHighlight = new Map(/* @__PURE__ */ new Map());
    highlights.subscribe((value2) => {
      value2.forEach(({ keyframes: keyframes2 }) => {
        if (keyframes2) {
          let style = styleElementByHighlight.get(keyframes2);
          style || (style = document32.createElement("style"), style.setAttribute("data-highlight", "keyframes"), styleElementByHighlight.set(keyframes2, style), document32.head.appendChild(style)), style.innerHTML = keyframes2;
        }
      }), styleElementByHighlight.forEach((style, keyframes2) => {
        value2.some((v3) => v3.keyframes === keyframes2) || (style.remove(), styleElementByHighlight.delete(keyframes2));
      });
    });
    let boxElementByTargetElement = new Map(/* @__PURE__ */ new Map());
    boxes.subscribe((value2) => {
      value2.forEach((box) => {
        let boxElement = boxElementByTargetElement.get(box.element);
        if (root && !boxElement) {
          let props = {
            popover: "manual",
            "data-highlight-dimensions": `w${box.width.toFixed(0)}h${box.height.toFixed(0)}`,
            "data-highlight-coordinates": `x${box.left.toFixed(0)}y${box.top.toFixed(0)}`
          };
          boxElement = root.appendChild(
            createElement2("div", props, [createElement2("div")])
          ), boxElementByTargetElement.set(box.element, boxElement);
        }
      }), boxElementByTargetElement.forEach((box, element) => {
        value2.some(({ element: e }) => e === element) || (box.remove(), boxElementByTargetElement.delete(element));
      });
    }), boxes.subscribe((value2) => {
      let targetable = value2.filter((box) => box.menu);
      if (!targetable.length)
        return;
      let onClick = (event) => {
        requestAnimationFrame(() => {
          let menu = document32.getElementById(menuId), coords = { x: event.pageX, y: event.pageY };
          if (menu && !isOverMenu(menu, coords)) {
            let results = targetable.filter((box) => {
              let boxElement = boxElementByTargetElement.get(box.element);
              return isTargeted(box, boxElement, coords);
            });
            clickCoords.set(results.length ? coords : void 0), targets.set(results);
          }
        });
      };
      return document32.addEventListener("click", onClick), () => document32.removeEventListener("click", onClick);
    });
    let updateHovered = () => {
      let menu = document32.getElementById(menuId), coords = hoverCoords.get();
      !coords || menu && isOverMenu(menu, coords) || hovered.set((current) => {
        let update = boxes.get().filter((box) => {
          let boxElement = boxElementByTargetElement.get(box.element);
          return isTargeted(box, boxElement, coords);
        }), existing = current.filter((box) => update.includes(box)), additions = update.filter((box) => !current.includes(box)), hasRemovals = current.length - existing.length;
        return additions.length || hasRemovals ? [...existing, ...additions] : current;
      });
    };
    hoverCoords.subscribe(updateHovered), boxes.subscribe(updateHovered);
    let updateBoxStyles = () => {
      let selectedElement = selected.get(), targetElements = selectedElement ? [selectedElement] : targets.get(), focusedElement = targetElements.length === 1 ? targetElements[0] : focused.get(), isMenuOpen = clickCoords.get() !== void 0;
      boxes.get().forEach((box) => {
        let boxElement = boxElementByTargetElement.get(box.element);
        if (boxElement) {
          let isFocused = focusedElement === box, isHovered = isMenuOpen ? focusedElement ? isFocused : targetElements.includes(box) : hovered.get()?.includes(box);
          Object.assign(boxElement.style, {
            animation: "none",
            background: "transparent",
            border: "none",
            boxSizing: "border-box",
            outline: "none",
            outlineOffset: "0px",
            ...box.styles,
            ...isHovered ? box.hoverStyles : {},
            ...isFocused ? box.focusStyles : {},
            position: getComputedStyle(box.element).position === "fixed" ? "fixed" : "absolute",
            zIndex: MAX_Z_INDEX - 10,
            top: `${box.top}px`,
            left: `${box.left}px`,
            width: `${box.width}px`,
            height: `${box.height}px`,
            margin: 0,
            padding: 0,
            cursor: box.menu && isHovered ? "pointer" : "default",
            pointerEvents: box.menu ? "auto" : "none",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            overflow: "visible"
          }), Object.assign(boxElement.children[0].style, {
            width: "100%",
            height: "100%",
            minHeight: `${MIN_TOUCH_AREA_SIZE}px`,
            minWidth: `${MIN_TOUCH_AREA_SIZE}px`,
            boxSizing: "content-box",
            padding: boxElement.style.outlineWidth || "0px"
          }), showPopover(boxElement);
        }
      });
    };
    boxes.subscribe(updateBoxStyles), targets.subscribe(updateBoxStyles), hovered.subscribe(updateBoxStyles), focused.subscribe(updateBoxStyles), selected.subscribe(updateBoxStyles);
    let renderMenu = () => {
      if (!root)
        return;
      let menu = document32.getElementById(menuId);
      if (menu)
        menu.innerHTML = "";
      else {
        let props = { id: menuId, popover: "manual" };
        menu = root.appendChild(createElement2("div", props)), root.appendChild(
          createElement2("style", {}, [
            `
            #${menuId} {
              position: absolute;
              z-index: ${MAX_Z_INDEX};
              width: 300px;
              padding: 0px;
              margin: 15px 0 0 0;
              transform: translateX(-50%);
              font-family: "Nunito Sans", -apple-system, ".SFNSText-Regular", "San Francisco", BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
              font-size: 12px;
              background: white;
              border: none;
              border-radius: 6px;
              box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.05), 0 5px 15px 0 rgba(0, 0, 0, 0.1);
              color: #2E3438;
            }
            #${menuId} ul {
              list-style: none;
              margin: 0;
              padding: 0;
            }
            #${menuId} > ul {
              max-height: 300px;
              overflow-y: auto;
              padding: 4px 0;
            }
            #${menuId} li {
              padding: 0 4px;
              margin: 0;
            }
            #${menuId} li > :not(ul) {
              display: flex;
              padding: 8px;
              margin: 0;
              align-items: center;
              gap: 8px;
              border-radius: 4px;
            }
            #${menuId} button {
              width: 100%;
              border: 0;
              background: transparent;
              color: inherit;
              text-align: left;
              font-family: inherit;
              font-size: inherit;
            }
            #${menuId} button:focus-visible {
              outline-color: #029CFD;
            }
            #${menuId} button:hover {
              background: rgba(2, 156, 253, 0.07);
              color: #029CFD;
              cursor: pointer;
            }
            #${menuId} li code {
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
              line-height: 16px;
              font-size: 11px;
            }
            #${menuId} li svg {
              flex-shrink: 0;
              margin: 1px;
              color: #73828C;
            }
            #${menuId} li > button:hover svg, #${menuId} li > button:focus-visible svg {
              color: #029CFD;
            }
            #${menuId} .element-list li svg {
              display: none;
            }
            #${menuId} li.selectable svg, #${menuId} li.selected svg {
              display: block;
            }
            #${menuId} .menu-list {
              border-top: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${menuId} .menu-list > li:not(:last-child) {
              padding-bottom: 4px;
              margin-bottom: 4px;
              border-bottom: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${menuId} .menu-items, #${menuId} .menu-items li {
              padding: 0;
            }
            #${menuId} .menu-item {
              display: flex;
            }
            #${menuId} .menu-item-content {
              display: flex;
              flex-direction: column;
              flex-grow: 1;
            }
          `
          ])
        );
      }
      let selectedElement = selected.get(), elementList = selectedElement ? [selectedElement] : targets.get();
      if (elementList.length && (menu.style.position = getComputedStyle(elementList[0].element).position === "fixed" ? "fixed" : "absolute", menu.appendChild(
        createElement2(
          "ul",
          { class: "element-list" },
          elementList.map((target) => {
            let selectable = elementList.length > 1 && !!target.menu?.some(
              (group) => group.some(
                (item) => !item.selectors || item.selectors.some((s4) => target.selectors.includes(s4))
              )
            ), props = selectable ? {
              class: "selectable",
              onClick: () => selected.set(target),
              onMouseEnter: () => focused.set(target),
              onMouseLeave: () => focused.set(void 0)
            } : selectedElement ? { class: "selected", onClick: () => selected.set(void 0) } : {}, asButton = selectable || selectedElement;
            return createElement2("li", props, [
              createElement2(asButton ? "button" : "div", asButton ? { type: "button" } : {}, [
                selectedElement ? createIcon("chevronLeft") : null,
                createElement2("code", {}, [target.element.outerHTML]),
                selectable ? createIcon("chevronRight") : null
              ])
            ]);
          })
        )
      )), selected.get() || targets.get().length === 1) {
        let target = selected.get() || targets.get()[0], menuGroups = target.menu?.filter(
          (group) => group.some(
            (item) => !item.selectors || item.selectors.some((s4) => target.selectors.includes(s4))
          )
        );
        menuGroups?.length && menu.appendChild(
          createElement2(
            "ul",
            { class: "menu-list" },
            menuGroups.map(
              (menuItems) => createElement2("li", {}, [
                createElement2(
                  "ul",
                  { class: "menu-items" },
                  menuItems.map(
                    ({ id: id2, title, description, iconLeft, iconRight, clickEvent: event }) => {
                      let onClick = event && (() => channel.emit(event, id2, getEventDetails(target)));
                      return createElement2("li", {}, [
                        createElement2(
                          onClick ? "button" : "div",
                          onClick ? { class: "menu-item", type: "button", onClick } : { class: "menu-item" },
                          [
                            iconLeft ? createIcon(iconLeft) : null,
                            createElement2("div", { class: "menu-item-content" }, [
                              createElement2(description ? "strong" : "span", {}, [title]),
                              description && createElement2("span", {}, [description])
                            ]),
                            iconRight ? createIcon(iconRight) : null
                          ]
                        )
                      ]);
                    }
                  )
                )
              ])
            )
          )
        );
      }
      let coords = clickCoords.get();
      coords ? (Object.assign(menu.style, {
        display: "block",
        left: `${menu.style.position === "fixed" ? coords.x - window.scrollX : coords.x}px`,
        top: `${menu.style.position === "fixed" ? coords.y - window.scrollY : coords.y}px`
      }), showPopover(menu), requestAnimationFrame(() => keepInViewport(menu, coords, { topOffset: 15, centered: !0 }))) : (hidePopover(menu), Object.assign(menu.style, { display: "none" }));
    };
    targets.subscribe(renderMenu), selected.subscribe(renderMenu);
    let addHighlight = (highlight2) => {
      let info = normalizeOptions(highlight2);
      highlights.set((value2) => {
        let others = info.id ? value2.filter((h4) => h4.id !== info.id) : value2;
        return info.selectors?.length ? [...others, info] : others;
      });
    }, removeHighlight = (id2) => {
      id2 && highlights.set((value2) => value2.filter((h4) => h4.id !== id2));
    }, resetState = () => {
      highlights.set([]), elements.set(/* @__PURE__ */ new Map()), boxes.set([]), clickCoords.set(void 0), hoverCoords.set(void 0), targets.set([]), hovered.set([]), focused.set(void 0), selected.set(void 0);
    }, removeTimeout, scrollIntoView = (target, options) => {
      let id2 = "scrollIntoView-highlight";
      clearTimeout(removeTimeout), removeHighlight(id2);
      let element = document32.querySelector(target);
      if (!element) {
        console.warn(`Cannot scroll into view: ${target} not found`);
        return;
      }
      element.scrollIntoView({ behavior: "smooth", block: "center", ...options });
      let keyframeName = `kf-${Math.random().toString(36).substring(2, 15)}`;
      highlights.set((value2) => [
        ...value2,
        {
          id: id2,
          priority: 1e3,
          selectors: [target],
          styles: {
            outline: "2px solid #1EA7FD",
            outlineOffset: "-1px",
            animation: `${keyframeName} 3s linear forwards`
          },
          keyframes: `@keyframes ${keyframeName} {
          0% { outline: 2px solid #1EA7FD; }
          20% { outline: 2px solid #1EA7FD00; }
          40% { outline: 2px solid #1EA7FD; }
          60% { outline: 2px solid #1EA7FD00; }
          80% { outline: 2px solid #1EA7FD; }
          100% { outline: 2px solid #1EA7FD00; }
        }`
        }
      ]), removeTimeout = setTimeout(() => removeHighlight(id2), 3500);
    }, onMouseMove = (event) => {
      requestAnimationFrame(() => hoverCoords.set({ x: event.pageX, y: event.pageY }));
    };
    document32.body.addEventListener("mousemove", onMouseMove), channel.on(HIGHLIGHT, addHighlight), channel.on(REMOVE_HIGHLIGHT, removeHighlight), channel.on(RESET_HIGHLIGHT, resetState), channel.on(SCROLL_INTO_VIEW, scrollIntoView), channel.on(STORY_RENDER_PHASE_CHANGED, ({ newPhase }) => {
      newPhase === "loading" && resetState();
    });
  };
  globalThis?.FEATURES?.highlight && addons2?.ready && addons2.ready().then(useHighlights);
  function getDocumentWidthAndHeight() {
    let container = scope.document.documentElement, height = Math.max(container.scrollHeight, container.offsetHeight);
    return { width: Math.max(container.scrollWidth, container.offsetWidth), height };
  }
  function createCanvas() {
    let canvas = scope.document.createElement("canvas");
    canvas.id = "storybook-addon-measure";
    let context = canvas.getContext("2d");
    invariant(context != null);
    let { width, height } = getDocumentWidthAndHeight();
    return setCanvasWidthAndHeight(canvas, context, { width, height }), canvas.style.position = "absolute", canvas.style.left = "0", canvas.style.top = "0", canvas.style.zIndex = "2147483647", canvas.style.pointerEvents = "none", scope.document.body.appendChild(canvas), { canvas, context, width, height };
  }
  function setCanvasWidthAndHeight(canvas, context, { width, height }) {
    canvas.style.width = `${width}px`, canvas.style.height = `${height}px`;
    let scale = scope.window.devicePixelRatio;
    canvas.width = Math.floor(width * scale), canvas.height = Math.floor(height * scale), context.scale(scale, scale);
  }
  var state2 = {};
  function init() {
    state2.canvas || (state2 = createCanvas());
  }
  function clear() {
    state2.context && state2.context.clearRect(0, 0, state2.width ?? 0, state2.height ?? 0);
  }
  function draw(callback) {
    clear(), callback(state2.context);
  }
  function rescale() {
    invariant(state2.canvas, "Canvas should exist in the state."), invariant(state2.context, "Context should exist in the state."), setCanvasWidthAndHeight(state2.canvas, state2.context, { width: 0, height: 0 });
    let { width, height } = getDocumentWidthAndHeight();
    setCanvasWidthAndHeight(state2.canvas, state2.context, { width, height }), state2.width = width, state2.height = height;
  }
  function destroy() {
    state2.canvas && (clear(), state2.canvas.parentNode?.removeChild(state2.canvas), state2 = {});
  }
  var colors = {
    margin: "#f6b26b",
    border: "#ffe599",
    padding: "#93c47d",
    content: "#6fa8dc",
    text: "#232020"
  }, labelPadding = 6;
  function roundedRect(context, { x: x3, y: y3, w: w3, h: h4, r: r2 }) {
    x3 = x3 - w3 / 2, y3 = y3 - h4 / 2, w3 < 2 * r2 && (r2 = w3 / 2), h4 < 2 * r2 && (r2 = h4 / 2), context.beginPath(), context.moveTo(x3 + r2, y3), context.arcTo(x3 + w3, y3, x3 + w3, y3 + h4, r2), context.arcTo(x3 + w3, y3 + h4, x3, y3 + h4, r2), context.arcTo(x3, y3 + h4, x3, y3, r2), context.arcTo(x3, y3, x3 + w3, y3, r2), context.closePath();
  }
  function positionCoordinate(position, { padding, border, width, height, top, left }) {
    let contentWidth = width - border.left - border.right - padding.left - padding.right, contentHeight = height - padding.top - padding.bottom - border.top - border.bottom, x3 = left + border.left + padding.left, y3 = top + border.top + padding.top;
    return position === "top" ? x3 += contentWidth / 2 : position === "right" ? (x3 += contentWidth, y3 += contentHeight / 2) : position === "bottom" ? (x3 += contentWidth / 2, y3 += contentHeight) : position === "left" ? y3 += contentHeight / 2 : position === "center" && (x3 += contentWidth / 2, y3 += contentHeight / 2), { x: x3, y: y3 };
  }
  function offset(type, position, { margin, border, padding }, labelPaddingSize, external) {
    let shift = (dir) => 0, offsetX = 0, offsetY = 0, locationMultiplier = external ? 1 : 0.5, labelPaddingShift = external ? labelPaddingSize * 2 : 0;
    return type === "padding" ? shift = (dir) => padding[dir] * locationMultiplier + labelPaddingShift : type === "border" ? shift = (dir) => padding[dir] + border[dir] * locationMultiplier + labelPaddingShift : type === "margin" && (shift = (dir) => padding[dir] + border[dir] + margin[dir] * locationMultiplier + labelPaddingShift), position === "top" ? offsetY = -shift("top") : position === "right" ? offsetX = shift("right") : position === "bottom" ? offsetY = shift("bottom") : position === "left" && (offsetX = -shift("left")), { offsetX, offsetY };
  }
  function collide(a3, b3) {
    return Math.abs(a3.x - b3.x) < Math.abs(a3.w + b3.w) / 2 && Math.abs(a3.y - b3.y) < Math.abs(a3.h + b3.h) / 2;
  }
  function overlapAdjustment(position, currentRect, prevRect) {
    return position === "top" ? currentRect.y = prevRect.y - prevRect.h - labelPadding : position === "right" ? currentRect.x = prevRect.x + prevRect.w / 2 + labelPadding + currentRect.w / 2 : position === "bottom" ? currentRect.y = prevRect.y + prevRect.h + labelPadding : position === "left" && (currentRect.x = prevRect.x - prevRect.w / 2 - labelPadding - currentRect.w / 2), { x: currentRect.x, y: currentRect.y };
  }
  function textWithRect(context, type, { x: x3, y: y3, w: w3, h: h4 }, text) {
    return roundedRect(context, { x: x3, y: y3, w: w3, h: h4, r: 3 }), context.fillStyle = `${colors[type]}dd`, context.fill(), context.strokeStyle = colors[type], context.stroke(), context.fillStyle = colors.text, context.fillText(text, x3, y3), roundedRect(context, { x: x3, y: y3, w: w3, h: h4, r: 3 }), context.fillStyle = `${colors[type]}dd`, context.fill(), context.strokeStyle = colors[type], context.stroke(), context.fillStyle = colors.text, context.fillText(text, x3, y3), { x: x3, y: y3, w: w3, h: h4 };
  }
  function configureText(context, text) {
    context.font = "600 12px monospace", context.textBaseline = "middle", context.textAlign = "center";
    let metrics = context.measureText(text), actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent, w3 = metrics.width + labelPadding * 2, h4 = actualHeight + labelPadding * 2;
    return { w: w3, h: h4 };
  }
  function drawLabel(context, measurements, { type, position = "center", text }, prevRect, external = !1) {
    let { x: x3, y: y3 } = positionCoordinate(position, measurements), { offsetX, offsetY } = offset(type, position, measurements, labelPadding + 1, external);
    x3 += offsetX, y3 += offsetY;
    let { w: w3, h: h4 } = configureText(context, text);
    if (prevRect && collide({ x: x3, y: y3, w: w3, h: h4 }, prevRect)) {
      let adjusted = overlapAdjustment(position, { x: x3, y: y3, w: w3, h: h4 }, prevRect);
      x3 = adjusted.x, y3 = adjusted.y;
    }
    return textWithRect(context, type, { x: x3, y: y3, w: w3, h: h4 }, text);
  }
  function floatingOffset(alignment, { w: w3, h: h4 }) {
    let deltaW = w3 * 0.5 + labelPadding, deltaH = h4 * 0.5 + labelPadding;
    return {
      offsetX: (alignment.x === "left" ? -1 : 1) * deltaW,
      offsetY: (alignment.y === "top" ? -1 : 1) * deltaH
    };
  }
  function drawFloatingLabel(context, measurements, { type, text }) {
    let { floatingAlignment: floatingAlignment2, extremities } = measurements, x3 = extremities[floatingAlignment2.x], y3 = extremities[floatingAlignment2.y], { w: w3, h: h4 } = configureText(context, text), { offsetX, offsetY } = floatingOffset(floatingAlignment2, {
      w: w3,
      h: h4
    });
    return x3 += offsetX, y3 += offsetY, textWithRect(context, type, { x: x3, y: y3, w: w3, h: h4 }, text);
  }
  function drawStack(context, measurements, stack, external) {
    let rects = [];
    stack.forEach((l2, idx) => {
      let rect = external && l2.position === "center" ? drawFloatingLabel(context, measurements, l2) : drawLabel(context, measurements, l2, rects[idx - 1], external);
      rects[idx] = rect;
    });
  }
  function labelStacks(context, measurements, labels, externalLabels) {
    let stacks = labels.reduce((acc, l2) => (Object.prototype.hasOwnProperty.call(acc, l2.position) || (acc[l2.position] = []), acc[l2.position]?.push(l2), acc), {});
    stacks.top && drawStack(context, measurements, stacks.top, externalLabels), stacks.right && drawStack(context, measurements, stacks.right, externalLabels), stacks.bottom && drawStack(context, measurements, stacks.bottom, externalLabels), stacks.left && drawStack(context, measurements, stacks.left, externalLabels), stacks.center && drawStack(context, measurements, stacks.center, externalLabels);
  }
  var colors2 = {
    margin: "#f6b26ba8",
    border: "#ffe599a8",
    padding: "#93c47d8c",
    content: "#6fa8dca8"
  }, SMALL_NODE_SIZE = 30;
  function pxToNumber(px) {
    return parseInt(px.replace("px", ""), 10);
  }
  function round(value2) {
    return Number.isInteger(value2) ? value2 : value2.toFixed(2);
  }
  function filterZeroValues(labels) {
    return labels.filter((l2) => l2.text !== 0 && l2.text !== "0");
  }
  function floatingAlignment(extremities) {
    let windowExtremities = {
      top: scope.window.scrollY,
      bottom: scope.window.scrollY + scope.window.innerHeight,
      left: scope.window.scrollX,
      right: scope.window.scrollX + scope.window.innerWidth
    }, distances = {
      top: Math.abs(windowExtremities.top - extremities.top),
      bottom: Math.abs(windowExtremities.bottom - extremities.bottom),
      left: Math.abs(windowExtremities.left - extremities.left),
      right: Math.abs(windowExtremities.right - extremities.right)
    };
    return {
      x: distances.left > distances.right ? "left" : "right",
      y: distances.top > distances.bottom ? "top" : "bottom"
    };
  }
  function measureElement(element) {
    let style = scope.getComputedStyle(element), { top, left, right, bottom, width, height } = element.getBoundingClientRect(), {
      marginTop,
      marginBottom,
      marginLeft,
      marginRight,
      paddingTop,
      paddingBottom,
      paddingLeft,
      paddingRight,
      borderBottomWidth,
      borderTopWidth,
      borderLeftWidth,
      borderRightWidth
    } = style;
    top = top + scope.window.scrollY, left = left + scope.window.scrollX, bottom = bottom + scope.window.scrollY, right = right + scope.window.scrollX;
    let margin = {
      top: pxToNumber(marginTop),
      bottom: pxToNumber(marginBottom),
      left: pxToNumber(marginLeft),
      right: pxToNumber(marginRight)
    }, padding = {
      top: pxToNumber(paddingTop),
      bottom: pxToNumber(paddingBottom),
      left: pxToNumber(paddingLeft),
      right: pxToNumber(paddingRight)
    }, border = {
      top: pxToNumber(borderTopWidth),
      bottom: pxToNumber(borderBottomWidth),
      left: pxToNumber(borderLeftWidth),
      right: pxToNumber(borderRightWidth)
    }, extremities = {
      top: top - margin.top,
      bottom: bottom + margin.bottom,
      left: left - margin.left,
      right: right + margin.right
    };
    return {
      margin,
      padding,
      border,
      top,
      left,
      bottom,
      right,
      width,
      height,
      extremities,
      floatingAlignment: floatingAlignment(extremities)
    };
  }
  function drawMargin(context, { margin, width, height, top, left, bottom, right }) {
    let marginHeight = height + margin.bottom + margin.top;
    context.fillStyle = colors2.margin, context.fillRect(left, top - margin.top, width, margin.top), context.fillRect(right, top - margin.top, margin.right, marginHeight), context.fillRect(left, bottom, width, margin.bottom), context.fillRect(left - margin.left, top - margin.top, margin.left, marginHeight);
    let marginLabels = [
      {
        type: "margin",
        text: round(margin.top),
        position: "top"
      },
      {
        type: "margin",
        text: round(margin.right),
        position: "right"
      },
      {
        type: "margin",
        text: round(margin.bottom),
        position: "bottom"
      },
      {
        type: "margin",
        text: round(margin.left),
        position: "left"
      }
    ];
    return filterZeroValues(marginLabels);
  }
  function drawPadding(context, { padding, border, width, height, top, left, bottom, right }) {
    let paddingWidth = width - border.left - border.right, paddingHeight = height - padding.top - padding.bottom - border.top - border.bottom;
    context.fillStyle = colors2.padding, context.fillRect(left + border.left, top + border.top, paddingWidth, padding.top), context.fillRect(
      right - padding.right - border.right,
      top + padding.top + border.top,
      padding.right,
      paddingHeight
    ), context.fillRect(
      left + border.left,
      bottom - padding.bottom - border.bottom,
      paddingWidth,
      padding.bottom
    ), context.fillRect(left + border.left, top + padding.top + border.top, padding.left, paddingHeight);
    let paddingLabels = [
      {
        type: "padding",
        text: padding.top,
        position: "top"
      },
      {
        type: "padding",
        text: padding.right,
        position: "right"
      },
      {
        type: "padding",
        text: padding.bottom,
        position: "bottom"
      },
      {
        type: "padding",
        text: padding.left,
        position: "left"
      }
    ];
    return filterZeroValues(paddingLabels);
  }
  function drawBorder(context, { border, width, height, top, left, bottom, right }) {
    let borderHeight = height - border.top - border.bottom;
    context.fillStyle = colors2.border, context.fillRect(left, top, width, border.top), context.fillRect(left, bottom - border.bottom, width, border.bottom), context.fillRect(left, top + border.top, border.left, borderHeight), context.fillRect(right - border.right, top + border.top, border.right, borderHeight);
    let borderLabels = [
      {
        type: "border",
        text: border.top,
        position: "top"
      },
      {
        type: "border",
        text: border.right,
        position: "right"
      },
      {
        type: "border",
        text: border.bottom,
        position: "bottom"
      },
      {
        type: "border",
        text: border.left,
        position: "left"
      }
    ];
    return filterZeroValues(borderLabels);
  }
  function drawContent(context, { padding, border, width, height, top, left }) {
    let contentWidth = width - border.left - border.right - padding.left - padding.right, contentHeight = height - padding.top - padding.bottom - border.top - border.bottom;
    return context.fillStyle = colors2.content, context.fillRect(
      left + border.left + padding.left,
      top + border.top + padding.top,
      contentWidth,
      contentHeight
    ), [
      {
        type: "content",
        position: "center",
        text: `${round(contentWidth)} x ${round(contentHeight)}`
      }
    ];
  }
  function drawBoxModel(element) {
    return (context) => {
      if (element && context) {
        let measurements = measureElement(element), marginLabels = drawMargin(context, measurements), paddingLabels = drawPadding(context, measurements), borderLabels = drawBorder(context, measurements), contentLabels = drawContent(context, measurements), externalLabels = measurements.width <= SMALL_NODE_SIZE * 3 || measurements.height <= SMALL_NODE_SIZE;
        labelStacks(
          context,
          measurements,
          [...contentLabels, ...paddingLabels, ...borderLabels, ...marginLabels],
          externalLabels
        );
      }
    };
  }
  function drawSelectedElement(element) {
    draw(drawBoxModel(element));
  }
  var deepElementFromPoint = (x3, y3) => {
    let element = scope.document.elementFromPoint(x3, y3), crawlShadows = (node) => {
      if (node && node.shadowRoot) {
        let nestedElement = node.shadowRoot.elementFromPoint(x3, y3);
        return node.isEqualNode(nestedElement) ? node : nestedElement.shadowRoot ? crawlShadows(nestedElement) : nestedElement;
      }
      return node;
    };
    return crawlShadows(element) || element;
  }, nodeAtPointerRef, pointer = { x: 0, y: 0 };
  function findAndDrawElement(x3, y3) {
    nodeAtPointerRef = deepElementFromPoint(x3, y3), drawSelectedElement(nodeAtPointerRef);
  }
  var withMeasure = (StoryFn, context) => {
    let { measureEnabled } = context.globals || {};
    return useEffect2(() => {
      if (typeof globalThis.document > "u")
        return;
      let onPointerMove = (event) => {
        window.requestAnimationFrame(() => {
          event.stopPropagation(), pointer.x = event.clientX, pointer.y = event.clientY;
        });
      };
      return globalThis.document.addEventListener("pointermove", onPointerMove), () => {
        globalThis.document.removeEventListener("pointermove", onPointerMove);
      };
    }, []), useEffect2(() => {
      let onPointerOver = (event) => {
        window.requestAnimationFrame(() => {
          event.stopPropagation(), findAndDrawElement(event.clientX, event.clientY);
        });
      }, onResize = () => {
        window.requestAnimationFrame(() => {
          rescale();
        });
      };
      return context.viewMode === "story" && measureEnabled && (globalThis.document.addEventListener("pointerover", onPointerOver), init(), globalThis.window.addEventListener("resize", onResize), findAndDrawElement(pointer.x, pointer.y)), () => {
        globalThis.window.removeEventListener("resize", onResize), destroy();
      };
    }, [measureEnabled, context.viewMode]), StoryFn();
  }, decorators2 = globalThis.FEATURES?.measure ? [withMeasure] : [], initialGlobals2 = {
    [PARAM_KEY2]: !1
  };
  var clearStyles2 = (selector) => {
    (Array.isArray(selector) ? selector : [selector]).forEach(clearStyle2);
  }, clearStyle2 = (input) => {
    let selector = typeof input == "string" ? input : input.join(""), element = scope.document.getElementById(selector);
    element && element.parentElement && element.parentElement.removeChild(element);
  }, addOutlineStyles = (selector, css2) => {
    let existingStyle = scope.document.getElementById(selector);
    if (existingStyle)
      existingStyle.innerHTML !== css2 && (existingStyle.innerHTML = css2);
    else {
      let style = scope.document.createElement("style");
      style.setAttribute("id", selector), style.innerHTML = css2, scope.document.head.appendChild(style);
    }
  };
  function outlineCSS(selector) {
    return dedent`
    ${selector} body {
      outline: 1px solid #2980b9 !important;
    }

    ${selector} article {
      outline: 1px solid #3498db !important;
    }

    ${selector} nav {
      outline: 1px solid #0088c3 !important;
    }

    ${selector} aside {
      outline: 1px solid #33a0ce !important;
    }

    ${selector} section {
      outline: 1px solid #66b8da !important;
    }

    ${selector} header {
      outline: 1px solid #99cfe7 !important;
    }

    ${selector} footer {
      outline: 1px solid #cce7f3 !important;
    }

    ${selector} h1 {
      outline: 1px solid #162544 !important;
    }

    ${selector} h2 {
      outline: 1px solid #314e6e !important;
    }

    ${selector} h3 {
      outline: 1px solid #3e5e85 !important;
    }

    ${selector} h4 {
      outline: 1px solid #449baf !important;
    }

    ${selector} h5 {
      outline: 1px solid #c7d1cb !important;
    }

    ${selector} h6 {
      outline: 1px solid #4371d0 !important;
    }

    ${selector} main {
      outline: 1px solid #2f4f90 !important;
    }

    ${selector} address {
      outline: 1px solid #1a2c51 !important;
    }

    ${selector} div {
      outline: 1px solid #036cdb !important;
    }

    ${selector} p {
      outline: 1px solid #ac050b !important;
    }

    ${selector} hr {
      outline: 1px solid #ff063f !important;
    }

    ${selector} pre {
      outline: 1px solid #850440 !important;
    }

    ${selector} blockquote {
      outline: 1px solid #f1b8e7 !important;
    }

    ${selector} ol {
      outline: 1px solid #ff050c !important;
    }

    ${selector} ul {
      outline: 1px solid #d90416 !important;
    }

    ${selector} li {
      outline: 1px solid #d90416 !important;
    }

    ${selector} dl {
      outline: 1px solid #fd3427 !important;
    }

    ${selector} dt {
      outline: 1px solid #ff0043 !important;
    }

    ${selector} dd {
      outline: 1px solid #e80174 !important;
    }

    ${selector} figure {
      outline: 1px solid #ff00bb !important;
    }

    ${selector} figcaption {
      outline: 1px solid #bf0032 !important;
    }

    ${selector} table {
      outline: 1px solid #00cc99 !important;
    }

    ${selector} caption {
      outline: 1px solid #37ffc4 !important;
    }

    ${selector} thead {
      outline: 1px solid #98daca !important;
    }

    ${selector} tbody {
      outline: 1px solid #64a7a0 !important;
    }

    ${selector} tfoot {
      outline: 1px solid #22746b !important;
    }

    ${selector} tr {
      outline: 1px solid #86c0b2 !important;
    }

    ${selector} th {
      outline: 1px solid #a1e7d6 !important;
    }

    ${selector} td {
      outline: 1px solid #3f5a54 !important;
    }

    ${selector} col {
      outline: 1px solid #6c9a8f !important;
    }

    ${selector} colgroup {
      outline: 1px solid #6c9a9d !important;
    }

    ${selector} button {
      outline: 1px solid #da8301 !important;
    }

    ${selector} datalist {
      outline: 1px solid #c06000 !important;
    }

    ${selector} fieldset {
      outline: 1px solid #d95100 !important;
    }

    ${selector} form {
      outline: 1px solid #d23600 !important;
    }

    ${selector} input {
      outline: 1px solid #fca600 !important;
    }

    ${selector} keygen {
      outline: 1px solid #b31e00 !important;
    }

    ${selector} label {
      outline: 1px solid #ee8900 !important;
    }

    ${selector} legend {
      outline: 1px solid #de6d00 !important;
    }

    ${selector} meter {
      outline: 1px solid #e8630c !important;
    }

    ${selector} optgroup {
      outline: 1px solid #b33600 !important;
    }

    ${selector} option {
      outline: 1px solid #ff8a00 !important;
    }

    ${selector} output {
      outline: 1px solid #ff9619 !important;
    }

    ${selector} progress {
      outline: 1px solid #e57c00 !important;
    }

    ${selector} select {
      outline: 1px solid #e26e0f !important;
    }

    ${selector} textarea {
      outline: 1px solid #cc5400 !important;
    }

    ${selector} details {
      outline: 1px solid #33848f !important;
    }

    ${selector} summary {
      outline: 1px solid #60a1a6 !important;
    }

    ${selector} command {
      outline: 1px solid #438da1 !important;
    }

    ${selector} menu {
      outline: 1px solid #449da6 !important;
    }

    ${selector} del {
      outline: 1px solid #bf0000 !important;
    }

    ${selector} ins {
      outline: 1px solid #400000 !important;
    }

    ${selector} img {
      outline: 1px solid #22746b !important;
    }

    ${selector} iframe {
      outline: 1px solid #64a7a0 !important;
    }

    ${selector} embed {
      outline: 1px solid #98daca !important;
    }

    ${selector} object {
      outline: 1px solid #00cc99 !important;
    }

    ${selector} param {
      outline: 1px solid #37ffc4 !important;
    }

    ${selector} video {
      outline: 1px solid #6ee866 !important;
    }

    ${selector} audio {
      outline: 1px solid #027353 !important;
    }

    ${selector} source {
      outline: 1px solid #012426 !important;
    }

    ${selector} canvas {
      outline: 1px solid #a2f570 !important;
    }

    ${selector} track {
      outline: 1px solid #59a600 !important;
    }

    ${selector} map {
      outline: 1px solid #7be500 !important;
    }

    ${selector} area {
      outline: 1px solid #305900 !important;
    }

    ${selector} a {
      outline: 1px solid #ff62ab !important;
    }

    ${selector} em {
      outline: 1px solid #800b41 !important;
    }

    ${selector} strong {
      outline: 1px solid #ff1583 !important;
    }

    ${selector} i {
      outline: 1px solid #803156 !important;
    }

    ${selector} b {
      outline: 1px solid #cc1169 !important;
    }

    ${selector} u {
      outline: 1px solid #ff0430 !important;
    }

    ${selector} s {
      outline: 1px solid #f805e3 !important;
    }

    ${selector} small {
      outline: 1px solid #d107b2 !important;
    }

    ${selector} abbr {
      outline: 1px solid #4a0263 !important;
    }

    ${selector} q {
      outline: 1px solid #240018 !important;
    }

    ${selector} cite {
      outline: 1px solid #64003c !important;
    }

    ${selector} dfn {
      outline: 1px solid #b4005a !important;
    }

    ${selector} sub {
      outline: 1px solid #dba0c8 !important;
    }

    ${selector} sup {
      outline: 1px solid #cc0256 !important;
    }

    ${selector} time {
      outline: 1px solid #d6606d !important;
    }

    ${selector} code {
      outline: 1px solid #e04251 !important;
    }

    ${selector} kbd {
      outline: 1px solid #5e001f !important;
    }

    ${selector} samp {
      outline: 1px solid #9c0033 !important;
    }

    ${selector} var {
      outline: 1px solid #d90047 !important;
    }

    ${selector} mark {
      outline: 1px solid #ff0053 !important;
    }

    ${selector} bdi {
      outline: 1px solid #bf3668 !important;
    }

    ${selector} bdo {
      outline: 1px solid #6f1400 !important;
    }

    ${selector} ruby {
      outline: 1px solid #ff7b93 !important;
    }

    ${selector} rt {
      outline: 1px solid #ff2f54 !important;
    }

    ${selector} rp {
      outline: 1px solid #803e49 !important;
    }

    ${selector} span {
      outline: 1px solid #cc2643 !important;
    }

    ${selector} br {
      outline: 1px solid #db687d !important;
    }

    ${selector} wbr {
      outline: 1px solid #db175b !important;
    }`;
  }
  var withOutline = (StoryFn, context) => {
    let globals = context.globals || {}, isActive = [!0, "true"].includes(globals[PARAM_KEY3]), isInDocs = context.viewMode === "docs", outlineStyles = useMemo2(() => outlineCSS(isInDocs ? '[data-story-block="true"]' : ".sb-show-main"), [context]);
    return useEffect2(() => {
      let selectorId = isInDocs ? `addon-outline-docs-${context.id}` : "addon-outline";
      return isActive ? addOutlineStyles(selectorId, outlineStyles) : clearStyles2(selectorId), () => {
        clearStyles2(selectorId);
      };
    }, [isActive, outlineStyles, context]), StoryFn();
  }, decorators3 = globalThis.FEATURES?.outline ? [withOutline] : [], initialGlobals3 = {
    [PARAM_KEY3]: !1
  };
  var initialGlobals4 = {
    [PARAM_KEY5]: { value: void 0, isRotated: !1 }
  };

  // node_modules/storybook/dist/core-server/presets/common-manager.js
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_react();
  init_theming();
  init_react();
  init_components();
  init_react();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_react();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_react();
  init_react();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_icons();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_react();
  init_react();
  init_components();
  init_react();
  init_react();
  init_components();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_theming();
  init_theming();
  init_react();
  init_components();
  init_react();
  init_react();
  init_theming();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_theming();
  init_react();
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_react();
  init_react();
  init_components();
  init_icons();
  init_react();
  init_react();
  init_components();
  init_icons();
  init_react();
  init_react();
  init_components();
  init_icons();
  init_react();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_react();
  init_icons();
  var Wrapper2 = styled.div(withReset, ({ theme: theme3 }) => ({
    backgroundColor: theme3.base === "light" ? "rgba(0,0,0,.01)" : "rgba(255,255,255,.01)",
    borderRadius: theme3.appBorderRadius,
    border: `1px dashed ${theme3.appBorderColor}`,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    padding: 20,
    margin: "25px 0 40px",
    color: curriedTransparentize$1(0.3, theme3.color.defaultText),
    fontSize: theme3.typography.size.s2
  })), EmptyBlock = (props) => react_default.createElement(Wrapper2, { ...props, className: "docblock-emptyblock sb-unstyled" });
  function n() {
    return n = Object.assign ? Object.assign.bind() : function(e2) {
      for (var n2 = 1; n2 < arguments.length; n2++) {
        var r2 = arguments[n2];
        for (var t in r2) Object.prototype.hasOwnProperty.call(r2, t) && (e2[t] = r2[t]);
      }
      return e2;
    }, n.apply(this, arguments);
  }
  var r = ["children", "options"], o = ["allowFullScreen", "allowTransparency", "autoComplete", "autoFocus", "autoPlay", "cellPadding", "cellSpacing", "charSet", "classId", "colSpan", "contentEditable", "contextMenu", "crossOrigin", "encType", "formAction", "formEncType", "formMethod", "formNoValidate", "formTarget", "frameBorder", "hrefLang", "inputMode", "keyParams", "keyType", "marginHeight", "marginWidth", "maxLength", "mediaGroup", "minLength", "noValidate", "radioGroup", "readOnly", "rowSpan", "spellCheck", "srcDoc", "srcLang", "srcSet", "tabIndex", "useMap"].reduce((e2, n2) => (e2[n2.toLowerCase()] = n2, e2), { class: "className", for: "htmlFor" }), a2 = { amp: "&", apos: "'", gt: ">", lt: "<", nbsp: "\xA0", quot: "\u201C" }, c2 = ["style", "script", "pre"], i2 = ["src", "href", "data", "formAction", "srcDoc", "action"], u2 = /([-A-Z0-9_:]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|(?:\{((?:\\.|{[^}]*?}|[^}])*)\})))?/gi, l = /\n{2,}$/, s3 = /^(\s*>[\s\S]*?)(?=\n\n|$)/, f3 = /^ *> ?/gm, _2 = /^(?:\[!([^\]]*)\]\n)?([\s\S]*)/, d2 = /^ {2,}\n/, p3 = /^(?:([-*_])( *\1){2,}) *(?:\n *)+\n/, y2 = /^(?: {1,3})?(`{3,}|~{3,}) *(\S+)? *([^\n]*?)?\n([\s\S]*?)(?:\1\n?|$)/, h3 = /^(?: {4}[^\n]+\n*)+(?:\n *)+\n?/, g2 = /^(`+)((?:\\`|(?!\1)`|[^`])+)\1/, m2 = /^(?:\n *)*\n/, k2 = /\r\n?/g, x2 = /^\[\^([^\]]+)](:(.*)((\n+ {4,}.*)|(\n(?!\[\^).+))*)/, q2 = /^\[\^([^\]]+)]/, v2 = /\f/g, b2 = /^---[ \t]*\n(.|\n)*\n---[ \t]*\n/, $2 = /^\s*?\[(x|\s)\]/, S2 = /^ *(#{1,6}) *([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, z2 = /^ *(#{1,6}) +([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, E2 = /^([^\n]+)\n *(=|-)\2{2,} *\n/, A2 = /^ *(?!<[a-z][^ >/]* ?\/>)<([a-z][^ >/]*) ?((?:[^>]*[^/])?)>\n?(\s*(?:<\1[^>]*?>[\s\S]*?<\/\1>|(?!<\1\b)[\s\S])*?)<\/\1>(?!<\/\1>)\n*/i, R2 = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi, B2 = /^<!--[\s\S]*?(?:-->)/, L2 = /^(data|aria|x)-[a-z_][a-z\d_.-]*$/, O = /^ *<([a-z][a-z0-9:]*)(?:\s+((?:<.*?>|[^>])*))?\/?>(?!<\/\1>)(\s*\n)?/i, j = /^\{.*\}$/, C3 = /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/, I2 = /^<([^ >]+[:@\/][^ >]+)>/, T2 = /-([a-z])?/gi, M = /^(\|.*)\n(?: *(\|? *[-:]+ *\|[-| :]*)\n((?:.*\|.*\n)*))?\n?/, w2 = /^[^\n]+(?:  \n|\n{2,})/, D2 = /^\[([^\]]*)\]:\s+<?([^\s>]+)>?\s*("([^"]*)")?/, F2 = /^!\[([^\]]*)\] ?\[([^\]]*)\]/, P3 = /^\[([^\]]*)\] ?\[([^\]]*)\]/, Z2 = /(\n|^[-*]\s|^#|^ {2,}|^-{2,}|^>\s)/, N2 = /\t/g, G = /(^ *\||\| *$)/g, U2 = /^ *:-+: *$/, V2 = /^ *:-+ *$/, H7 = /^ *-+: *$/, Q2 = (e2) => `(?=[\\s\\S]+?\\1${e2 ? "\\1" : ""})`, W2 = "((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|\\\\\\1|[\\s\\S])+?)", J2 = RegExp(`^([*_])\\1${Q2(1)}${W2}\\1\\1(?!\\1)`), K2 = RegExp(`^([*_])${Q2(0)}${W2}\\1(?!\\1)`), X2 = RegExp(`^(==)${Q2(0)}${W2}\\1`), Y2 = RegExp(`^(~~)${Q2(0)}${W2}\\1`), ee2 = /^(:[a-zA-Z0-9-_]+:)/, ne = /^\\([^0-9A-Za-z\s])/, re2 = /\\([^0-9A-Za-z\s])/g, te = /^[\s\S](?:(?!  \n|[0-9]\.|http)[^=*_~\-\n:<`\\\[!])*/, oe = /^\n+/, ae = /^([ \t]*)/, ce = /(?:^|\n)( *)$/, ie = "(?:\\d+\\.)", ue2 = "(?:[*+-])";
  function le2(e2) {
    return "( *)(" + (e2 === 1 ? ie : ue2) + ") +";
  }
  var se = le2(1), fe = le2(2);
  function _e(e2) {
    return RegExp("^" + (e2 === 1 ? se : fe));
  }
  var de = _e(1), pe = _e(2);
  function ye(e2) {
    return RegExp("^" + (e2 === 1 ? se : fe) + "[^\\n]*(?:\\n(?!\\1" + (e2 === 1 ? ie : ue2) + " )[^\\n]*)*(\\n|$)", "gm");
  }
  var he = ye(1), ge = ye(2);
  function me(e2) {
    let n2 = e2 === 1 ? ie : ue2;
    return RegExp("^( *)(" + n2 + ") [\\s\\S]+?(?:\\n{2,}(?! )(?!\\1" + n2 + " (?!" + n2 + " ))\\n*|\\s*\\n*$)");
  }
  var ke = me(1), xe = me(2);
  function qe(e2, n2) {
    let r2 = n2 === 1, t = r2 ? ke : xe, o2 = r2 ? he : ge, a22 = r2 ? de : pe;
    return { t: (e3) => a22.test(e3), o: je(function(e3, n3) {
      let r3 = ce.exec(n3.prevCapture);
      return r3 && (n3.list || !n3.inline && !n3.simple) ? t.exec(e3 = r3[1] + e3) : null;
    }), i: 1, u(e3, n3, t2) {
      let c22 = r2 ? +e3[2] : void 0, i22 = e3[0].replace(l, `
`).match(o2), u22 = !1;
      return { items: i22.map(function(e4, r3) {
        let o3 = a22.exec(e4)[0].length, c3 = RegExp("^ {1," + o3 + "}", "gm"), l2 = e4.replace(c3, "").replace(a22, ""), s22 = r3 === i22.length - 1, f22 = l2.indexOf(`

`) !== -1 || s22 && u22;
        u22 = f22;
        let _22 = t2.inline, d22 = t2.list, p22;
        t2.list = !0, f22 ? (t2.inline = !1, p22 = Se(l2) + `

`) : (t2.inline = !0, p22 = Se(l2));
        let y22 = n3(p22, t2);
        return t2.inline = _22, t2.list = d22, y22;
      }), ordered: r2, start: c22 };
    }, l: (n3, r3, t2) => e2(n3.ordered ? "ol" : "ul", { key: t2.key, start: n3.type === "20" ? n3.start : void 0 }, n3.items.map(function(n4, o3) {
      return e2("li", { key: o3 }, r3(n4, t2));
    })) };
  }
  var ve = RegExp(`^\\[((?:\\[[^\\[\\]]*(?:\\[[^\\[\\]]*\\][^\\[\\]]*)*\\]|[^\\[\\]])*)\\]\\(\\s*<?((?:\\([^)]*\\)|[^\\s\\\\]|\\\\.)*?)>?(?:\\s+['"]([\\s\\S]*?)['"])?\\s*\\)`), be = /^!\[(.*?)\]\( *((?:\([^)]*\)|[^() ])*) *"?([^)"]*)?"?\)/;
  function $e(e2) {
    return typeof e2 == "string";
  }
  function Se(e2) {
    let n2 = e2.length;
    for (; n2 > 0 && e2[n2 - 1] <= " "; ) n2--;
    return e2.slice(0, n2);
  }
  function ze(e2, n2) {
    return e2.startsWith(n2);
  }
  function Ee2(e2, n2, r2) {
    if (Array.isArray(r2)) {
      for (let n3 = 0; n3 < r2.length; n3++) if (ze(e2, r2[n3])) return !0;
      return !1;
    }
    return r2(e2, n2);
  }
  function Ae(e2) {
    return e2.replace(/[]/g, "a").replace(/[]/g, "c").replace(/[]/g, "d").replace(/[]/g, "e").replace(/[]/g, "i").replace(/[]/g, "n").replace(/[]/g, "o").replace(/[]/g, "u").replace(/[]/g, "y").replace(/[^a-z0-9- ]/gi, "").replace(/ /gi, "-").toLowerCase();
  }
  function Re(e2) {
    return H7.test(e2) ? "right" : U2.test(e2) ? "center" : V2.test(e2) ? "left" : null;
  }
  function Be(e2, n2, r2, t) {
    let o2 = r2.inTable;
    r2.inTable = !0;
    let a22 = [[]], c22 = "";
    function i22() {
      if (!c22) return;
      let e3 = a22[a22.length - 1];
      e3.push.apply(e3, n2(c22, r2)), c22 = "";
    }
    return e2.trim().split(/(`[^`]*`|\\\||\|)/).filter(Boolean).forEach((e3, n3, r3) => {
      e3.trim() === "|" && (i22(), t) ? n3 !== 0 && n3 !== r3.length - 1 && a22.push([]) : c22 += e3;
    }), i22(), r2.inTable = o2, a22;
  }
  function Le(e2, n2, r2) {
    r2.inline = !0;
    let t = e2[2] ? e2[2].replace(G, "").split("|").map(Re) : [], o2 = e2[3] ? (function(e3, n3, r3) {
      return e3.trim().split(`
`).map(function(e4) {
        return Be(e4, n3, r3, !0);
      });
    })(e2[3], n2, r2) : [], a22 = Be(e2[1], n2, r2, !!o2.length);
    return r2.inline = !1, o2.length ? { align: t, cells: o2, header: a22, type: "25" } : { children: a22, type: "21" };
  }
  function Oe(e2, n2) {
    return e2.align[n2] == null ? {} : { textAlign: e2.align[n2] };
  }
  function je(e2) {
    return e2.inline = 1, e2;
  }
  function Ce(e2) {
    return je(function(n2, r2) {
      return r2.inline ? e2.exec(n2) : null;
    });
  }
  function Ie(e2) {
    return je(function(n2, r2) {
      return r2.inline || r2.simple ? e2.exec(n2) : null;
    });
  }
  function Te(e2) {
    return function(n2, r2) {
      return r2.inline || r2.simple ? null : e2.exec(n2);
    };
  }
  function Me(e2) {
    return je(function(n2) {
      return e2.exec(n2);
    });
  }
  var we = /(javascript|vbscript|data(?!:image)):/i;
  function De(e2) {
    try {
      let n2 = decodeURIComponent(e2).replace(/[^A-Za-z0-9/:]/g, "");
      if (we.test(n2)) return null;
    } catch {
      return null;
    }
    return e2;
  }
  function Fe(e2) {
    return e2 && e2.replace(re2, "$1");
  }
  function Pe(e2, n2, r2) {
    let t = r2.inline || !1, o2 = r2.simple || !1;
    r2.inline = !0, r2.simple = !0;
    let a22 = e2(n2, r2);
    return r2.inline = t, r2.simple = o2, a22;
  }
  function Ze(e2, n2, r2) {
    let t = r2.inline || !1, o2 = r2.simple || !1;
    r2.inline = !1, r2.simple = !0;
    let a22 = e2(n2, r2);
    return r2.inline = t, r2.simple = o2, a22;
  }
  function Ne(e2, n2, r2) {
    let t = r2.inline || !1;
    r2.inline = !1;
    let o2 = e2(n2, r2);
    return r2.inline = t, o2;
  }
  var Ge = (e2, n2, r2) => ({ children: Pe(n2, e2[2], r2) });
  function Ue() {
    return {};
  }
  function Ve() {
    return null;
  }
  function He2(...e2) {
    return e2.filter(Boolean).join(" ");
  }
  function Qe(e2, n2, r2) {
    let t = e2, o2 = n2.split(".");
    for (; o2.length && (t = t[o2[0]], t !== void 0); ) o2.shift();
    return t || r2;
  }
  function We(r2 = "", t = {}) {
    t.overrides = t.overrides || {}, t.namedCodesToUnicode = t.namedCodesToUnicode ? n({}, a2, t.namedCodesToUnicode) : a2;
    let l2 = t.slugify || Ae, G2 = t.sanitizer || De, U22 = t.createElement || createElement, V22 = [s3, y2, h3, t.enforceAtxHeadings ? z2 : S2, E2, M, ke, xe], H22 = [...V22, w2, A2, B2, O];
    function Q22(e2, n2) {
      for (let r3 = 0; r3 < e2.length; r3++) if (e2[r3].test(n2)) return !0;
      return !1;
    }
    function W22(e2, r3, ...o2) {
      let a22 = Qe(t.overrides, e2 + ".props", {});
      return U22((function(e3, n2) {
        let r4 = Qe(n2, e3);
        return r4 ? typeof r4 == "function" || typeof r4 == "object" && "render" in r4 ? r4 : Qe(n2, e3 + ".component", e3) : e3;
      })(e2, t.overrides), n({}, r3, a22, { className: He2(r3?.className, a22.className) || void 0 }), ...o2);
    }
    function re22(e2) {
      e2 = e2.replace(b2, "");
      let n2 = !1;
      t.forceInline ? n2 = !0 : t.forceBlock || (n2 = Z2.test(e2) === !1);
      let r3 = fe2(se2(n2 ? e2 : Se(e2).replace(oe, "") + `

`, { inline: n2 }));
      for (; $e(r3[r3.length - 1]) && !r3[r3.length - 1].trim(); ) r3.pop();
      if (t.wrapper === null) return r3;
      let o2 = t.wrapper || (n2 ? "span" : "div"), a22;
      if (r3.length > 1 || t.forceWrapper) a22 = r3;
      else {
        if (r3.length === 1) return a22 = r3[0], typeof a22 == "string" ? W22("span", { key: "outer" }, a22) : a22;
        a22 = null;
      }
      return U22(o2, { key: "outer" }, a22);
    }
    function ce2(e2, n2) {
      if (!n2 || !n2.trim()) return null;
      let r3 = n2.match(u2);
      return r3 ? r3.reduce(function(n3, r4) {
        let t2 = r4.indexOf("=");
        if (t2 !== -1) {
          let a22 = (function(e3) {
            return e3.indexOf("-") !== -1 && e3.match(L2) === null && (e3 = e3.replace(T2, function(e4, n4) {
              return n4.toUpperCase();
            })), e3;
          })(r4.slice(0, t2)).trim(), c22 = (function(e3) {
            let n4 = e3[0];
            return (n4 === '"' || n4 === "'") && e3.length >= 2 && e3[e3.length - 1] === n4 ? e3.slice(1, -1) : e3;
          })(r4.slice(t2 + 1).trim()), u22 = o[a22] || a22;
          if (u22 === "ref") return n3;
          let l3 = n3[u22] = (function(e3, n4, r5, t3) {
            return n4 === "style" ? (function(e4) {
              let n5 = [], r6 = "", t4 = !1, o2 = !1, a3 = "";
              if (!e4) return n5;
              for (let c4 = 0; c4 < e4.length; c4++) {
                let i22 = e4[c4];
                if (i22 !== '"' && i22 !== "'" || t4 || (o2 ? i22 === a3 && (o2 = !1, a3 = "") : (o2 = !0, a3 = i22)), i22 === "(" && r6.endsWith("url") ? t4 = !0 : i22 === ")" && t4 && (t4 = !1), i22 !== ";" || o2 || t4) r6 += i22;
                else {
                  let e5 = r6.trim();
                  if (e5) {
                    let r7 = e5.indexOf(":");
                    if (r7 > 0) {
                      let t5 = e5.slice(0, r7).trim(), o3 = e5.slice(r7 + 1).trim();
                      n5.push([t5, o3]);
                    }
                  }
                  r6 = "";
                }
              }
              let c3 = r6.trim();
              if (c3) {
                let e5 = c3.indexOf(":");
                if (e5 > 0) {
                  let r7 = c3.slice(0, e5).trim(), t5 = c3.slice(e5 + 1).trim();
                  n5.push([r7, t5]);
                }
              }
              return n5;
            })(r5).reduce(function(n5, [r6, o2]) {
              return n5[r6.replace(/(-[a-z])/g, (e4) => e4[1].toUpperCase())] = t3(o2, e3, r6), n5;
            }, {}) : i2.indexOf(n4) !== -1 ? t3(Fe(r5), e3, n4) : (r5.match(j) && (r5 = Fe(r5.slice(1, r5.length - 1))), r5 === "true" || r5 !== "false" && r5);
          })(e2, a22, c22, G2);
          typeof l3 == "string" && (A2.test(l3) || O.test(l3)) && (n3[u22] = re22(l3.trim()));
        } else r4 !== "style" && (n3[o[r4] || r4] = !0);
        return n3;
      }, {}) : null;
    }
    let ie2 = [], ue22 = {}, le22 = { 0: { t: [">"], o: Te(s3), i: 1, u(e2, n2, r3) {
      let [, t2, o2] = e2[0].replace(f3, "").match(_2);
      return { alert: t2, children: n2(o2, r3) };
    }, l(e2, n2, r3) {
      let t2 = { key: r3.key };
      return e2.alert && (t2.className = "markdown-alert-" + l2(e2.alert.toLowerCase(), Ae), e2.children.unshift({ attrs: {}, children: [{ type: "27", text: e2.alert }], noInnerParse: !0, type: "11", tag: "header" })), W22("blockquote", t2, n2(e2.children, r3));
    } }, 1: { t: ["  "], o: Me(d2), i: 1, u: Ue, l: (e2, n2, r3) => W22("br", { key: r3.key }) }, 2: { t: ["--", "__", "**", "- ", "* ", "_ "], o: Te(p3), i: 1, u: Ue, l: (e2, n2, r3) => W22("hr", { key: r3.key }) }, 3: { t: ["    "], o: Te(h3), i: 0, u: (e2) => ({ lang: void 0, text: Fe(Se(e2[0].replace(/^ {4}/gm, ""))) }), l: (e2, r3, t2) => W22("pre", { key: t2.key }, W22("code", n({}, e2.attrs, { className: e2.lang ? "lang-" + e2.lang : "" }), e2.text)) }, 4: { t: ["```", "~~~"], o: Te(y2), i: 0, u: (e2) => ({ attrs: ce2("code", e2[3] || ""), lang: e2[2] || void 0, text: e2[4], type: "3" }) }, 5: { t: ["`"], o: Ie(g2), i: 3, u: (e2) => ({ text: Fe(e2[2]) }), l: (e2, n2, r3) => W22("code", { key: r3.key }, e2.text) }, 6: { t: ["[^"], o: Te(x2), i: 0, u: (e2) => (ie2.push({ footnote: e2[2], identifier: e2[1] }), {}), l: Ve }, 7: { t: ["[^"], o: Ce(q2), i: 1, u: (e2) => ({ target: "#" + l2(e2[1], Ae), text: e2[1] }), l: (e2, n2, r3) => W22("a", { key: r3.key, href: G2(e2.target, "a", "href") }, W22("sup", { key: r3.key }, e2.text)) }, 8: { t: ["[ ]", "[x]"], o: Ce($2), i: 1, u: (e2) => ({ completed: e2[1].toLowerCase() === "x" }), l: (e2, n2, r3) => W22("input", { checked: e2.completed, key: r3.key, readOnly: !0, type: "checkbox" }) }, 9: { t: ["#"], o: Te(t.enforceAtxHeadings ? z2 : S2), i: 1, u: (e2, n2, r3) => ({ children: Pe(n2, e2[2], r3), id: l2(e2[2], Ae), level: e2[1].length }), l: (e2, n2, r3) => W22("h" + e2.level, { id: e2.id, key: r3.key }, n2(e2.children, r3)) }, 10: { t: (e2) => {
      let n2 = e2.indexOf(`
`);
      return n2 > 0 && n2 < e2.length - 1 && (e2[n2 + 1] === "=" || e2[n2 + 1] === "-");
    }, o: Te(E2), i: 1, u: (e2, n2, r3) => ({ children: Pe(n2, e2[1], r3), level: e2[2] === "=" ? 1 : 2, type: "9" }) }, 11: { t: ["<"], o: Me(A2), i: 1, u(e2, n2, r3) {
      let [, t2] = e2[3].match(ae), o2 = RegExp("^" + t2, "gm"), a22 = e2[3].replace(o2, ""), i22 = Q22(H22, a22) ? Ne : Pe, u22 = e2[1].toLowerCase(), l3 = c2.indexOf(u22) !== -1, s22 = (l3 ? u22 : e2[1]).trim(), f22 = { attrs: ce2(s22, e2[2]), noInnerParse: l3, tag: s22 };
      if (r3.inAnchor = r3.inAnchor || u22 === "a", l3) f22.text = e2[3];
      else {
        let e3 = r3.inHTML;
        r3.inHTML = !0, f22.children = i22(n2, a22, r3), r3.inHTML = e3;
      }
      return r3.inAnchor = !1, f22;
    }, l: (e2, r3, t2) => W22(e2.tag, n({ key: t2.key }, e2.attrs), e2.text || (e2.children ? r3(e2.children, t2) : "")) }, 13: { t: ["<"], o: Me(O), i: 1, u(e2) {
      let n2 = e2[1].trim();
      return { attrs: ce2(n2, e2[2] || ""), tag: n2 };
    }, l: (e2, r3, t2) => W22(e2.tag, n({}, e2.attrs, { key: t2.key })) }, 12: { t: ["<!--"], o: Me(B2), i: 1, u: () => ({}), l: Ve }, 14: { t: ["!["], o: Ie(be), i: 1, u: (e2) => ({ alt: Fe(e2[1]), target: Fe(e2[2]), title: Fe(e2[3]) }), l: (e2, n2, r3) => W22("img", { key: r3.key, alt: e2.alt || void 0, title: e2.title || void 0, src: G2(e2.target, "img", "src") }) }, 15: { t: ["["], o: Ce(ve), i: 3, u: (e2, n2, r3) => ({ children: Ze(n2, e2[1], r3), target: Fe(e2[2]), title: Fe(e2[3]) }), l: (e2, n2, r3) => W22("a", { key: r3.key, href: G2(e2.target, "a", "href"), title: e2.title }, n2(e2.children, r3)) }, 16: { t: ["<"], o: Ce(I2), i: 0, u(e2) {
      let n2 = e2[1], r3 = !1;
      return n2.indexOf("@") !== -1 && n2.indexOf("//") === -1 && (r3 = !0, n2 = n2.replace("mailto:", "")), { children: [{ text: n2, type: "27" }], target: r3 ? "mailto:" + n2 : n2, type: "15" };
    } }, 17: { t: (e2, n2) => !n2.inAnchor && !t.disableAutoLink && (ze(e2, "http://") || ze(e2, "https://")), o: Ce(C3), i: 0, u: (e2) => ({ children: [{ text: e2[1], type: "27" }], target: e2[1], title: void 0, type: "15" }) }, 20: qe(W22, 1), 33: qe(W22, 2), 19: { t: [`
`], o: Te(m2), i: 3, u: Ue, l: () => `
` }, 21: { o: je(function(e2, n2) {
      if (n2.inline || n2.simple || n2.inHTML && e2.indexOf(`

`) === -1 && n2.prevCapture.indexOf(`

`) === -1) return null;
      let r3 = "", t2 = 0;
      for (; ; ) {
        let n3 = e2.indexOf(`
`, t2), o3 = e2.slice(t2, n3 === -1 ? void 0 : n3 + 1);
        if (Q22(V22, o3) || (r3 += o3, n3 === -1 || !o3.trim())) break;
        t2 = n3 + 1;
      }
      let o2 = Se(r3);
      return o2 === "" ? null : [r3, , o2];
    }), i: 3, u: Ge, l: (e2, n2, r3) => W22("p", { key: r3.key }, n2(e2.children, r3)) }, 22: { t: ["["], o: Ce(D2), i: 0, u: (e2) => (ue22[e2[1]] = { target: e2[2], title: e2[4] }, {}), l: Ve }, 23: { t: ["!["], o: Ie(F2), i: 0, u: (e2) => ({ alt: e2[1] ? Fe(e2[1]) : void 0, ref: e2[2] }), l: (e2, n2, r3) => ue22[e2.ref] ? W22("img", { key: r3.key, alt: e2.alt, src: G2(ue22[e2.ref].target, "img", "src"), title: ue22[e2.ref].title }) : null }, 24: { t: (e2) => e2[0] === "[" && e2.indexOf("](") === -1, o: Ce(P3), i: 0, u: (e2, n2, r3) => ({ children: n2(e2[1], r3), fallbackChildren: e2[0], ref: e2[2] }), l: (e2, n2, r3) => ue22[e2.ref] ? W22("a", { key: r3.key, href: G2(ue22[e2.ref].target, "a", "href"), title: ue22[e2.ref].title }, n2(e2.children, r3)) : W22("span", { key: r3.key }, e2.fallbackChildren) }, 25: { t: ["|"], o: Te(M), i: 1, u: Le, l(e2, n2, r3) {
      let t2 = e2;
      return W22("table", { key: r3.key }, W22("thead", null, W22("tr", null, t2.header.map(function(e3, o2) {
        return W22("th", { key: o2, style: Oe(t2, o2) }, n2(e3, r3));
      }))), W22("tbody", null, t2.cells.map(function(e3, o2) {
        return W22("tr", { key: o2 }, e3.map(function(e4, o3) {
          return W22("td", { key: o3, style: Oe(t2, o3) }, n2(e4, r3));
        }));
      })));
    } }, 27: { o: je(function(e2, n2) {
      let r3;
      return ze(e2, ":") && (r3 = ee2.exec(e2)), r3 || te.exec(e2);
    }), i: 4, u(e2) {
      let n2 = e2[0];
      return { text: n2.indexOf("&") === -1 ? n2 : n2.replace(R2, (e3, n3) => t.namedCodesToUnicode[n3] || e3) };
    }, l: (e2) => e2.text }, 28: { t: ["**", "__"], o: Ie(J2), i: 2, u: (e2, n2, r3) => ({ children: n2(e2[2], r3) }), l: (e2, n2, r3) => W22("strong", { key: r3.key }, n2(e2.children, r3)) }, 29: { t: (e2) => {
      let n2 = e2[0];
      return (n2 === "*" || n2 === "_") && e2[1] !== n2;
    }, o: Ie(K2), i: 3, u: (e2, n2, r3) => ({ children: n2(e2[2], r3) }), l: (e2, n2, r3) => W22("em", { key: r3.key }, n2(e2.children, r3)) }, 30: { t: ["\\"], o: Ie(ne), i: 1, u: (e2) => ({ text: e2[1], type: "27" }) }, 31: { t: ["=="], o: Ie(X2), i: 3, u: Ge, l: (e2, n2, r3) => W22("mark", { key: r3.key }, n2(e2.children, r3)) }, 32: { t: ["~~"], o: Ie(Y2), i: 3, u: Ge, l: (e2, n2, r3) => W22("del", { key: r3.key }, n2(e2.children, r3)) } };
    t.disableParsingRawHTML === !0 && (delete le22[11], delete le22[13]);
    let se2 = (function(e2) {
      var n2 = Object.keys(e2);
      function r3(t2, o2) {
        var a22 = [];
        if (o2.prevCapture = o2.prevCapture || "", t2.trim()) for (; t2; ) for (var c22 = 0; c22 < n2.length; ) {
          var i22 = n2[c22], u22 = e2[i22];
          if (!u22.t || Ee2(t2, o2, u22.t)) {
            var l3 = u22.o(t2, o2);
            if (l3 && l3[0]) {
              t2 = t2.substring(l3[0].length);
              var s22 = u22.u(l3, r3, o2);
              o2.prevCapture += l3[0], s22.type || (s22.type = i22), a22.push(s22);
              break;
            }
            c22++;
          } else c22++;
        }
        return o2.prevCapture = "", a22;
      }
      return n2.sort(function(n3, r4) {
        return e2[n3].i - e2[r4].i || (n3 < r4 ? -1 : 1);
      }), function(e3, n3) {
        return r3((function(e4) {
          return e4.replace(k2, `
`).replace(v2, "").replace(N2, "    ");
        })(e3), n3);
      };
    })(le22), fe2 = /* @__PURE__ */ (function(e2, n2) {
      return function r3(t2, o2 = {}) {
        if (Array.isArray(t2)) {
          let e3 = o2.key, n3 = [], a22 = !1;
          for (let e4 = 0; e4 < t2.length; e4++) {
            o2.key = e4;
            let c22 = r3(t2[e4], o2), i22 = $e(c22);
            i22 && a22 ? n3[n3.length - 1] += c22 : c22 !== null && n3.push(c22), a22 = i22;
          }
          return o2.key = e3, n3;
        }
        return (function(r4, t3, o3) {
          let a22 = e2[r4.type].l;
          return n2 ? n2(() => a22(r4, t3, o3), r4, t3, o3) : a22(r4, t3, o3);
        })(t2, r3, o2);
      };
    })(le22, t.renderRule), _e2 = re22(r2);
    return ie2.length ? W22("div", null, _e2, W22("footer", { key: "footer" }, ie2.map(function(e2) {
      return W22("div", { id: l2(e2.identifier, Ae), key: e2.identifier }, e2.identifier, fe2(se2(e2.footnote, { inline: !0 })));
    }))) : _e2;
  }
  var index_modern_default = (n2) => {
    let { children: t, options: o2 } = n2, a22 = (function(e2, n3) {
      if (e2 == null) return {};
      var r2, t2, o3 = {}, a3 = Object.keys(e2);
      for (t2 = 0; t2 < a3.length; t2++) n3.indexOf(r2 = a3[t2]) >= 0 || (o3[r2] = e2[r2]);
      return o3;
    })(n2, r);
    return cloneElement(We(t ?? "", o2), a22);
  }, Label = styled.label(({ theme: theme3 }) => ({
    lineHeight: "18px",
    alignItems: "center",
    marginBottom: 8,
    display: "inline-block",
    position: "relative",
    whiteSpace: "nowrap",
    background: theme3.boolean.background,
    borderRadius: "3em",
    padding: 1,
    '&[aria-disabled="true"]': {
      opacity: 0.5,
      input: {
        cursor: "not-allowed"
      }
    },
    input: {
      appearance: "none",
      width: "100%",
      height: "100%",
      position: "absolute",
      left: 0,
      top: 0,
      margin: 0,
      padding: 0,
      border: "none",
      background: "transparent",
      cursor: "pointer",
      borderRadius: "3em",
      "&:focus": {
        outline: "none",
        boxShadow: `${theme3.color.secondary} 0 0 0 1px inset !important`
      },
      "@media (forced-colors: active)": {
        "&:focus": {
          outline: "1px solid highlight"
        }
      }
    },
    span: {
      textAlign: "center",
      fontSize: theme3.typography.size.s1,
      fontWeight: theme3.typography.weight.bold,
      lineHeight: "1",
      cursor: "pointer",
      display: "inline-block",
      padding: "7px 15px",
      transition: "all 100ms ease-out",
      userSelect: "none",
      borderRadius: "3em",
      color: curriedTransparentize$1(0.5, theme3.color.defaultText),
      background: "transparent",
      "&:hover": {
        boxShadow: `${curriedOpacify$1(0.3, theme3.appBorderColor)} 0 0 0 1px inset`
      },
      "&:active": {
        boxShadow: `${curriedOpacify$1(0.05, theme3.appBorderColor)} 0 0 0 2px inset`,
        color: curriedOpacify$1(1, theme3.appBorderColor)
      },
      "&:first-of-type": {
        paddingRight: 8
      },
      "&:last-of-type": {
        paddingLeft: 8
      }
    },
    "input:checked ~ span:last-of-type, input:not(:checked) ~ span:first-of-type": {
      background: theme3.boolean.selectedBackground,
      boxShadow: theme3.base === "light" ? `${curriedOpacify$1(0.1, theme3.appBorderColor)} 0 0 2px` : `${theme3.appBorderColor} 0 0 0 1px`,
      color: theme3.color.defaultText,
      padding: "7px 15px",
      "@media (forced-colors: active)": {
        textDecoration: "underline"
      }
    }
  })), parse = (value2) => value2 === "true", BooleanControl = ({
    name,
    value: value2,
    onChange,
    onBlur,
    onFocus,
    argType
  }) => {
    let onSetFalse = useCallback(() => onChange(!1), [onChange]), readonly = !!argType?.table?.readonly;
    if (value2 === void 0)
      return react_default.createElement(
        Button,
        {
          ariaLabel: !1,
          variant: "outline",
          size: "medium",
          id: getControlSetterButtonId(name),
          onClick: onSetFalse,
          disabled: readonly
        },
        "Set boolean"
      );
    let controlId = getControlId(name), parsedValue = typeof value2 == "string" ? parse(value2) : value2;
    return react_default.createElement(Label, { "aria-disabled": readonly, htmlFor: controlId, "aria-label": name }, react_default.createElement(
      "input",
      {
        id: controlId,
        type: "checkbox",
        onChange: (e2) => onChange(e2.target.checked),
        checked: parsedValue,
        role: "switch",
        disabled: readonly,
        name,
        onBlur,
        onFocus
      }
    ), react_default.createElement("span", { "aria-hidden": "true" }, "False"), react_default.createElement("span", { "aria-hidden": "true" }, "True"));
  }, parseDate = (value2) => {
    let [year, month, day] = value2.split("-"), result = /* @__PURE__ */ new Date();
    return result.setFullYear(parseInt(year, 10), parseInt(month, 10) - 1, parseInt(day, 10)), result;
  }, parseTime = (value2) => {
    let [hours, minutes] = value2.split(":"), result = /* @__PURE__ */ new Date();
    return result.setHours(parseInt(hours, 10)), result.setMinutes(parseInt(minutes, 10)), result;
  }, formatDate = (value2) => {
    let date = new Date(value2), year = `000${date.getFullYear()}`.slice(-4), month = `0${date.getMonth() + 1}`.slice(-2), day = `0${date.getDate()}`.slice(-2);
    return `${year}-${month}-${day}`;
  }, formatTime = (value2) => {
    let date = new Date(value2), hours = `0${date.getHours()}`.slice(-2), minutes = `0${date.getMinutes()}`.slice(-2);
    return `${hours}:${minutes}`;
  }, FormInput = styled(Form.Input)(({ theme: theme3 }) => ({
    "&[readonly]": {
      background: theme3.base === "light" ? theme3.color.lighter : "transparent"
    },
    "&::-webkit-calendar-picker-indicator": {
      opacity: 0.5,
      height: 12,
      filter: theme3.base === "light" ? void 0 : "invert(1)"
    }
  })), FlexSpaced = styled.fieldset({
    flex: 1,
    display: "flex",
    border: 0,
    marginInline: 0,
    padding: 0,
    gap: 10,
    "div:first-of-type": {
      flex: 4
    },
    "div:last-of-type": {
      flex: 3
    }
  }), DateControl = ({ name, value: value2, onChange, onFocus, onBlur, argType }) => {
    let [valid, setValid] = useState(!0), dateRef = useRef(), timeRef = useRef(), readonly = !!argType?.table?.readonly;
    useEffect(() => {
      valid !== !1 && (dateRef && dateRef.current && (dateRef.current.value = value2 ? formatDate(value2) : ""), timeRef && timeRef.current && (timeRef.current.value = value2 ? formatTime(value2) : ""));
    }, [value2]);
    let onDateChange = (e2) => {
      if (!e2.target.value)
        return onChange();
      let parsed = parseDate(e2.target.value), result = new Date(value2 ?? "");
      result.setFullYear(parsed.getFullYear(), parsed.getMonth(), parsed.getDate());
      let time = result.getTime();
      time && onChange(time), setValid(!!time);
    }, onTimeChange = (e2) => {
      if (!e2.target.value)
        return onChange();
      let parsed = parseTime(e2.target.value), result = new Date(value2 ?? "");
      result.setHours(parsed.getHours()), result.setMinutes(parsed.getMinutes());
      let time = result.getTime();
      time && onChange(time), setValid(!!time);
    }, controlId = getControlId(name);
    return react_default.createElement(FlexSpaced, null, react_default.createElement("legend", { className: "sb-sr-only" }, name), react_default.createElement("label", { htmlFor: `${controlId}-date`, className: "sb-sr-only" }, "Date"), react_default.createElement(
      FormInput,
      {
        type: "date",
        max: "9999-12-31",
        ref: dateRef,
        id: `${controlId}-date`,
        name: `${controlId}-date`,
        readOnly: readonly,
        onChange: onDateChange,
        onFocus,
        onBlur
      }
    ), react_default.createElement("label", { htmlFor: `${controlId}-time`, className: "sb-sr-only" }, "Time"), react_default.createElement(
      FormInput,
      {
        type: "time",
        id: `${controlId}-time`,
        name: `${controlId}-time`,
        ref: timeRef,
        onChange: onTimeChange,
        readOnly: readonly,
        onFocus,
        onBlur
      }
    ), valid ? null : react_default.createElement("div", null, "invalid"));
  }, Wrapper22 = styled.label({
    display: "flex"
  }), parse2 = (value2) => {
    let result = parseFloat(value2);
    return Number.isNaN(result) ? void 0 : result;
  }, FormInput2 = styled(Form.Input)(({ theme: theme3 }) => ({
    background: theme3.base === "light" ? theme3.color.lighter : "transparent"
  })), NumberControl = ({
    name,
    value: value2,
    onChange,
    min,
    max,
    step: step2,
    onBlur,
    onFocus,
    argType
  }) => {
    let [inputValue, setInputValue] = useState(typeof value2 == "number" ? value2 : ""), [forceVisible, setForceVisible] = useState(!1), [parseError, setParseError] = useState(null), readonly = !!argType?.table?.readonly, handleChange = useCallback(
      (event) => {
        setInputValue(event.target.value);
        let result = parseFloat(event.target.value);
        if (Number.isNaN(result))
          setParseError(new Error(`'${event.target.value}' is not a number`));
        else {
          let finalValue = result;
          typeof min == "number" && finalValue < min && (finalValue = min), typeof max == "number" && finalValue > max && (finalValue = max), onChange(finalValue), setParseError(null), finalValue !== result && setInputValue(String(finalValue));
        }
      },
      [onChange, setParseError, min, max]
    ), onForceVisible = useCallback(() => {
      setInputValue("0"), onChange(0), setForceVisible(!0);
    }, [setForceVisible]), htmlElRef = useRef(null);
    return useEffect(() => {
      forceVisible && htmlElRef.current && htmlElRef.current.select();
    }, [forceVisible]), useEffect(() => {
      let newInputValue = typeof value2 == "number" ? value2 : "";
      inputValue !== newInputValue && setInputValue(newInputValue);
    }, [value2]), value2 === void 0 ? react_default.createElement(
      Button,
      {
        ariaLabel: !1,
        variant: "outline",
        size: "medium",
        id: getControlSetterButtonId(name),
        onClick: onForceVisible,
        disabled: readonly
      },
      "Set number"
    ) : react_default.createElement(Wrapper22, null, react_default.createElement(
      FormInput2,
      {
        ref: htmlElRef,
        id: getControlId(name),
        type: "number",
        onChange: handleChange,
        size: "flex",
        placeholder: "Edit number...",
        value: inputValue,
        valid: parseError ? "error" : void 0,
        autoFocus: forceVisible,
        readOnly: readonly,
        name,
        min,
        max,
        step: step2,
        onFocus,
        onBlur
      }
    ));
  }, selectedKey = (value2, options) => {
    let entry = options && Object.entries(options).find(([_key, val]) => val === value2);
    return entry ? entry[0] : void 0;
  }, selectedKeys = (value2, options) => value2 && options ? Object.entries(options).filter((entry) => value2.includes(entry[1])).map((entry) => entry[0]) : [], selectedValues = (keys, options) => keys && options && keys.map((key) => options[key]), Wrapper3 = styled.fieldset(
    {
      border: "none",
      marginInline: 0,
      padding: 0,
      display: "flex",
      alignItems: "flex-start"
    },
    ({ $isInline: isInline }) => isInline ? {
      flexWrap: "wrap",
      gap: 15,
      label: {
        display: "inline-flex"
      }
    } : {
      flexDirection: "column",
      gap: 8,
      label: {
        display: "flex"
      }
    }
  ), Text = styled.span(({ $readOnly }) => ({
    opacity: $readOnly ? 0.5 : 1
  })), Label2 = styled.label(({ $readOnly }) => ({
    lineHeight: "20px",
    alignItems: "center",
    cursor: $readOnly ? "not-allowed" : "pointer",
    input: {
      cursor: $readOnly ? "not-allowed" : "pointer",
      margin: 0,
      marginRight: 6
    }
  })), CheckboxControl = ({
    name,
    options,
    value: value2,
    onChange,
    isInline,
    argType
  }) => {
    if (!options)
      return logger.warn(`Checkbox with no options: ${name}`), react_default.createElement(react_default.Fragment, null, "-");
    let initial = selectedKeys(value2 || [], options), [selected, setSelected] = useState(initial), readonly = !!argType?.table?.readonly, handleChange = (e2) => {
      let option = e2.target.value, updated = [...selected];
      updated.includes(option) ? updated.splice(updated.indexOf(option), 1) : updated.push(option), onChange(selectedValues(updated, options)), setSelected(updated);
    };
    useEffect(() => {
      setSelected(selectedKeys(value2 || [], options));
    }, [value2]);
    let controlId = getControlId(name);
    return react_default.createElement(Wrapper3, { $isInline: isInline }, react_default.createElement("legend", { className: "sb-sr-only" }, name), Object.keys(options).map((key, index2) => {
      let id2 = `${controlId}-${index2}`;
      return react_default.createElement(Label2, { key: id2, htmlFor: id2, $readOnly: readonly }, react_default.createElement(
        "input",
        {
          type: "checkbox",
          disabled: readonly,
          id: id2,
          name: id2,
          value: key,
          onChange: handleChange,
          checked: selected?.includes(key)
        }
      ), react_default.createElement(Text, { $readOnly: readonly }, key));
    }));
  }, Wrapper4 = styled.fieldset(
    {
      border: "none",
      marginInline: 0,
      padding: 0,
      display: "flex",
      alignItems: "flex-start"
    },
    ({ isInline }) => isInline ? {
      flexWrap: "wrap",
      gap: 15,
      label: {
        display: "inline-flex"
      }
    } : {
      flexDirection: "column",
      gap: 8,
      label: {
        display: "flex"
      }
    }
  ), Text2 = styled.span(({ $readOnly }) => ({
    opacity: $readOnly ? 0.5 : 1
  })), Label3 = styled.label(({ $readOnly }) => ({
    lineHeight: "20px",
    alignItems: "center",
    cursor: $readOnly ? "not-allowed" : "pointer",
    input: {
      cursor: $readOnly ? "not-allowed" : "pointer",
      margin: 0,
      marginRight: 6
    }
  })), RadioControl = ({
    name,
    options,
    value: value2,
    onChange,
    isInline,
    argType
  }) => {
    if (!options)
      return logger.warn(`Radio with no options: ${name}`), react_default.createElement(react_default.Fragment, null, "-");
    let selection = selectedKey(value2, options), controlId = getControlId(name), readonly = !!argType?.table?.readonly;
    return react_default.createElement(Wrapper4, { isInline }, react_default.createElement("legend", { className: "sb-sr-only" }, name), Object.keys(options).map((key, index2) => {
      let id2 = `${controlId}-${index2}`;
      return react_default.createElement(Label3, { key: id2, htmlFor: id2, $readOnly: readonly }, react_default.createElement(
        "input",
        {
          type: "radio",
          id: id2,
          name: controlId,
          disabled: readonly,
          value: key,
          onChange: (e2) => onChange(options[e2.currentTarget.value]),
          checked: key === selection
        }
      ), react_default.createElement(Text2, { $readOnly: readonly }, key));
    }));
  }, styleResets = {
    // resets
    appearance: "none",
    border: "0 none",
    boxSizing: "inherit",
    display: " block",
    margin: " 0",
    background: "transparent",
    padding: 0,
    fontSize: "inherit",
    position: "relative"
  }, OptionsSelect = styled.select(styleResets, ({ theme: theme3 }) => ({
    boxSizing: "border-box",
    position: "relative",
    padding: "6px 10px",
    width: "100%",
    color: theme3.input.color || "inherit",
    background: theme3.input.background,
    borderRadius: theme3.input.borderRadius,
    boxShadow: `${theme3.input.border} 0 0 0 1px inset`,
    fontSize: theme3.typography.size.s2 - 1,
    lineHeight: "20px",
    "&:focus": {
      boxShadow: `${theme3.color.secondary} 0 0 0 1px inset`,
      outline: "none"
    },
    "&[disabled]": {
      cursor: "not-allowed",
      opacity: 0.5
    },
    "::placeholder": {
      color: theme3.textMutedColor
    },
    "&[multiple]": {
      overflow: "auto",
      padding: 0,
      option: {
        display: "block",
        padding: "6px 10px",
        marginLeft: 1,
        marginRight: 1,
        "&:hover": {
          background: theme3.background.hoverable
        },
        "&:checked": {
          background: "transparent",
          color: theme3.color.secondary,
          fontWeight: theme3.typography.weight.bold
        }
      }
    }
  })), SelectWrapper = styled.span(({ theme: theme3 }) => ({
    display: "inline-block",
    lineHeight: "normal",
    overflow: "hidden",
    position: "relative",
    verticalAlign: "top",
    width: "100%",
    svg: {
      position: "absolute",
      zIndex: 1,
      pointerEvents: "none",
      height: "12px",
      marginTop: "-6px",
      right: "12px",
      top: "50%",
      fill: theme3.textMutedColor,
      path: {
        fill: theme3.textMutedColor
      }
    }
  })), NO_SELECTION = "Choose option...", SingleSelect = ({ name, value: value2, options, onChange, argType }) => {
    let handleChange = (e2) => {
      onChange(options[e2.currentTarget.value]);
    }, selection = selectedKey(value2, options) || NO_SELECTION, controlId = getControlId(name), readonly = !!argType?.table?.readonly;
    return react_default.createElement(SelectWrapper, null, react_default.createElement(ChevronSmallDownIcon, null), react_default.createElement("label", { htmlFor: controlId, className: "sb-sr-only" }, name), react_default.createElement(OptionsSelect, { disabled: readonly, id: controlId, value: selection, onChange: handleChange }, react_default.createElement("option", { disabled: selection === NO_SELECTION, key: "no-selection" }, NO_SELECTION), Object.keys(options).map((key) => react_default.createElement("option", { key, value: key }, key))));
  }, MultiSelect = ({ name, value: value2, options, onChange, argType }) => {
    let handleChange = (e2) => {
      let selection2 = Array.from(e2.currentTarget.options).filter((option) => option.selected).map((option) => option.value);
      onChange(selectedValues(selection2, options));
    }, selection = selectedKeys(value2, options), controlId = getControlId(name), readonly = !!argType?.table?.readonly;
    return react_default.createElement(SelectWrapper, null, react_default.createElement("label", { htmlFor: controlId, className: "sb-sr-only" }, name), react_default.createElement(
      OptionsSelect,
      {
        disabled: readonly,
        id: controlId,
        multiple: !0,
        value: selection,
        onChange: handleChange
      },
      Object.keys(options).map((key) => react_default.createElement("option", { key, value: key }, key))
    ));
  }, SelectControl = (props) => {
    let { name, options } = props;
    return options ? props.isMulti ? react_default.createElement(MultiSelect, { ...props }) : react_default.createElement(SingleSelect, { ...props }) : (logger.warn(`Select with no options: ${name}`), react_default.createElement(react_default.Fragment, null, "-"));
  }, normalizeOptions2 = (options, labels) => Array.isArray(options) ? options.reduce((acc, item) => (acc[labels?.[item] || String(item)] = item, acc), {}) : options, Controls = {
    check: CheckboxControl,
    "inline-check": CheckboxControl,
    radio: RadioControl,
    "inline-radio": RadioControl,
    select: SelectControl,
    "multi-select": SelectControl
  }, OptionsControl = (props) => {
    let { type = "select", labels, argType } = props, normalized = {
      ...props,
      argType,
      options: argType ? normalizeOptions2(argType.options, labels) : {},
      isInline: type.includes("inline"),
      isMulti: type.includes("multi")
    }, Control = Controls[type];
    if (Control)
      return react_default.createElement(Control, { ...normalized });
    throw new Error(`Unknown options type: ${type}`);
  }, Container = styled.div(({ theme: theme3 }) => ({
    position: "relative",
    ":hover": {
      "& > .rejt-accordion-button::after": {
        background: theme3.color.secondary
      },
      "& > .rejt-accordion-region > :is(.rejt-plus-menu, .rejt-minus-menu)": {
        opacity: 1
      }
    }
  })), Trigger = styled.button(({ theme: theme3 }) => ({
    padding: 0,
    background: "transparent",
    border: "none",
    marginRight: "3px",
    lineHeight: "22px",
    color: theme3.color.secondary,
    "::after": {
      content: '""',
      position: "absolute",
      top: 0,
      display: "block",
      width: "100%",
      marginLeft: "-1rem",
      height: "22px",
      background: "transparent",
      borderRadius: 4,
      transition: "background 0.2s",
      opacity: 0.1,
      paddingRight: "20px"
    },
    "::before": {
      content: '""',
      position: "absolute"
    },
    '&[aria-expanded="true"]::before': {
      left: -10,
      top: 10,
      borderTop: "3px solid rgba(153,153,153,0.6)",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent"
    },
    '&[aria-expanded="false"]::before': {
      left: -8,
      top: 8,
      borderTop: "3px solid transparent",
      borderBottom: "3px solid transparent",
      borderLeft: "3px solid rgba(153,153,153,0.6)"
    }
  })), Region = styled.div({
    display: "inline"
  });
  function JsonNodeAccordion({
    children,
    name,
    collapsed,
    keyPath,
    deep,
    ...props
  }) {
    let accordionKey = `${keyPath.at(-1) ?? "root"}-${name}-${deep}`, ids = {
      trigger: `${accordionKey}-trigger`,
      region: `${accordionKey}-region`
    }, containerTag = keyPath.length > 0 ? "li" : "div";
    return react_default.createElement(Container, { as: containerTag }, react_default.createElement(
      Trigger,
      {
        type: "button",
        "aria-expanded": !collapsed,
        id: ids.trigger,
        "aria-controls": ids.region,
        className: "rejt-accordion-button",
        ...props
      },
      name,
      " :"
    ), react_default.createElement(
      Region,
      {
        role: "region",
        id: ids.region,
        "aria-labelledby": ids.trigger,
        className: "rejt-accordion-region"
      },
      children
    ));
  }
  var ERROR = "Error", OBJECT = "Object", ARRAY = "Array", STRING = "String", NUMBER = "Number", BOOLEAN = "Boolean", DATE = "Date", NULL = "Null", UNDEFINED = "Undefined", FUNCTION = "Function", SYMBOL = "Symbol", ADD_DELTA_TYPE = "ADD_DELTA_TYPE", REMOVE_DELTA_TYPE = "REMOVE_DELTA_TYPE", UPDATE_DELTA_TYPE = "UPDATE_DELTA_TYPE", VALUE = "value";
  function getObjectType(obj) {
    return obj !== null && typeof obj == "object" && !Array.isArray(obj) && typeof obj[Symbol.iterator] == "function" ? "Iterable" : Object.prototype.toString.call(obj).slice(8, -1);
  }
  function isComponentWillChange(oldValue, newValue) {
    let oldType = getObjectType(oldValue), newType = getObjectType(newValue);
    return (oldType === "Function" || newType === "Function") && newType !== oldType;
  }
  var JsonAddValue = class extends Component {
    constructor(props) {
      super(props), this.state = {
        inputRefKey: null,
        inputRefValue: null
      }, this.refInputValue = this.refInputValue.bind(this), this.refInputKey = this.refInputKey.bind(this), this.onKeydown = this.onKeydown.bind(this), this.onSubmit = this.onSubmit.bind(this);
    }
    componentDidMount() {
      let { inputRefKey, inputRefValue } = this.state, { onlyValue } = this.props;
      inputRefKey && typeof inputRefKey.focus == "function" && inputRefKey.focus(), onlyValue && inputRefValue && typeof inputRefValue.focus == "function" && inputRefValue.focus();
    }
    onKeydown(event) {
      if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey || event.repeat)
        return;
      let { inputRefKey, inputRefValue } = this.state, { addButtonElement, handleCancel } = this.props;
      [inputRefKey, inputRefValue, addButtonElement].some(
        (elm) => elm === event.target
      ) && ((event.code === "Enter" || event.key === "Enter") && (event.preventDefault(), this.onSubmit()), (event.code === "Escape" || event.key === "Escape") && (event.preventDefault(), handleCancel()));
    }
    onSubmit() {
      let { handleAdd, onlyValue, onSubmitValueParser, keyPath, deep } = this.props, { inputRefKey, inputRefValue } = this.state, result = {};
      if (!onlyValue) {
        if (!inputRefKey.value)
          return;
        result.key = inputRefKey.value;
      }
      result.newValue = onSubmitValueParser(!1, keyPath, deep, result.key, inputRefValue.value), handleAdd(result);
    }
    refInputKey(node) {
      this.state.inputRefKey = node;
    }
    refInputValue(node) {
      this.state.inputRefValue = node;
    }
    render() {
      let {
        handleCancel,
        onlyValue,
        addButtonElement,
        cancelButtonElement,
        inputElementGenerator,
        keyPath,
        deep
      } = this.props, addButtonElementLayout = addButtonElement && cloneElement(addButtonElement, {
        onClick: this.onSubmit
      }), cancelButtonElementLayout = cancelButtonElement && cloneElement(cancelButtonElement, {
        onClick: handleCancel
      }), inputElementValue = inputElementGenerator(VALUE, keyPath, deep), inputElementValueLayout = cloneElement(inputElementValue, {
        placeholder: "Value",
        ref: this.refInputValue,
        onKeyDown: this.onKeydown
      }), inputElementKeyLayout = null;
      if (!onlyValue) {
        let inputElementKey = inputElementGenerator("key", keyPath, deep);
        inputElementKeyLayout = cloneElement(inputElementKey, {
          placeholder: "Key",
          ref: this.refInputKey,
          onKeyDown: this.onKeydown
        });
      }
      return react_default.createElement("span", { className: "rejt-add-value-node" }, inputElementKeyLayout, inputElementValueLayout, addButtonElementLayout, cancelButtonElementLayout);
    }
  };
  JsonAddValue.defaultProps = {
    onlyValue: !1,
    addButtonElement: react_default.createElement("button", null, "+"),
    cancelButtonElement: react_default.createElement("button", null, "c")
  };
  var JsonArray = class extends Component {
    constructor(props) {
      super(props);
      let keyPath = [...props.keyPath || [], props.name];
      this.state = {
        data: props.data,
        name: props.name,
        keyPath: keyPath ?? [],
        deep: props.deep ?? 0,
        nextDeep: (props.deep ?? 0) + 1,
        collapsed: props.isCollapsed(keyPath, props.deep ?? 0, props.data),
        addFormVisible: !1
      }, this.handleCollapseMode = this.handleCollapseMode.bind(this), this.handleRemoveItem = this.handleRemoveItem.bind(this), this.handleAddMode = this.handleAddMode.bind(this), this.handleAddValueAdd = this.handleAddValueAdd.bind(this), this.handleAddValueCancel = this.handleAddValueCancel.bind(this), this.handleEditValue = this.handleEditValue.bind(this), this.onChildUpdate = this.onChildUpdate.bind(this), this.renderCollapsed = this.renderCollapsed.bind(this), this.renderNotCollapsed = this.renderNotCollapsed.bind(this);
    }
    static getDerivedStateFromProps(props, state3) {
      return props.data !== state3.data ? { data: props.data } : null;
    }
    onChildUpdate(childKey, childData) {
      let { data, keyPath = [] } = this.state;
      data[childKey] = childData, this.setState({
        data
      });
      let { onUpdate } = this.props, size = keyPath.length;
      onUpdate(keyPath[size - 1], data);
    }
    handleAddMode() {
      this.setState({
        addFormVisible: !0
      });
    }
    handleCollapseMode() {
      this.setState((state3) => ({
        collapsed: !state3.collapsed
      }));
    }
    handleRemoveItem(index2) {
      return () => {
        let { beforeRemoveAction, logger: logger5 } = this.props, { data, keyPath, nextDeep: deep } = this.state, oldValue = data[index2];
        (beforeRemoveAction || Promise.resolve.bind(Promise))(index2, keyPath, deep, oldValue).then(() => {
          let deltaUpdateResult = {
            keyPath,
            deep,
            key: index2,
            oldValue,
            type: REMOVE_DELTA_TYPE
          };
          data.splice(index2, 1), this.setState({ data });
          let { onUpdate, onDeltaUpdate } = this.props;
          onUpdate(keyPath[keyPath.length - 1], data), onDeltaUpdate(deltaUpdateResult);
        }).catch(logger5.error);
      };
    }
    handleAddValueAdd({ newValue }) {
      let { data, keyPath = [], nextDeep: deep } = this.state, { beforeAddAction, logger: logger5 } = this.props, key = data.length;
      (beforeAddAction || Promise.resolve.bind(Promise))(key, keyPath, deep, newValue).then(() => {
        data[key] = newValue, this.setState({
          data
        }), this.handleAddValueCancel();
        let { onUpdate, onDeltaUpdate } = this.props;
        onUpdate(keyPath[keyPath.length - 1], data), onDeltaUpdate({
          type: ADD_DELTA_TYPE,
          keyPath,
          deep,
          key,
          newValue
        });
      }).catch(logger5.error);
    }
    handleAddValueCancel() {
      this.setState({
        addFormVisible: !1
      });
    }
    handleEditValue({ key, value: value2 }) {
      return new Promise((resolve, reject) => {
        let { beforeUpdateAction } = this.props, { data, keyPath, nextDeep: deep } = this.state, oldValue = data[key];
        (beforeUpdateAction || Promise.resolve.bind(Promise))(key, keyPath, deep, oldValue, value2).then(() => {
          data[key] = value2, this.setState({
            data
          });
          let { onUpdate, onDeltaUpdate } = this.props;
          onUpdate(keyPath[keyPath.length - 1], data), onDeltaUpdate({
            type: UPDATE_DELTA_TYPE,
            keyPath,
            deep,
            key,
            newValue: value2,
            oldValue
          }), resolve(void 0);
        }).catch(reject);
      });
    }
    renderCollapsed() {
      let { name, data, keyPath, deep } = this.state, { handleRemove, readOnly, getStyle, dataType, minusMenuElement } = this.props, { minus, collapsed } = getStyle(name, data, keyPath, deep, dataType), isReadOnly = readOnly(name, data, keyPath, deep, dataType), removeItemButton = minusMenuElement && cloneElement(minusMenuElement, {
        onClick: handleRemove,
        className: "rejt-minus-menu",
        style: minus,
        "aria-label": `remove the array '${String(name)}'`
      });
      return react_default.createElement(react_default.Fragment, null, react_default.createElement("span", { style: collapsed }, "[...] ", data.length, " ", data.length === 1 ? "item" : "items"), !isReadOnly && removeItemButton);
    }
    renderNotCollapsed() {
      let { name, data, keyPath, deep, addFormVisible, nextDeep } = this.state, {
        isCollapsed,
        handleRemove,
        onDeltaUpdate,
        readOnly,
        getStyle,
        dataType,
        addButtonElement,
        cancelButtonElement,
        inputElementGenerator,
        textareaElementGenerator,
        minusMenuElement,
        plusMenuElement,
        beforeRemoveAction,
        beforeAddAction,
        beforeUpdateAction,
        logger: logger5,
        onSubmitValueParser
      } = this.props, { minus, plus, delimiter, ul, addForm } = getStyle(name, data, keyPath, deep, dataType), isReadOnly = readOnly(name, data, keyPath, deep, dataType), addItemButton = plusMenuElement && cloneElement(plusMenuElement, {
        onClick: this.handleAddMode,
        className: "rejt-plus-menu",
        style: plus,
        "aria-label": `add a new item to the '${String(name)}' array`
      }), removeItemButton = minusMenuElement && cloneElement(minusMenuElement, {
        onClick: handleRemove,
        className: "rejt-minus-menu",
        style: minus,
        "aria-label": `remove the array '${String(name)}'`
      });
      return react_default.createElement(react_default.Fragment, null, react_default.createElement("span", { className: "rejt-not-collapsed-delimiter", style: delimiter }, "["), !addFormVisible && addItemButton, react_default.createElement("ul", { className: "rejt-not-collapsed-list", style: ul }, data.map((item, index2) => react_default.createElement(
        JsonNode,
        {
          key: index2,
          name: index2.toString(),
          data: item,
          keyPath,
          deep: nextDeep,
          isCollapsed,
          handleRemove: this.handleRemoveItem(index2),
          handleUpdateValue: this.handleEditValue,
          onUpdate: this.onChildUpdate,
          onDeltaUpdate,
          readOnly,
          getStyle,
          addButtonElement,
          cancelButtonElement,
          inputElementGenerator,
          textareaElementGenerator,
          minusMenuElement,
          plusMenuElement,
          beforeRemoveAction,
          beforeAddAction,
          beforeUpdateAction,
          logger: logger5,
          onSubmitValueParser
        }
      ))), !isReadOnly && addFormVisible && react_default.createElement("div", { className: "rejt-add-form", style: addForm }, react_default.createElement(
        JsonAddValue,
        {
          handleAdd: this.handleAddValueAdd,
          handleCancel: this.handleAddValueCancel,
          onlyValue: !0,
          addButtonElement,
          cancelButtonElement,
          inputElementGenerator,
          keyPath,
          deep,
          onSubmitValueParser
        }
      )), react_default.createElement("span", { className: "rejt-not-collapsed-delimiter", style: delimiter }, "]"), !isReadOnly && removeItemButton);
    }
    render() {
      let { name, collapsed, keyPath, deep } = this.state, value2 = collapsed ? this.renderCollapsed() : this.renderNotCollapsed();
      return react_default.createElement(
        JsonNodeAccordion,
        {
          name,
          collapsed,
          deep,
          keyPath,
          onClick: this.handleCollapseMode
        },
        value2
      );
    }
  };
  JsonArray.defaultProps = {
    keyPath: [],
    deep: 0,
    minusMenuElement: react_default.createElement("span", null, " - "),
    plusMenuElement: react_default.createElement("span", null, " + ")
  };
  var JsonFunctionValue = class extends Component {
    constructor(props) {
      super(props);
      let keyPath = [...props.keyPath || [], props.name];
      this.state = {
        value: props.value,
        name: props.name,
        keyPath: keyPath ?? [],
        deep: props.deep ?? 0,
        editEnabled: !1,
        inputRef: null
      }, this.handleEditMode = this.handleEditMode.bind(this), this.refInput = this.refInput.bind(this), this.handleCancelEdit = this.handleCancelEdit.bind(this), this.handleEdit = this.handleEdit.bind(this), this.onKeydown = this.onKeydown.bind(this);
    }
    static getDerivedStateFromProps(props, state3) {
      return props.value !== state3.value ? { value: props.value } : null;
    }
    componentDidUpdate() {
      let { editEnabled, inputRef, name, value: value2, keyPath, deep } = this.state, { readOnly, dataType } = this.props, readOnlyResult = readOnly(name, value2, keyPath, deep, dataType);
      editEnabled && !readOnlyResult && typeof inputRef.focus == "function" && inputRef.focus();
    }
    onKeydown(event) {
      let { inputRef } = this.state;
      event.altKey || event.ctrlKey || event.metaKey || event.shiftKey || event.repeat || inputRef !== event.target || ((event.code === "Enter" || event.key === "Enter") && (event.preventDefault(), this.handleEdit()), (event.code === "Escape" || event.key === "Escape") && (event.preventDefault(), this.handleCancelEdit()));
    }
    handleEdit() {
      let { handleUpdateValue, originalValue, logger: logger5, onSubmitValueParser, keyPath } = this.props, { inputRef, name, deep } = this.state;
      if (!inputRef)
        return;
      let newValue = onSubmitValueParser(!0, keyPath, deep, name, inputRef.value), result = {
        value: newValue,
        key: name
      };
      (handleUpdateValue || Promise.resolve.bind(Promise))(result).then(() => {
        isComponentWillChange(originalValue, newValue) || this.handleCancelEdit();
      }).catch(logger5.error);
    }
    handleEditMode() {
      this.setState({
        editEnabled: !0
      });
    }
    refInput(node) {
      this.state.inputRef = node;
    }
    handleCancelEdit() {
      this.setState({
        editEnabled: !1
      });
    }
    render() {
      let { name, value: value2, editEnabled, keyPath, deep } = this.state, {
        handleRemove,
        originalValue,
        readOnly,
        dataType,
        getStyle,
        textareaElementGenerator,
        minusMenuElement,
        keyPath: comeFromKeyPath = []
      } = this.props, style = getStyle(name, originalValue, keyPath, deep, dataType), result = null, minusElement = null, resultOnlyResult = readOnly(name, originalValue, keyPath, deep, dataType);
      if (editEnabled && !resultOnlyResult) {
        let textareaElement = textareaElementGenerator(
          VALUE,
          comeFromKeyPath,
          deep,
          name,
          originalValue,
          dataType
        ), textareaElementLayout = cloneElement(textareaElement, {
          ref: this.refInput,
          defaultValue: value2,
          onKeyDown: this.onKeydown
        });
        result = react_default.createElement("span", { className: "rejt-edit-form", style: style.editForm }, textareaElementLayout), minusElement = null;
      } else {
        result = react_default.createElement(
          "span",
          {
            className: "rejt-value",
            style: style.value,
            onClick: resultOnlyResult ? void 0 : this.handleEditMode
          },
          value2
        );
        let parentPropertyName = comeFromKeyPath.at(-1), minusMenuLayout = minusMenuElement && cloneElement(minusMenuElement, {
          onClick: handleRemove,
          className: "rejt-minus-menu",
          style: style.minus,
          "aria-label": `remove the function '${String(name)}'${String(parentPropertyName) ? ` from '${String(parentPropertyName)}'` : ""}`
        });
        minusElement = resultOnlyResult ? null : minusMenuLayout;
      }
      return react_default.createElement("li", { className: "rejt-value-node", style: style.li }, react_default.createElement("span", { className: "rejt-name", style: style.name }, name, " :", " "), result, minusElement);
    }
  };
  JsonFunctionValue.defaultProps = {
    keyPath: [],
    deep: 0,
    handleUpdateValue: () => {
    },
    cancelButtonElement: react_default.createElement("button", null, "c"),
    minusMenuElement: react_default.createElement("span", null, " - ")
  };
  var JsonNode = class extends Component {
    constructor(props) {
      super(props), this.state = {
        data: props.data,
        name: props.name,
        keyPath: props.keyPath ?? [],
        deep: props.deep ?? 0
      };
    }
    static getDerivedStateFromProps(props, state3) {
      return props.data !== state3.data ? { data: props.data } : null;
    }
    render() {
      let { data, name, keyPath, deep } = this.state, {
        isCollapsed,
        handleRemove,
        handleUpdateValue,
        onUpdate,
        onDeltaUpdate,
        readOnly,
        getStyle,
        addButtonElement,
        cancelButtonElement,
        inputElementGenerator,
        textareaElementGenerator,
        minusMenuElement,
        plusMenuElement,
        beforeRemoveAction,
        beforeAddAction,
        beforeUpdateAction,
        logger: logger5,
        onSubmitValueParser
      } = this.props, readOnlyTrue = () => !0, dataType = getObjectType(data);
      switch (dataType) {
        case ERROR:
          return react_default.createElement(
            JsonObject,
            {
              data,
              name,
              isCollapsed,
              keyPath,
              deep,
              handleRemove,
              onUpdate,
              onDeltaUpdate,
              readOnly: readOnlyTrue,
              dataType,
              getStyle,
              addButtonElement,
              cancelButtonElement,
              inputElementGenerator,
              textareaElementGenerator,
              minusMenuElement,
              plusMenuElement,
              beforeRemoveAction,
              beforeAddAction,
              beforeUpdateAction,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case OBJECT:
          return react_default.createElement(
            JsonObject,
            {
              data,
              name,
              isCollapsed,
              keyPath,
              deep,
              handleRemove,
              onUpdate,
              onDeltaUpdate,
              readOnly,
              dataType,
              getStyle,
              addButtonElement,
              cancelButtonElement,
              inputElementGenerator,
              textareaElementGenerator,
              minusMenuElement,
              plusMenuElement,
              beforeRemoveAction,
              beforeAddAction,
              beforeUpdateAction,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case ARRAY:
          return react_default.createElement(
            JsonArray,
            {
              data,
              name,
              isCollapsed,
              keyPath,
              deep,
              handleRemove,
              onUpdate,
              onDeltaUpdate,
              readOnly,
              dataType,
              getStyle,
              addButtonElement,
              cancelButtonElement,
              inputElementGenerator,
              textareaElementGenerator,
              minusMenuElement,
              plusMenuElement,
              beforeRemoveAction,
              beforeAddAction,
              beforeUpdateAction,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case STRING:
          return react_default.createElement(
            JsonValue,
            {
              name,
              value: `"${data}"`,
              originalValue: data,
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly,
              dataType,
              getStyle,
              cancelButtonElement,
              inputElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case NUMBER:
          return react_default.createElement(
            JsonValue,
            {
              name,
              value: data,
              originalValue: data,
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly,
              dataType,
              getStyle,
              cancelButtonElement,
              inputElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case BOOLEAN:
          return react_default.createElement(
            JsonValue,
            {
              name,
              value: data ? "true" : "false",
              originalValue: data,
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly,
              dataType,
              getStyle,
              cancelButtonElement,
              inputElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case DATE:
          return react_default.createElement(
            JsonValue,
            {
              name,
              value: data.toISOString(),
              originalValue: data,
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly: readOnlyTrue,
              dataType,
              getStyle,
              cancelButtonElement,
              inputElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case NULL:
          return react_default.createElement(
            JsonValue,
            {
              name,
              value: "null",
              originalValue: "null",
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly,
              dataType,
              getStyle,
              cancelButtonElement,
              inputElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case UNDEFINED:
          return react_default.createElement(
            JsonValue,
            {
              name,
              value: "undefined",
              originalValue: "undefined",
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly,
              dataType,
              getStyle,
              cancelButtonElement,
              inputElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case FUNCTION:
          return react_default.createElement(
            JsonFunctionValue,
            {
              name,
              value: data.toString(),
              originalValue: data,
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly,
              dataType,
              getStyle,
              cancelButtonElement,
              textareaElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case SYMBOL:
          return react_default.createElement(
            JsonValue,
            {
              name,
              value: data.toString(),
              originalValue: data,
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly: readOnlyTrue,
              dataType,
              getStyle,
              cancelButtonElement,
              inputElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        default:
          return null;
      }
    }
  };
  JsonNode.defaultProps = {
    keyPath: [],
    deep: 0
  };
  var JsonObject = class extends Component {
    constructor(props) {
      super(props);
      let keyPath = props.deep === -1 ? [] : [...props.keyPath || [], props.name];
      this.state = {
        name: props.name,
        data: props.data,
        keyPath: keyPath ?? [],
        deep: props.deep ?? 0,
        nextDeep: (props.deep ?? 0) + 1,
        collapsed: props.isCollapsed(keyPath, props.deep ?? 0, props.data),
        addFormVisible: !1
      }, this.handleCollapseMode = this.handleCollapseMode.bind(this), this.handleRemoveValue = this.handleRemoveValue.bind(this), this.handleAddMode = this.handleAddMode.bind(this), this.handleAddValueAdd = this.handleAddValueAdd.bind(this), this.handleAddValueCancel = this.handleAddValueCancel.bind(this), this.handleEditValue = this.handleEditValue.bind(this), this.onChildUpdate = this.onChildUpdate.bind(this), this.renderCollapsed = this.renderCollapsed.bind(this), this.renderNotCollapsed = this.renderNotCollapsed.bind(this);
    }
    static getDerivedStateFromProps(props, state3) {
      return props.data !== state3.data ? { data: props.data } : null;
    }
    onChildUpdate(childKey, childData) {
      let { data, keyPath = [] } = this.state;
      data[childKey] = childData, this.setState({
        data
      });
      let { onUpdate } = this.props, size = keyPath.length;
      onUpdate(keyPath[size - 1], data);
    }
    handleAddMode() {
      this.setState({
        addFormVisible: !0
      });
    }
    handleAddValueCancel() {
      this.setState({
        addFormVisible: !1
      });
    }
    handleAddValueAdd({ key, newValue }) {
      let { data, keyPath = [], nextDeep: deep } = this.state, { beforeAddAction, logger: logger5 } = this.props;
      (beforeAddAction || Promise.resolve.bind(Promise))(key, keyPath, deep, newValue).then(() => {
        data[key] = newValue, this.setState({
          data
        }), this.handleAddValueCancel();
        let { onUpdate, onDeltaUpdate } = this.props;
        onUpdate(keyPath[keyPath.length - 1], data), onDeltaUpdate({
          type: ADD_DELTA_TYPE,
          keyPath,
          deep,
          key,
          newValue
        });
      }).catch(logger5.error);
    }
    handleRemoveValue(key) {
      return () => {
        let { beforeRemoveAction, logger: logger5 } = this.props, { data, keyPath = [], nextDeep: deep } = this.state, oldValue = data[key];
        (beforeRemoveAction || Promise.resolve.bind(Promise))(key, keyPath, deep, oldValue).then(() => {
          let deltaUpdateResult = {
            keyPath,
            deep,
            key,
            oldValue,
            type: REMOVE_DELTA_TYPE
          };
          delete data[key], this.setState({ data });
          let { onUpdate, onDeltaUpdate } = this.props;
          onUpdate(keyPath[keyPath.length - 1], data), onDeltaUpdate(deltaUpdateResult);
        }).catch(logger5.error);
      };
    }
    handleCollapseMode() {
      this.setState((state3) => ({
        collapsed: !state3.collapsed
      }));
    }
    handleEditValue({ key, value: value2 }) {
      return new Promise((resolve, reject) => {
        let { beforeUpdateAction } = this.props, { data, keyPath = [], nextDeep: deep } = this.state, oldValue = data[key];
        (beforeUpdateAction || Promise.resolve.bind(Promise))(key, keyPath, deep, oldValue, value2).then(() => {
          data[key] = value2, this.setState({
            data
          });
          let { onUpdate, onDeltaUpdate } = this.props;
          onUpdate(keyPath[keyPath.length - 1], data), onDeltaUpdate({
            type: UPDATE_DELTA_TYPE,
            keyPath,
            deep,
            key,
            newValue: value2,
            oldValue
          }), resolve();
        }).catch(reject);
      });
    }
    renderCollapsed() {
      let { name, keyPath, deep, data } = this.state, { handleRemove, readOnly, dataType, getStyle, minusMenuElement } = this.props, { minus, collapsed } = getStyle(name, data, keyPath, deep, dataType), keyList = Object.getOwnPropertyNames(data), isReadOnly = readOnly(name, data, keyPath, deep, dataType), removeItemButton = minusMenuElement && cloneElement(minusMenuElement, {
        onClick: handleRemove,
        className: "rejt-minus-menu",
        style: minus,
        "aria-label": `remove the object '${String(name)}'`
      });
      return react_default.createElement(react_default.Fragment, null, react_default.createElement("span", { style: collapsed }, "{...}", " ", keyList.length, " ", keyList.length === 1 ? "key" : "keys"), !isReadOnly && removeItemButton);
    }
    renderNotCollapsed() {
      let { name, data, keyPath, deep, nextDeep, addFormVisible } = this.state, {
        isCollapsed,
        handleRemove,
        onDeltaUpdate,
        readOnly,
        getStyle,
        dataType,
        addButtonElement,
        cancelButtonElement,
        inputElementGenerator,
        textareaElementGenerator,
        minusMenuElement,
        plusMenuElement,
        beforeRemoveAction,
        beforeAddAction,
        beforeUpdateAction,
        logger: logger5,
        onSubmitValueParser
      } = this.props, { minus, plus, addForm, ul, delimiter } = getStyle(name, data, keyPath, deep, dataType), keyList = Object.getOwnPropertyNames(data), isReadOnly = readOnly(name, data, keyPath, deep, dataType), addItemButton = plusMenuElement && cloneElement(plusMenuElement, {
        onClick: this.handleAddMode,
        className: "rejt-plus-menu",
        style: plus,
        "aria-label": `add a new property to the object '${String(name)}'`
      }), removeItemButton = minusMenuElement && cloneElement(minusMenuElement, {
        onClick: handleRemove,
        className: "rejt-minus-menu",
        style: minus,
        "aria-label": `remove the object '${String(name)}'`
      }), list = keyList.map((key) => react_default.createElement(
        JsonNode,
        {
          key,
          name: key,
          data: data[key],
          keyPath,
          deep: nextDeep,
          isCollapsed,
          handleRemove: this.handleRemoveValue(key),
          handleUpdateValue: this.handleEditValue,
          onUpdate: this.onChildUpdate,
          onDeltaUpdate,
          readOnly,
          getStyle,
          addButtonElement,
          cancelButtonElement,
          inputElementGenerator,
          textareaElementGenerator,
          minusMenuElement,
          plusMenuElement,
          beforeRemoveAction,
          beforeAddAction,
          beforeUpdateAction,
          logger: logger5,
          onSubmitValueParser
        }
      ));
      return react_default.createElement(react_default.Fragment, null, react_default.createElement("span", { className: "rejt-not-collapsed-delimiter", style: delimiter }, "{"), !isReadOnly && addItemButton, react_default.createElement("ul", { className: "rejt-not-collapsed-list", style: ul }, list), !isReadOnly && addFormVisible && react_default.createElement("div", { className: "rejt-add-form", style: addForm }, react_default.createElement(
        JsonAddValue,
        {
          handleAdd: this.handleAddValueAdd,
          handleCancel: this.handleAddValueCancel,
          addButtonElement,
          cancelButtonElement,
          inputElementGenerator,
          keyPath,
          deep,
          onSubmitValueParser
        }
      )), react_default.createElement("span", { className: "rejt-not-collapsed-delimiter", style: delimiter }, "}"), !isReadOnly && removeItemButton);
    }
    render() {
      let { name, collapsed, keyPath, deep = 0 } = this.state, value2 = collapsed ? this.renderCollapsed() : this.renderNotCollapsed();
      return react_default.createElement(
        JsonNodeAccordion,
        {
          name,
          collapsed,
          deep,
          keyPath,
          onClick: this.handleCollapseMode
        },
        value2
      );
    }
  };
  JsonObject.defaultProps = {
    keyPath: [],
    deep: 0,
    minusMenuElement: react_default.createElement("span", null, " - "),
    plusMenuElement: react_default.createElement("span", null, " + ")
  };
  var JsonValue = class extends Component {
    constructor(props) {
      super(props);
      let keyPath = [...props.keyPath || [], props.name];
      this.state = {
        value: props.value,
        name: props.name,
        keyPath: keyPath ?? [],
        deep: props.deep ?? 0,
        editEnabled: !1,
        inputRef: null
      }, this.handleEditMode = this.handleEditMode.bind(this), this.refInput = this.refInput.bind(this), this.handleCancelEdit = this.handleCancelEdit.bind(this), this.handleEdit = this.handleEdit.bind(this), this.onKeydown = this.onKeydown.bind(this);
    }
    static getDerivedStateFromProps(props, state3) {
      return props.value !== state3.value ? { value: props.value } : null;
    }
    componentDidUpdate() {
      let { editEnabled, inputRef, name, value: value2, keyPath, deep } = this.state, { readOnly, dataType } = this.props, isReadOnly = readOnly(name, value2, keyPath, deep, dataType);
      editEnabled && !isReadOnly && typeof inputRef.focus == "function" && inputRef.focus();
    }
    onKeydown(event) {
      let { inputRef } = this.state;
      event.altKey || event.ctrlKey || event.metaKey || event.shiftKey || event.repeat || inputRef !== event.target || ((event.code === "Enter" || event.key === "Enter") && (event.preventDefault(), this.handleEdit()), (event.code === "Escape" || event.key === "Escape") && (event.preventDefault(), this.handleCancelEdit()));
    }
    handleEdit() {
      let { handleUpdateValue, originalValue, logger: logger5, onSubmitValueParser, keyPath } = this.props, { inputRef, name, deep } = this.state;
      if (!inputRef)
        return;
      let newValue = onSubmitValueParser(!0, keyPath, deep, name, inputRef.value), result = {
        value: newValue,
        key: name
      };
      (handleUpdateValue || Promise.resolve.bind(Promise))(result).then(() => {
        isComponentWillChange(originalValue, newValue) || this.handleCancelEdit();
      }).catch(logger5.error);
    }
    handleEditMode() {
      this.setState({
        editEnabled: !0
      });
    }
    refInput(node) {
      this.state.inputRef = node;
    }
    handleCancelEdit() {
      this.setState({
        editEnabled: !1
      });
    }
    render() {
      let { name, value: value2, editEnabled, keyPath, deep } = this.state, {
        handleRemove,
        originalValue,
        readOnly,
        dataType,
        getStyle,
        inputElementGenerator,
        minusMenuElement,
        keyPath: comeFromKeyPath
      } = this.props, style = getStyle(name, originalValue, keyPath, deep, dataType), isReadOnly = readOnly(name, originalValue, keyPath, deep, dataType), isEditing = editEnabled && !isReadOnly, inputElement = inputElementGenerator(
        VALUE,
        comeFromKeyPath,
        deep,
        name,
        originalValue,
        dataType
      ), inputElementLayout = cloneElement(inputElement, {
        ref: this.refInput,
        defaultValue: JSON.stringify(originalValue),
        onKeyDown: this.onKeydown
      }), parentPropertyName = keyPath.at(-2), minusMenuLayout = minusMenuElement && cloneElement(minusMenuElement, {
        onClick: handleRemove,
        className: "rejt-minus-menu",
        style: style.minus,
        "aria-label": `remove the property '${String(name)}' with value '${String(originalValue)}'${String(parentPropertyName) ? ` from '${String(parentPropertyName)}'` : ""}`
      });
      return react_default.createElement("li", { className: "rejt-value-node", style: style.li }, react_default.createElement("span", { className: "rejt-name", style: style.name }, name, " : "), isEditing ? react_default.createElement("span", { className: "rejt-edit-form", style: style.editForm }, inputElementLayout) : react_default.createElement(
        "span",
        {
          className: "rejt-value",
          style: style.value,
          onClick: isReadOnly ? void 0 : this.handleEditMode
        },
        String(value2)
      ), !isReadOnly && !isEditing && minusMenuLayout);
    }
  };
  JsonValue.defaultProps = {
    keyPath: [],
    deep: 0,
    handleUpdateValue: () => Promise.resolve(),
    cancelButtonElement: react_default.createElement("button", null, "c"),
    minusMenuElement: react_default.createElement("span", null, " - ")
  };
  function parse3(string) {
    let result = string;
    if (result.indexOf("function") === 0)
      return (0, eval)(`(${result})`);
    try {
      result = JSON.parse(string);
    } catch {
    }
    return result;
  }
  var object = {
    minus: {
      color: "red"
    },
    plus: {
      color: "green"
    },
    collapsed: {
      color: "grey"
    },
    delimiter: {},
    ul: {
      padding: "0px",
      margin: "0 0 0 25px",
      listStyle: "none"
    },
    name: {
      color: "#2287CD"
    },
    addForm: {}
  }, array = {
    minus: {
      color: "red"
    },
    plus: {
      color: "green"
    },
    collapsed: {
      color: "grey"
    },
    delimiter: {},
    ul: {
      padding: "0px",
      margin: "0 0 0 25px",
      listStyle: "none"
    },
    name: {
      color: "#2287CD"
    },
    addForm: {}
  }, value = {
    minus: {
      color: "red"
    },
    editForm: {},
    value: {
      color: "#7bba3d"
    },
    li: {
      minHeight: "22px",
      lineHeight: "22px",
      outline: "0px"
    },
    name: {
      color: "#2287CD"
    }
  }, JsonTree = class extends Component {
    constructor(props) {
      super(props), this.state = {
        data: props.data,
        rootName: props.rootName
      }, this.onUpdate = this.onUpdate.bind(this), this.removeRoot = this.removeRoot.bind(this);
    }
    static getDerivedStateFromProps(props, state3) {
      return props.data !== state3.data || props.rootName !== state3.rootName ? {
        data: props.data,
        rootName: props.rootName
      } : null;
    }
    onUpdate(key, data) {
      this.setState({ data }), this.props.onFullyUpdate?.(data);
    }
    removeRoot() {
      this.onUpdate(null, null);
    }
    render() {
      let { data, rootName } = this.state, {
        isCollapsed,
        onDeltaUpdate,
        readOnly,
        getStyle,
        addButtonElement,
        cancelButtonElement,
        inputElement,
        textareaElement,
        minusMenuElement,
        plusMenuElement,
        beforeRemoveAction,
        beforeAddAction,
        beforeUpdateAction,
        logger: logger5,
        onSubmitValueParser,
        fallback = null
      } = this.props, dataType = getObjectType(data), readOnlyFunction = readOnly;
      getObjectType(readOnly) === "Boolean" && (readOnlyFunction = () => readOnly);
      let inputElementFunction = inputElement;
      inputElement && getObjectType(inputElement) !== "Function" && (inputElementFunction = () => inputElement);
      let textareaElementFunction = textareaElement;
      return textareaElement && getObjectType(textareaElement) !== "Function" && (textareaElementFunction = () => textareaElement), dataType === "Object" || dataType === "Array" ? react_default.createElement("div", { className: "rejt-tree" }, react_default.createElement(
        JsonNode,
        {
          data,
          name: rootName || "root",
          deep: -1,
          isCollapsed: isCollapsed ?? (() => !1),
          onUpdate: this.onUpdate,
          onDeltaUpdate: onDeltaUpdate ?? (() => {
          }),
          readOnly: readOnlyFunction,
          getStyle: getStyle ?? (() => ({})),
          addButtonElement,
          cancelButtonElement,
          inputElementGenerator: inputElementFunction,
          textareaElementGenerator: textareaElementFunction,
          minusMenuElement,
          plusMenuElement,
          handleRemove: this.removeRoot,
          beforeRemoveAction,
          beforeAddAction,
          beforeUpdateAction,
          logger: logger5 ?? {},
          onSubmitValueParser: onSubmitValueParser ?? ((val) => val)
        }
      )) : fallback;
    }
  };
  JsonTree.defaultProps = {
    rootName: "root",
    isCollapsed: (keyPath, deep) => deep !== -1,
    getStyle: (keyName, data, keyPath, deep, dataType) => {
      switch (dataType) {
        case "Object":
        case "Error":
          return object;
        case "Array":
          return array;
        default:
          return value;
      }
    },
    readOnly: () => !1,
    onFullyUpdate: () => {
    },
    onDeltaUpdate: () => {
    },
    beforeRemoveAction: () => Promise.resolve(),
    beforeAddAction: () => Promise.resolve(),
    beforeUpdateAction: () => Promise.resolve(),
    logger: { error: () => {
    } },
    onSubmitValueParser: (isEditMode, keyPath, deep, name, rawValue) => parse3(rawValue),
    inputElement: () => react_default.createElement("input", null),
    textareaElement: () => react_default.createElement("textarea", null),
    fallback: null
  };
  var { window: globalWindow } = globalThis, Wrapper5 = styled.div(({ theme: theme3 }) => ({
    position: "relative",
    display: "flex",
    isolation: "isolate",
    ".rejt-tree": {
      marginLeft: "1rem",
      fontSize: "13px",
      listStyleType: "none"
    },
    ".rejt-value-node:hover": {
      "& > button": {
        opacity: 1
      }
    },
    ".rejt-add-form": {
      marginLeft: 10
    },
    ".rejt-add-value-node": {
      display: "inline-flex",
      alignItems: "center"
    },
    ".rejt-name": {
      lineHeight: "22px"
    },
    ".rejt-not-collapsed-delimiter": {
      lineHeight: "22px"
    },
    ".rejt-value": {
      display: "inline-block",
      border: "1px solid transparent",
      borderRadius: 4,
      margin: "1px 0",
      padding: "0 4px",
      cursor: "text",
      color: theme3.color.defaultText
    },
    ".rejt-value-node:hover > .rejt-value": {
      background: theme3.base === "light" ? theme3.color.lighter : "hsl(0 0 100 / 0.02)",
      borderColor: theme3.appBorderColor
    }
  })), ButtonInline = styled.button(({ theme: theme3, primary }) => ({
    border: 0,
    height: 20,
    margin: 1,
    borderRadius: 4,
    background: primary ? theme3.color.secondary : "transparent",
    color: primary ? theme3.color.lightest : theme3.color.dark,
    fontWeight: primary ? "bold" : "normal",
    cursor: "pointer"
  })), ActionButton = styled.button(({ theme: theme3 }) => ({
    background: "none",
    border: 0,
    display: "inline-flex",
    verticalAlign: "middle",
    padding: 3,
    marginLeft: 5,
    color: theme3.textMutedColor,
    opacity: 0,
    transition: "opacity 0.2s",
    cursor: "pointer",
    position: "relative",
    svg: {
      width: 9,
      height: 9
    },
    ":disabled": {
      cursor: "not-allowed"
    },
    ":hover, :focus-visible": {
      opacity: 1
    },
    "&:hover:not(:disabled), &:focus-visible:not(:disabled)": {
      "&.rejt-plus-menu": {
        color: theme3.color.ancillary
      },
      "&.rejt-minus-menu": {
        color: theme3.color.negative
      }
    }
  })), Input2 = styled.input(({ theme: theme3, placeholder }) => ({
    outline: 0,
    margin: placeholder ? 1 : "1px 0",
    padding: "3px 4px",
    color: theme3.color.defaultText,
    background: theme3.background.app,
    border: `1px solid ${theme3.appBorderColor}`,
    borderRadius: 4,
    lineHeight: "14px",
    width: placeholder === "Key" ? 80 : 120,
    "&:focus": {
      border: `1px solid ${theme3.color.secondary}`
    }
  })), RawButton = styled(ToggleButton)({
    position: "absolute",
    zIndex: 2,
    top: 2,
    right: 2
  }), RawInput = styled(Form.Textarea)(({ theme: theme3 }) => ({
    flex: 1,
    padding: "7px 6px",
    fontFamily: theme3.typography.fonts.mono,
    fontSize: "12px",
    lineHeight: "18px",
    "&::placeholder": {
      fontFamily: theme3.typography.fonts.base,
      fontSize: "13px"
    },
    "&:placeholder-shown": {
      padding: "7px 10px"
    }
  })), ENTER_EVENT = {
    bubbles: !0,
    cancelable: !0,
    key: "Enter",
    code: "Enter",
    keyCode: 13
  }, dispatchEnterKey = (event) => {
    event.currentTarget.dispatchEvent(new globalWindow.KeyboardEvent("keydown", ENTER_EVENT));
  }, selectValue = (event) => {
    event.currentTarget.select();
  }, getCustomStyleFunction = (theme3) => () => ({
    name: {
      color: theme3.color.secondary
    },
    collapsed: {
      color: theme3.color.dark
    },
    ul: {
      listStyle: "none",
      margin: "0 0 0 1rem",
      padding: 0
    },
    li: {
      outline: 0
    }
  }), ObjectControl = ({ name, value: value2, onChange, argType }) => {
    let theme3 = useTheme(), data = useMemo(() => value2 && cloneDeep(value2), [value2]), hasData = data != null, [showRaw, setShowRaw] = useState(!hasData), [parseError, setParseError] = useState(null), readonly = !!argType?.table?.readonly, updateRaw = useCallback(
      (raw) => {
        try {
          raw && onChange(JSON.parse(raw)), setParseError(null);
        } catch (e2) {
          setParseError(e2);
        }
      },
      [onChange]
    ), [forceVisible, setForceVisible] = useState(!1), onForceVisible = useCallback(() => {
      onChange({}), setForceVisible(!0);
    }, [setForceVisible]), htmlElRef = useRef(null);
    useEffect(() => {
      forceVisible && htmlElRef.current && htmlElRef.current.select();
    }, [forceVisible]);
    let jsonString = useMemo(() => JSON.stringify(data ?? "", null, 2), [data]);
    if (!hasData)
      return react_default.createElement(
        Button,
        {
          ariaLabel: !1,
          disabled: readonly,
          id: getControlSetterButtonId(name),
          onClick: onForceVisible
        },
        "Set object"
      );
    let rawJSONForm = react_default.createElement(
      RawInput,
      {
        ref: htmlElRef,
        id: getControlId(name),
        minRows: 3,
        name,
        key: jsonString,
        defaultValue: jsonString,
        onBlur: (event) => updateRaw(event.target.value),
        placeholder: "Edit JSON string...",
        autoFocus: forceVisible,
        valid: parseError ? "error" : void 0,
        readOnly: readonly
      }
    ), isObjectOrArray = Array.isArray(value2) || typeof value2 == "object" && value2?.constructor === Object;
    return react_default.createElement(Wrapper5, null, isObjectOrArray && react_default.createElement(
      RawButton,
      {
        disabled: readonly,
        pressed: showRaw,
        ariaLabel: `Edit the ${name} properties in JSON format`,
        onClick: (e2) => {
          e2.preventDefault(), setShowRaw((isRaw) => !isRaw);
        }
      },
      "Edit JSON"
    ), showRaw ? rawJSONForm : react_default.createElement(
      JsonTree,
      {
        readOnly: readonly || !isObjectOrArray,
        isCollapsed: isObjectOrArray ? (
          /* default value */
          void 0
        ) : () => !0,
        data,
        rootName: name,
        onFullyUpdate: onChange,
        getStyle: getCustomStyleFunction(theme3),
        cancelButtonElement: react_default.createElement(ButtonInline, { type: "button" }, "Cancel"),
        addButtonElement: react_default.createElement(ButtonInline, { type: "submit", primary: !0 }, "Save"),
        plusMenuElement: react_default.createElement(ActionButton, { type: "button" }, react_default.createElement(AddIcon, null)),
        minusMenuElement: react_default.createElement(ActionButton, { type: "button" }, react_default.createElement(SubtractIcon, null)),
        inputElement: (_22, __, ___, key) => key ? react_default.createElement(Input2, { onFocus: selectValue, onBlur: dispatchEnterKey }) : react_default.createElement(Input2, null),
        fallback: rawJSONForm
      }
    ));
  }, RangeInput = styled.input(
    ({ theme: theme3, min, max, value: value2, disabled }) => {
      let trackBaseStyles = {
        background: theme3.base === "light" ? `linear-gradient(to right, 
          ${theme3.color.green} 0%, ${theme3.color.green} ${(value2 - min) / (max - min) * 100}%, 
          ${curriedDarken$1(0.02, theme3.input.background)} ${(value2 - min) / (max - min) * 100}%, 
          ${curriedDarken$1(0.02, theme3.input.background)} 100%)` : `linear-gradient(to right, 
          ${theme3.color.green} 0%, ${theme3.color.green} ${(value2 - min) / (max - min) * 100}%, 
          ${curriedLighten$1(0.02, theme3.input.background)} ${(value2 - min) / (max - min) * 100}%, 
          ${curriedLighten$1(0.02, theme3.input.background)} 100%)`,
        borderRadius: 6,
        boxShadow: `${theme3.base == "dark" ? "hsl(0 0 100 / 0.4)" : "hsl(0 0 0 / 0.44)"} 0 0 0 1px inset`,
        cursor: disabled ? "not-allowed" : "pointer",
        height: 6,
        width: "100%"
      }, trackFocusStyles = {
        borderColor: rgba(theme3.color.secondary, 0.4)
      }, thumbBaseStyles = {
        width: 16,
        height: 16,
        borderRadius: 50,
        cursor: disabled ? "not-allowed" : "grab",
        background: theme3.input.background,
        border: `1px solid ${theme3.base == "dark" ? "hsl(0 0 100 / 0.4)" : "hsl(0 0 0 / 0.44)"}`,
        boxShadow: theme3.base === "light" ? `0 1px 3px 0px ${rgba(theme3.appBorderColor, 0.2)}` : "unset",
        transition: "all 150ms ease-out"
      }, thumbHoverStyles = {
        background: `${curriedDarken$1(0.05, theme3.input.background)}`,
        transform: "scale3d(1.1, 1.1, 1.1) translateY(-1px)",
        transition: "all 50ms ease-out"
      }, thumbActiveStyles = {
        background: `${theme3.input.background}`,
        transform: "scale3d(1, 1, 1) translateY(0px)"
      }, thumbFocusStyles = {
        borderColor: theme3.color.secondary,
        boxShadow: theme3.base === "light" ? `0 0px 5px 0px ${theme3.color.secondary}` : "unset"
      };
      return {
        // Restyled using http://danielstern.ca/range.css/#/
        appearance: "none",
        backgroundColor: "transparent",
        width: "100%",
        // Track styles
        "&::-webkit-slider-runnable-track": trackBaseStyles,
        "&::-moz-range-track": trackBaseStyles,
        "&::-ms-track": {
          ...trackBaseStyles,
          color: "transparent"
        },
        // Thumb styles
        "&::-moz-range-thumb": {
          ...thumbBaseStyles,
          "&:hover": thumbHoverStyles,
          "&:active": thumbActiveStyles
        },
        "&::-webkit-slider-thumb": {
          ...thumbBaseStyles,
          marginTop: "-6px",
          appearance: "none",
          "&:hover": thumbHoverStyles,
          "&:active": thumbActiveStyles
        },
        "&::-ms-thumb": {
          ...thumbBaseStyles,
          marginTop: 0,
          "&:hover": thumbHoverStyles,
          "&:active": thumbActiveStyles
        },
        "&:focus": {
          outline: "none",
          "&::-webkit-slider-runnable-track": trackFocusStyles,
          "&::-moz-range-track": trackFocusStyles,
          "&::-ms-track": trackFocusStyles,
          "&::-webkit-slider-thumb": thumbFocusStyles,
          "&::-moz-range-thumb": thumbFocusStyles,
          "&::-ms-thumb": thumbFocusStyles
        },
        "&::-ms-fill-lower": {
          borderRadius: 6
        },
        "&::-ms-fill-upper": {
          borderRadius: 6
        },
        "@supports (-ms-ime-align:auto)": { "input[type=range]": { margin: "0" } }
      };
    }
  ), RangeLabel = styled.span({
    paddingLeft: 5,
    paddingRight: 5,
    fontSize: 12,
    whiteSpace: "nowrap",
    fontFeatureSettings: "tnum",
    fontVariantNumeric: "tabular-nums"
  }), RangeCurrentAndMaxLabel = styled(RangeLabel)(({ numberOFDecimalsPlaces, max }) => ({
    // Fixed width of "current / max" label to avoid slider width changes
    // 3 = size of separator " / "
    width: `${numberOFDecimalsPlaces + max.toString().length * 2 + 3}ch`,
    textAlign: "right",
    flexShrink: 0
  })), RangeWrapper = styled.div(({ readOnly }) => ({
    display: "flex",
    alignItems: "center",
    width: "100%",
    opacity: readOnly ? 0.5 : 1
  }));
  function getNumberOfDecimalPlaces(number) {
    let match = number.toString().match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
    return match ? Math.max(
      0,
      // Number of digits right of decimal point.
      (match[1] ? match[1].length : 0) - // Adjust for scientific notation.
      (match[2] ? +match[2] : 0)
    ) : 0;
  }
  var RangeControl = ({
    name,
    value: value2,
    onChange,
    min = 0,
    max = 100,
    step: step2 = 1,
    onBlur,
    onFocus,
    argType
  }) => {
    let handleChange = (event) => {
      onChange(parse2(event.target.value));
    }, hasValue = value2 !== void 0, numberOFDecimalsPlaces = useMemo(() => getNumberOfDecimalPlaces(step2), [step2]), readonly = !!argType?.table?.readonly, controlId = getControlId(name);
    return react_default.createElement(RangeWrapper, { readOnly: readonly }, react_default.createElement("label", { htmlFor: controlId, className: "sb-sr-only" }, name), react_default.createElement(RangeLabel, null, min), react_default.createElement(
      RangeInput,
      {
        id: controlId,
        type: "range",
        disabled: readonly,
        onChange: handleChange,
        name,
        min,
        max,
        step: step2,
        onFocus,
        onBlur,
        value: value2 ?? min
      }
    ), react_default.createElement(RangeCurrentAndMaxLabel, { numberOFDecimalsPlaces, max }, hasValue ? value2.toFixed(numberOFDecimalsPlaces) : "--", " / ", max));
  }, Wrapper6 = styled.label({
    display: "flex"
  }), MaxLength = styled.div(({ isMaxed }) => ({
    marginLeft: "0.75rem",
    paddingTop: "0.35rem",
    color: isMaxed ? "red" : void 0
  })), TextControl = ({
    name,
    value: value2,
    onChange,
    onFocus,
    onBlur,
    maxLength,
    argType
  }) => {
    let handleChange = (event) => {
      onChange(event.target.value);
    }, readonly = !!argType?.table?.readonly, [forceVisible, setForceVisible] = useState(!1), onForceVisible = useCallback(() => {
      onChange(""), setForceVisible(!0);
    }, [setForceVisible]);
    if (value2 === void 0)
      return react_default.createElement(
        Button,
        {
          ariaLabel: !1,
          variant: "outline",
          size: "medium",
          disabled: readonly,
          id: getControlSetterButtonId(name),
          onClick: onForceVisible
        },
        "Set string"
      );
    let isValid = typeof value2 == "string";
    return react_default.createElement(Wrapper6, null, react_default.createElement(
      Form.Textarea,
      {
        id: getControlId(name),
        maxLength,
        onChange: handleChange,
        disabled: readonly,
        size: "flex",
        placeholder: "Edit string...",
        autoFocus: forceVisible,
        valid: isValid ? void 0 : "error",
        name,
        value: isValid ? value2 : "",
        onFocus,
        onBlur
      }
    ), maxLength && react_default.createElement(MaxLength, { isMaxed: value2?.length === maxLength }, value2?.length ?? 0, " / ", maxLength));
  }, FileInput = styled(Form.Input)({
    padding: 10
  });
  function revokeOldUrls(urls) {
    urls.forEach((url) => {
      url.startsWith("blob:") && URL.revokeObjectURL(url);
    });
  }
  var FilesControl = ({
    onChange,
    name,
    accept = "image/*",
    value: value2,
    argType
  }) => {
    let inputElement = useRef(null), readonly = argType?.control?.readOnly;
    function handleFileChange(e2) {
      if (!e2.target.files)
        return;
      let fileUrls = Array.from(e2.target.files).map((file) => URL.createObjectURL(file));
      onChange(fileUrls), revokeOldUrls(value2 || []);
    }
    useEffect(() => {
      value2 == null && inputElement.current && (inputElement.current.value = "");
    }, [value2, name]);
    let controlId = getControlId(name);
    return react_default.createElement(react_default.Fragment, null, react_default.createElement("label", { htmlFor: controlId, className: "sb-sr-only" }, name), react_default.createElement(
      FileInput,
      {
        ref: inputElement,
        id: controlId,
        type: "file",
        name,
        multiple: !0,
        disabled: readonly,
        onChange: handleFileChange,
        accept,
        size: "flex"
      }
    ));
  }, LazyColorControl = lazy(() => Promise.resolve().then(() => (init_Color_XESOIGZP(), Color_XESOIGZP_exports))), ColorControl2 = (props) => react_default.createElement(Suspense, { fallback: react_default.createElement("div", null) }, react_default.createElement(LazyColorControl, { ...props })), Controls2 = {
    array: ObjectControl,
    object: ObjectControl,
    boolean: BooleanControl,
    color: ColorControl2,
    date: DateControl,
    number: NumberControl,
    check: OptionsControl,
    "inline-check": OptionsControl,
    radio: OptionsControl,
    "inline-radio": OptionsControl,
    select: OptionsControl,
    "multi-select": OptionsControl,
    range: RangeControl,
    text: TextControl,
    file: FilesControl
  }, NoControl = () => react_default.createElement(react_default.Fragment, null, "-"), ArgControl = ({ row, arg, updateArgs, isHovered }) => {
    let { key, control } = row, [isFocused, setFocused] = useState(!1), [boxedValue, setBoxedValue] = useState({ value: arg });
    useEffect(() => {
      isFocused || setBoxedValue({ value: arg });
    }, [isFocused, arg]);
    let onChange = useCallback(
      (argVal) => (setBoxedValue({ value: argVal }), updateArgs({ [key]: argVal }), argVal),
      [updateArgs, key]
    ), onBlur = useCallback(() => setFocused(!1), []), onFocus = useCallback(() => setFocused(!0), []);
    if (!control || control.disable) {
      let canBeSetup = control?.disable !== !0 && row?.type?.name !== "function";
      return isHovered && canBeSetup ? react_default.createElement(
        Link,
        {
          href: "https://storybook.js.org/docs/essentials/controls?ref=ui",
          target: "_blank",
          withArrow: !0
        },
        "Setup controls"
      ) : react_default.createElement(NoControl, null);
    }
    let props = { name: key, argType: row, value: boxedValue.value, onChange, onBlur, onFocus }, Control = Controls2[control.type] || NoControl;
    return react_default.createElement(Control, { ...props, ...control, controlType: control.type });
  }, Table2 = styled.table(({ theme: theme3 }) => ({
    "&&": {
      // Escape default table styles
      borderCollapse: "collapse",
      borderSpacing: 0,
      border: "none",
      tr: {
        border: "none !important",
        background: "none"
      },
      "td, th": {
        padding: 0,
        border: "none",
        width: "auto!important"
      },
      // End escape
      marginTop: 0,
      marginBottom: 0,
      "th:first-of-type, td:first-of-type": {
        paddingLeft: 0
      },
      "th:last-of-type, td:last-of-type": {
        paddingRight: 0
      },
      td: {
        paddingTop: 0,
        paddingBottom: 4,
        "&:not(:first-of-type)": {
          paddingLeft: 10,
          paddingRight: 0
        }
      },
      tbody: {
        boxShadow: "none",
        border: "none"
      },
      code: codeCommon({ theme: theme3 }),
      div: {
        span: {
          fontWeight: "bold"
        }
      },
      "& code": {
        margin: 0,
        display: "inline-block",
        fontSize: theme3.typography.size.s1
      }
    }
  })), ArgJsDoc = ({ tags }) => {
    let params = (tags.params || []).filter((x22) => x22.description), hasDisplayableParams = params.length !== 0, hasDisplayableDeprecated = tags.deprecated != null, hasDisplayableReturns = tags.returns != null && tags.returns.description != null;
    return !hasDisplayableParams && !hasDisplayableReturns && !hasDisplayableDeprecated ? null : react_default.createElement(react_default.Fragment, null, react_default.createElement(Table2, null, react_default.createElement("tbody", null, hasDisplayableDeprecated && react_default.createElement("tr", { key: "deprecated" }, react_default.createElement("td", { colSpan: 2 }, react_default.createElement("strong", null, "Deprecated"), ": ", tags.deprecated?.toString())), hasDisplayableParams && params.map((x22) => react_default.createElement("tr", { key: x22.name }, react_default.createElement("td", null, react_default.createElement("code", null, x22.name)), react_default.createElement("td", null, x22.description))), hasDisplayableReturns && react_default.createElement("tr", { key: "returns" }, react_default.createElement("td", null, react_default.createElement("code", null, "Returns")), react_default.createElement("td", null, tags.returns?.description)))));
  }, ITEMS_BEFORE_EXPANSION = 8, Summary = styled.div(({ isExpanded }) => ({
    display: "flex",
    flexDirection: isExpanded ? "column" : "row",
    flexWrap: "wrap",
    alignItems: "flex-start",
    marginBottom: "-4px",
    minWidth: 100
  })), DetailsContainer = styled.details({
    display: "flex",
    flexDirection: "column",
    summary: {
      order: 2
    },
    "summary::-webkit-details-marker": {
      display: "none"
    },
    "summary::marker": {
      content: "none"
    }
  }), AlignedDetails = styled.div({
    display: "flex",
    flexDirection: "column",
    flexWrap: "wrap",
    alignItems: "flex-start"
  }), Text3 = styled.span(codeCommon, ({ theme: theme3, simple = !1 }) => ({
    flex: "0 0 auto",
    fontFamily: theme3.typography.fonts.mono,
    fontSize: theme3.typography.size.s1,
    wordBreak: "break-word",
    whiteSpace: "normal",
    maxWidth: "100%",
    margin: 0,
    marginRight: "4px",
    marginBottom: "4px",
    paddingTop: "2px",
    paddingBottom: "2px",
    lineHeight: "13px",
    ...simple && {
      background: "transparent",
      border: "0 none",
      paddingLeft: 0
    }
  })), ExpandButton = styled.summary(({ theme: theme3 }) => ({
    fontFamily: theme3.typography.fonts.mono,
    color: theme3.color.secondary,
    cursor: "pointer",
    lineHeight: "normal",
    margin: "0 0 4px",
    padding: "1px 6px",
    background: "none",
    border: "none"
  })), Expandable = styled.button(codeCommon, ({ theme: theme3 }) => ({
    fontFamily: theme3.typography.fonts.mono,
    color: theme3.color.secondary,
    fontSize: theme3.typography.size.s1,
    // overrides codeCommon
    margin: 0,
    whiteSpace: "nowrap",
    display: "flex",
    alignItems: "center",
    cursor: "pointer",
    "&:hover": {
      border: theme3.base === "light" ? "1px solid hsl(0 0 0 / 0.15)" : "1px solid hsl(0 0 100 / 0.15)"
    },
    "&:focus-visible": {
      outline: `2px solid ${theme3.color.secondary}`,
      outlineOffset: "2px"
    }
  })), Detail = styled.div(({ theme: theme3 }) => ({
    minWidth: 200,
    maxWidth: 800,
    paddingRight: 16,
    // Don't remove the mono fontFamily here even if it seems useless, this is used by the browser to calculate the length of a "ch" unit.
    fontFamily: theme3.typography.fonts.mono,
    fontSize: theme3.typography.size.s1,
    // Most custom stylesheet will reset the box-sizing to "border-box" and will break the tooltip.
    boxSizing: "content-box",
    "& code": {
      padding: "0 !important"
    }
  })), ChevronUpIcon2 = styled(ChevronSmallUpIcon)({
    marginLeft: 4
  }), ChevronDownIcon2 = styled(ChevronSmallDownIcon)({
    marginLeft: 4
  }), EmptyArg = () => react_default.createElement("span", null, "-"), ArgText = ({ text, simple }) => react_default.createElement(Text3, { simple }, text), getSummaryItems = (summary) => {
    if (!summary)
      return [summary];
    let summaryItems = summary.split("|").map((value2) => value2.trim());
    return uniq(summaryItems);
  }, renderSummaryItems = (summaryItems) => summaryItems.slice(0, ITEMS_BEFORE_EXPANSION).map((item) => react_default.createElement(ArgText, { key: item, text: item === "" ? '""' : item })), renderExpandedItems = (summaryItems) => summaryItems.slice(ITEMS_BEFORE_EXPANSION).map((item) => react_default.createElement(ArgText, { key: item, text: item === "" ? '""' : item })), ArgSummary = ({ value: value2, initialExpandedArgs }) => {
    let { summary, detail } = value2, [isOpen, setIsOpen] = useState(!1), [isExpanded, setIsExpanded] = useState(initialExpandedArgs || !1);
    if (summary == null)
      return null;
    let summaryAsString = typeof summary.toString == "function" ? summary.toString() : summary;
    if (detail == null) {
      if (/[(){}[\]<>]/.test(summaryAsString))
        return react_default.createElement(ArgText, { text: summaryAsString });
      let summaryItems = getSummaryItems(summaryAsString), itemsCount = summaryItems.length;
      return itemsCount > ITEMS_BEFORE_EXPANSION ? react_default.createElement(Summary, { isExpanded }, renderSummaryItems(summaryItems), react_default.createElement(DetailsContainer, { open: isExpanded, onToggle: (e2) => setIsExpanded(e2.currentTarget.open) }, react_default.createElement(AlignedDetails, null, renderExpandedItems(summaryItems)), react_default.createElement(ExpandButton, { role: "button" }, isExpanded ? "Show less..." : `Show ${itemsCount - ITEMS_BEFORE_EXPANSION} more...`))) : react_default.createElement(Summary, null, renderSummaryItems(summaryItems));
    }
    return react_default.createElement(
      PopoverProvider,
      {
        placement: "bottom",
        visible: isOpen,
        onVisibleChange: (isVisible) => {
          setIsOpen(isVisible);
        },
        hasCloseButton: !0,
        popover: react_default.createElement(Detail, null, react_default.createElement(SyntaxHighlighter, { language: "jsx", format: !1 }, detail))
      },
      react_default.createElement(Expandable, { className: "sbdocs-expandable" }, react_default.createElement("span", null, summaryAsString), isOpen ? react_default.createElement(ChevronUpIcon2, null) : react_default.createElement(ChevronDownIcon2, null))
    );
  }, ArgValue = ({ value: value2, initialExpandedArgs }) => value2 == null ? react_default.createElement(EmptyArg, null) : react_default.createElement(ArgSummary, { value: value2, initialExpandedArgs }), Name = styled.span({ fontWeight: "bold" }), Required = styled.span(({ theme: theme3 }) => ({
    color: theme3.color.negative,
    fontFamily: theme3.typography.fonts.mono,
    cursor: "help"
  })), Description = styled.div(({ theme: theme3 }) => ({
    "&&": {
      p: {
        margin: "0 0 10px 0"
      },
      a: {
        color: theme3.color.secondary
      }
    },
    code: {
      ...codeCommon({ theme: theme3 }),
      fontSize: 12,
      fontFamily: theme3.typography.fonts.mono
    },
    "& code": {
      margin: 0,
      display: "inline-block"
    },
    "& pre > code": {
      whiteSpace: "pre-wrap"
    }
  })), Type = styled.div(({ theme: theme3, hasDescription }) => ({
    color: theme3.base === "light" ? curriedTransparentize$1(0.1, theme3.color.defaultText) : curriedTransparentize$1(0.2, theme3.color.defaultText),
    marginTop: hasDescription ? 4 : 0
  })), TypeWithJsDoc = styled.div(({ theme: theme3, hasDescription }) => ({
    color: theme3.base === "light" ? curriedTransparentize$1(0.1, theme3.color.defaultText) : curriedTransparentize$1(0.2, theme3.color.defaultText),
    marginTop: hasDescription ? 12 : 0,
    marginBottom: 12
  })), StyledTd = styled.td(({ expandable }) => ({
    paddingLeft: expandable ? "40px !important" : "20px !important"
  })), toSummary = (value2) => value2 && { summary: typeof value2 == "string" ? value2 : value2.name }, ArgRow = (props) => {
    let [isHovered, setIsHovered] = useState(!1), { row, updateArgs, compact, expandable, initialExpandedArgs } = props, { name, description } = row, table = row.table || {}, type = table.type || toSummary(row.type), defaultValue = table.defaultValue || row.defaultValue, required = row.type?.required, hasDescription = description != null && description !== "";
    return react_default.createElement("tr", { onMouseEnter: () => setIsHovered(!0), onMouseLeave: () => setIsHovered(!1) }, react_default.createElement(StyledTd, { expandable: expandable ?? !1 }, react_default.createElement(Name, null, name), required ? react_default.createElement(Required, { title: "Required" }, "*") : null), compact ? null : react_default.createElement("td", null, hasDescription && react_default.createElement(Description, null, react_default.createElement(index_modern_default, null, description)), table.jsDocTags != null ? react_default.createElement(react_default.Fragment, null, react_default.createElement(TypeWithJsDoc, { hasDescription }, react_default.createElement(ArgValue, { value: type, initialExpandedArgs })), react_default.createElement(ArgJsDoc, { tags: table.jsDocTags })) : react_default.createElement(Type, { hasDescription }, react_default.createElement(ArgValue, { value: type, initialExpandedArgs }))), compact ? null : react_default.createElement("td", null, react_default.createElement(ArgValue, { value: defaultValue, initialExpandedArgs })), updateArgs ? react_default.createElement("td", null, react_default.createElement(ArgControl, { ...props, isHovered })) : null);
  }, Wrapper7 = styled.div(({ inAddonPanel, theme: theme3 }) => ({
    height: inAddonPanel ? "100%" : "auto",
    display: "flex",
    border: inAddonPanel ? "none" : `1px solid ${theme3.appBorderColor}`,
    borderRadius: inAddonPanel ? 0 : theme3.appBorderRadius,
    padding: inAddonPanel ? 0 : 40,
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "column",
    gap: 15,
    background: theme3.background.content
  })), Links = styled.div(({ theme: theme3 }) => ({
    display: "flex",
    fontSize: theme3.typography.size.s2 - 1,
    gap: 25
  })), Empty = ({ inAddonPanel }) => {
    let [isLoading, setIsLoading] = useState(!0);
    return useEffect(() => {
      let load = setTimeout(() => {
        setIsLoading(!1);
      }, 100);
      return () => clearTimeout(load);
    }, []), isLoading ? null : react_default.createElement(Wrapper7, { inAddonPanel }, react_default.createElement(
      EmptyTabContent,
      {
        title: inAddonPanel ? "Interactive story playground" : "Args table with interactive controls couldn't be auto-generated",
        description: react_default.createElement(react_default.Fragment, null, "Controls give you an easy to use interface to test your components. Set your story args and you'll see controls appearing here automatically."),
        footer: react_default.createElement(Links, null, inAddonPanel && react_default.createElement(react_default.Fragment, null, react_default.createElement(
          Link,
          {
            href: "https://storybook.js.org/docs/essentials/controls?ref=ui",
            target: "_blank",
            withArrow: !0
          },
          react_default.createElement(DocumentIcon, null),
          " Read docs"
        )), !inAddonPanel && react_default.createElement(
          Link,
          {
            href: "https://storybook.js.org/docs/essentials/controls?ref=ui",
            target: "_blank",
            withArrow: !0
          },
          react_default.createElement(DocumentIcon, null),
          " Learn how to set that up"
        ))
      }
    ));
  }, ExpanderIconDown = styled(ChevronDownIcon)(({ theme: theme3 }) => ({
    marginRight: 8,
    marginLeft: -10,
    marginTop: -2,
    // optical alignment
    height: 12,
    width: 12,
    color: theme3.base === "light" ? curriedTransparentize$1(0.25, theme3.color.defaultText) : curriedTransparentize$1(0.3, theme3.color.defaultText),
    border: "none",
    display: "inline-block"
  })), ExpanderIconRight = styled(ChevronRightIcon)(({ theme: theme3 }) => ({
    marginRight: 8,
    marginLeft: -10,
    marginTop: -2,
    // optical alignment
    height: 12,
    width: 12,
    color: theme3.base === "light" ? curriedTransparentize$1(0.25, theme3.color.defaultText) : curriedTransparentize$1(0.3, theme3.color.defaultText),
    border: "none",
    display: "inline-block"
  })), FlexWrapper = styled.span(({ theme: theme3 }) => ({
    display: "flex",
    lineHeight: "20px",
    alignItems: "center"
  })), Section = styled.td(({ theme: theme3 }) => ({
    position: "relative",
    letterSpacing: "0.35em",
    textTransform: "uppercase",
    fontWeight: theme3.typography.weight.bold,
    fontSize: theme3.typography.size.s1 - 1,
    color: theme3.base === "light" ? curriedTransparentize$1(0.4, theme3.color.defaultText) : curriedTransparentize$1(0.6, theme3.color.defaultText),
    background: `${theme3.background.app} !important`,
    "& ~ td": {
      background: `${theme3.background.app} !important`
    }
  })), Subsection = styled.td(({ theme: theme3 }) => ({
    position: "relative",
    fontWeight: theme3.typography.weight.bold,
    fontSize: theme3.typography.size.s2 - 1,
    background: theme3.background.app
  })), StyledTd2 = styled.td({
    position: "relative"
  }), StyledTr = styled.tr(({ theme: theme3 }) => ({
    "&:hover > td": {
      backgroundColor: `${curriedLighten$1(5e-3, theme3.background.app)} !important`,
      boxShadow: `${theme3.color.mediumlight} 0 - 1px 0 0 inset`,
      cursor: "row-resize"
    }
  })), ClickIntercept = styled.button({
    // reset button style
    background: "none",
    border: "none",
    padding: "0",
    font: "inherit",
    // add custom style
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    height: "100%",
    width: "100%",
    color: "transparent",
    cursor: "row-resize !important"
  }), SectionRow = ({
    level = "section",
    label,
    children,
    initialExpanded = !0,
    colSpan = 3
  }) => {
    let [expanded, setExpanded] = useState(initialExpanded), Level = level === "subsection" ? Subsection : Section, itemCount = children?.length || 0, caption = level === "subsection" ? `${itemCount} item${itemCount !== 1 ? "s" : ""}` : "", helperText = `${expanded ? "Hide" : "Show"} ${level === "subsection" ? itemCount : label} item${itemCount !== 1 ? "s" : ""}`;
    return react_default.createElement(react_default.Fragment, null, react_default.createElement(StyledTr, { title: helperText }, react_default.createElement(Level, { colSpan: 1 }, react_default.createElement(ClickIntercept, { onClick: (e2) => setExpanded(!expanded), tabIndex: 0 }, helperText), react_default.createElement(FlexWrapper, null, expanded ? react_default.createElement(ExpanderIconDown, null) : react_default.createElement(ExpanderIconRight, null), label)), react_default.createElement(StyledTd2, { colSpan: colSpan - 1 }, react_default.createElement(
      ClickIntercept,
      {
        onClick: (e2) => setExpanded(!expanded),
        tabIndex: -1,
        style: { outline: "none" }
      },
      helperText
    ), expanded ? null : caption)), expanded ? children : null);
  }, TableWrapper = styled.div(({ theme: theme3 }) => ({
    width: "100%",
    borderSpacing: 0,
    color: theme3.color.defaultText
  })), Row = styled.div(({ theme: theme3 }) => ({
    display: "flex",
    borderBottom: `1px solid ${theme3.appBorderColor}`,
    "&:last-child": {
      borderBottom: 0
    }
  })), Column = styled.div(
    ({ position, theme: theme3 }) => {
      let baseStyles = {
        display: "flex",
        flexDirection: "column",
        gap: 5,
        padding: "10px 15px",
        alignItems: "flex-start"
      };
      switch (position) {
        case "first":
          return {
            ...baseStyles,
            width: "25%",
            paddingLeft: 20
          };
        case "second":
          return {
            ...baseStyles,
            width: "35%"
          };
        case "third":
          return {
            ...baseStyles,
            width: "15%"
          };
        case "last":
          return {
            ...baseStyles,
            width: "25%",
            paddingRight: 20
          };
      }
    }
  ), SkeletonText = styled.div(
    ({ theme: theme3, width, height }) => ({
      animation: `${theme3.animation.glow} 1.5s ease-in-out infinite`,
      background: theme3.appBorderColor,
      width: width || "100%",
      height: height || 16,
      borderRadius: 3
    })
  ), Skeleton = () => react_default.createElement(TableWrapper, null, react_default.createElement(Row, null, react_default.createElement(Column, { position: "first" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "second" }, react_default.createElement(SkeletonText, { width: "30%" })), react_default.createElement(Column, { position: "third" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "last" }, react_default.createElement(SkeletonText, { width: "60%" }))), react_default.createElement(Row, null, react_default.createElement(Column, { position: "first" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "second" }, react_default.createElement(SkeletonText, { width: "80%" }), react_default.createElement(SkeletonText, { width: "30%" })), react_default.createElement(Column, { position: "third" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "last" }, react_default.createElement(SkeletonText, { width: "60%" }))), react_default.createElement(Row, null, react_default.createElement(Column, { position: "first" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "second" }, react_default.createElement(SkeletonText, { width: "80%" }), react_default.createElement(SkeletonText, { width: "30%" })), react_default.createElement(Column, { position: "third" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "last" }, react_default.createElement(SkeletonText, { width: "60%" }))), react_default.createElement(Row, null, react_default.createElement(Column, { position: "first" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "second" }, react_default.createElement(SkeletonText, { width: "80%" }), react_default.createElement(SkeletonText, { width: "30%" })), react_default.createElement(Column, { position: "third" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "last" }, react_default.createElement(SkeletonText, { width: "60%" })))), TableWrapper2 = styled.table(({ theme: theme3, compact, inAddonPanel, inTabPanel }) => ({
    "&&": {
      // Resets for cascading/system styles
      borderSpacing: 0,
      color: theme3.color.defaultText,
      "td, th": {
        padding: 0,
        border: "none",
        verticalAlign: "top",
        textOverflow: "ellipsis"
      },
      // End Resets
      fontSize: theme3.typography.size.s2 - 1,
      lineHeight: "19px",
      textAlign: "left",
      width: "100%",
      // Margin collapse
      marginTop: inAddonPanel ? 0 : 25,
      marginBottom: inAddonPanel ? 0 : 40,
      "thead th:first-of-type, td:first-of-type": {
        // intentionally specify thead here
        width: "25%"
      },
      "th:first-of-type, td:first-of-type": {
        paddingLeft: 20
      },
      "th:nth-of-type(2), td:nth-of-type(2)": {
        ...compact ? null : {
          // Description column
          width: "35%"
        }
      },
      "td:nth-of-type(3)": {
        ...compact ? null : {
          // Defaults column
          width: "15%"
        }
      },
      "th:last-of-type, td:last-of-type": {
        paddingRight: 20,
        ...compact ? null : {
          // Controls column
          width: "25%"
        }
      },
      th: {
        color: theme3.textMutedColor,
        paddingTop: 10,
        paddingBottom: 10,
        paddingLeft: 15,
        paddingRight: 15
      },
      td: {
        paddingTop: "10px",
        paddingBottom: "10px",
        "&:not(:first-of-type)": {
          paddingLeft: 15,
          paddingRight: 15
        },
        "&:last-of-type": {
          paddingRight: 20
        }
      },
      // Makes border alignment consistent w/other DocBlocks
      marginInline: inAddonPanel || inTabPanel ? 0 : 1,
      paddingInline: inTabPanel ? 3 : 0,
      tbody: {
        // Safari doesn't love shadows on tbody so we need to use a shadow filter. In order to do this,
        // the table cells all need to be solid so they have a background color applied.
        // I wasn't sure what kinds of content go in these tables so I was extra specific with selectors
        // to avoid unexpected surprises.
        ...inAddonPanel ? null : {
          filter: theme3.base === "light" ? "drop-shadow(0px 1px 3px rgba(0, 0, 0, 0.10))" : "drop-shadow(0px 1px 3px rgba(0, 0, 0, 0.20))"
        },
        "> tr > *": {
          // For filter to work properly, the table cells all need to be opaque.
          background: theme3.background.content,
          borderTop: `1px solid ${theme3.appBorderColor}`
        },
        ...inAddonPanel ? null : {
          // This works and I don't know why. :)
          "> tr:first-of-type > *": {
            borderBlockStart: `1px solid ${theme3.appBorderColor}`
          },
          "> tr:last-of-type > *": {
            borderBlockEnd: `1px solid ${theme3.appBorderColor}`
          },
          "> tr > *:first-of-type": {
            borderInlineStart: `1px solid ${theme3.appBorderColor}`
          },
          "> tr > *:last-of-type": {
            borderInlineEnd: `1px solid ${theme3.appBorderColor}`
          },
          // Thank you, Safari, for making me write code like this.
          "> tr:first-of-type > td:first-of-type": {
            borderTopLeftRadius: theme3.appBorderRadius
          },
          "> tr:first-of-type > td:last-of-type": {
            borderTopRightRadius: theme3.appBorderRadius
          },
          "> tr:last-of-type > td:first-of-type": {
            borderBottomLeftRadius: theme3.appBorderRadius
          },
          "> tr:last-of-type > td:last-of-type": {
            borderBottomRightRadius: theme3.appBorderRadius
          }
        }
      }
      // End awesome table styling
    }
  })), TablePositionWrapper = styled.div({
    position: "relative"
  }), ButtonPositionWrapper = styled.div({
    position: "absolute",
    right: 22,
    top: 10
  }), StyledButton = styled(Button)({
    margin: "-4px -12px -4px 0"
  }), sortFns = {
    alpha: (a22, b22) => (a22.name ?? "").localeCompare(b22.name ?? ""),
    requiredFirst: (a22, b22) => +!!b22.type?.required - +!!a22.type?.required || (a22.name ?? "").localeCompare(b22.name ?? ""),
    none: null
  }, groupRows = (rows, sort) => {
    let sections = { ungrouped: [], ungroupedSubsections: {}, sections: {} };
    if (!rows)
      return sections;
    Object.entries(rows).forEach(([key, row]) => {
      let { category, subcategory } = row?.table || {};
      if (category) {
        let section = sections.sections[category] || { ungrouped: [], subsections: {} };
        if (!subcategory)
          section.ungrouped.push({ key, ...row });
        else {
          let subsection = section.subsections[subcategory] || [];
          subsection.push({ key, ...row }), section.subsections[subcategory] = subsection;
        }
        sections.sections[category] = section;
      } else if (subcategory) {
        let subsection = sections.ungroupedSubsections[subcategory] || [];
        subsection.push({ key, ...row }), sections.ungroupedSubsections[subcategory] = subsection;
      } else
        sections.ungrouped.push({ key, ...row });
    });
    let sortFn = sortFns[sort], sortSubsection = (record) => sortFn ? Object.keys(record).reduce(
      (acc, cur) => ({
        ...acc,
        [cur]: record[cur].sort(sortFn)
      }),
      {}
    ) : record;
    return {
      ungrouped: sortFn ? sections.ungrouped.sort(sortFn) : sections.ungrouped,
      ungroupedSubsections: sortSubsection(sections.ungroupedSubsections),
      sections: Object.keys(sections.sections).reduce(
        (acc, cur) => ({
          ...acc,
          [cur]: {
            ungrouped: sortFn ? sections.sections[cur].ungrouped.sort(sortFn) : sections.sections[cur].ungrouped,
            subsections: sortSubsection(sections.sections[cur].subsections)
          }
        }),
        {}
      )
    };
  }, safeIncludeConditionalArg = (row, args, globals) => {
    try {
      return includeConditionalArg(row, args, globals);
    } catch (err) {
      return once.warn(err.message), !1;
    }
  }, ArgsTable = (props) => {
    let {
      updateArgs,
      resetArgs,
      compact,
      inAddonPanel,
      inTabPanel,
      initialExpandedArgs,
      sort = "none",
      isLoading
    } = props;
    if ("error" in props) {
      let { error } = props;
      return react_default.createElement(EmptyBlock, null, error, "\xA0", react_default.createElement(Link, { href: "http://storybook.js.org/docs/?ref=ui", target: "_blank", withArrow: !0 }, react_default.createElement(DocumentIcon, null), " Read the docs"));
    }
    if (isLoading)
      return react_default.createElement(Skeleton, null);
    let { rows, args, globals } = "rows" in props ? props : { rows: void 0, args: void 0, globals: void 0 }, groups = groupRows(
      pickBy(
        rows || {},
        (row) => !row?.table?.disable && safeIncludeConditionalArg(row, args || {}, globals || {})
      ),
      sort
    ), hasNoUngrouped = groups.ungrouped.length === 0, hasNoSections = Object.entries(groups.sections).length === 0, hasNoUngroupedSubsections = Object.entries(groups.ungroupedSubsections).length === 0;
    if (hasNoUngrouped && hasNoSections && hasNoUngroupedSubsections)
      return react_default.createElement(Empty, { inAddonPanel });
    let colSpan = 1;
    updateArgs && (colSpan += 1), compact || (colSpan += 2);
    let expandable = Object.keys(groups.sections).length > 0, common = { updateArgs, compact, inAddonPanel, initialExpandedArgs };
    return react_default.createElement(ResetWrapper, null, react_default.createElement(TablePositionWrapper, null, updateArgs && !isLoading && resetArgs && react_default.createElement(ButtonPositionWrapper, null, react_default.createElement(
      StyledButton,
      {
        variant: "ghost",
        padding: "small",
        onClick: () => resetArgs(),
        ariaLabel: "Reset controls"
      },
      react_default.createElement(UndoIcon, null)
    )), react_default.createElement(
      TableWrapper2,
      {
        compact,
        inAddonPanel,
        inTabPanel,
        className: "docblock-argstable sb-unstyled"
      },
      react_default.createElement("thead", { className: "docblock-argstable-head" }, react_default.createElement("tr", null, react_default.createElement("th", null, react_default.createElement("span", null, "Name")), compact ? null : react_default.createElement("th", null, react_default.createElement("span", null, "Description")), compact ? null : react_default.createElement("th", null, react_default.createElement("span", null, "Default")), updateArgs ? react_default.createElement("th", null, react_default.createElement("span", null, "Control")) : null)),
      react_default.createElement("tbody", { className: "docblock-argstable-body" }, groups.ungrouped.map((row) => react_default.createElement(ArgRow, { key: row.key, row, arg: args && args[row.key], ...common })), Object.entries(groups.ungroupedSubsections).map(([subcategory, subsection]) => react_default.createElement(
        SectionRow,
        {
          key: subcategory,
          label: subcategory,
          level: "subsection",
          colSpan
        },
        subsection.map((row) => react_default.createElement(
          ArgRow,
          {
            key: row.key,
            row,
            arg: args && args[row.key],
            expandable,
            ...common
          }
        ))
      )), Object.entries(groups.sections).map(([category, section]) => react_default.createElement(SectionRow, { key: category, label: category, level: "section", colSpan }, section.ungrouped.map((row) => react_default.createElement(ArgRow, { key: row.key, row, arg: args && args[row.key], ...common })), Object.entries(section.subsections).map(([subcategory, subsection]) => react_default.createElement(
        SectionRow,
        {
          key: subcategory,
          label: subcategory,
          level: "subsection",
          colSpan
        },
        subsection.map((row) => react_default.createElement(
          ArgRow,
          {
            key: row.key,
            row,
            arg: args && args[row.key],
            expandable,
            ...common
          }
        ))
      )))))
    )));
  }, ADDON_ID62 = "addon-controls", PARAM_KEY52 = "controls", slideIn = keyframes({
    from: { transform: "translateY(40px)" },
    to: { transform: "translateY(0)" }
  }), highlight = keyframes({
    from: { background: "var(--highlight-bg-color)" },
    to: {}
  }), Container2 = styled.div({
    containerType: "size",
    position: "absolute",
    bottom: 0,
    width: "100%",
    height: 41,
    overflow: "hidden",
    zIndex: 1
  }), Bar2 = styled(Bar)(({ theme: theme3 }) => ({
    "--highlight-bg-color": theme3.base === "dark" ? "#153B5B" : "#E0F0FF",
    paddingInline: 4,
    animation: `${slideIn} 300ms, ${highlight} 2s`,
    background: theme3.background.bar,
    borderTop: `1px solid ${theme3.appBorderColor}`,
    fontSize: theme3.typography.size.s2,
    "@container (max-width: 799px)": {
      flexDirection: "row",
      justifyContent: "flex-end"
    }
  })), Info = styled.div({
    display: "flex",
    flex: "99 0 auto",
    alignItems: "center",
    marginInlineStart: 7,
    marginInlineEnd: 10,
    gap: 6
  }), Actions = styled.div(({ theme: theme3 }) => ({
    // We want actions to appear first and be hidden last on overflow,
    // but the screenreader reading order must start with Info.
    display: "flex",
    flex: "1 0 0",
    alignItems: "center",
    gap: 2,
    color: theme3.textMutedColor,
    fontSize: theme3.typography.size.s2
  })), Label4 = styled.div({
    "@container (max-width: 799px)": {
      lineHeight: 0,
      textIndent: "-9999px",
      "&::after": {
        content: "attr(data-short-label)",
        display: "block",
        lineHeight: "initial",
        textIndent: "0"
      }
    }
  }), ModalInput = styled(Form.Input)(({ theme: theme3 }) => ({
    "::placeholder": {
      color: theme3.color.mediumdark
    },
    "&:invalid:not(:placeholder-shown)": {
      boxShadow: `${theme3.color.negative} 0 0 0 1px inset`
    }
  })), SaveStory = ({ saveStory, createStory, resetArgs }) => {
    let inputRef = react_default.useRef(null), [saving, setSaving] = react_default.useState(!1), [creating, setCreating] = react_default.useState(!1), [storyName, setStoryName] = react_default.useState(""), [errorMessage, setErrorMessage] = react_default.useState(null), onSaveStory = async () => {
      saving || (setSaving(!0), await saveStory().catch(() => {
      }), setSaving(!1));
    }, onShowForm = () => {
      setCreating(!0), setStoryName(""), setTimeout(() => inputRef.current?.focus(), 0);
    }, onChange = (e2) => {
      let value2 = e2.target.value.replace(/^[^a-z]/i, "").replace(/[^a-z0-9-_ ]/gi, "").replaceAll(/([-_ ]+[a-z0-9])/gi, (match) => match.toUpperCase().replace(/[-_ ]/g, ""));
      setStoryName(value2.charAt(0).toUpperCase() + value2.slice(1));
    }, onSubmitForm = async (event) => {
      if (event.preventDefault(), !saving)
        try {
          setErrorMessage(null), setSaving(!0), await createStory(storyName.replace(/^[^a-z]/i, "").replaceAll(/[^a-z0-9]/gi, "")), setCreating(!1), setSaving(!1);
        } catch (e2) {
          setErrorMessage(e2.message), setSaving(!1);
        }
    }, saveLabel = saving ? "Saving changes to story" : "Save changes to story", createLabel = "Create new story with these settings";
    return react_default.createElement(Container2, { id: "save-from-controls" }, react_default.createElement(
      Bar2,
      {
        innerStyle: {
          flexDirection: "row-reverse",
          justifyContent: "space-between",
          flexWrap: "wrap"
        }
      },
      react_default.createElement(Actions, null, react_default.createElement(Button, { ariaLabel: saveLabel, tooltip: saveLabel, disabled: saving, onClick: onSaveStory }, react_default.createElement(CheckIcon, null), react_default.createElement(Label4, { "data-short-label": "Save" }, "Update story")), react_default.createElement(Button, { ariaLabel: createLabel, tooltip: createLabel, onClick: onShowForm }, react_default.createElement(AddIcon, null), react_default.createElement(Label4, { "data-short-label": "New" }, "Create new story")), react_default.createElement(Button, { ariaLabel: "Reset changes", onClick: () => resetArgs() }, react_default.createElement(UndoIcon, null), react_default.createElement("span", null, "Reset"))),
      react_default.createElement(Modal, { ariaLabel: "Create new story", width: 350, open: creating, onOpenChange: setCreating }, react_default.createElement(Form, { onSubmit: onSubmitForm, id: "create-new-story-form" }, react_default.createElement(Modal.Content, null, react_default.createElement(Modal.Header, null, react_default.createElement(Modal.Title, null, "Create new story"), react_default.createElement(Modal.Description, null, "This will add a new story to your existing stories file.")), react_default.createElement(
        ModalInput,
        {
          onChange,
          placeholder: "Story export name",
          readOnly: saving,
          ref: inputRef,
          value: storyName
        }
      ), react_default.createElement(Modal.Actions, null, react_default.createElement(
        Button,
        {
          ariaLabel: !1,
          disabled: saving || !storyName,
          size: "medium",
          type: "submit",
          variant: "solid"
        },
        "Create"
      ), react_default.createElement(Modal.Close, { asChild: !0 }, react_default.createElement(Button, { ariaLabel: !1, disabled: saving, size: "medium", type: "reset" }, "Cancel"))))), errorMessage && react_default.createElement(Modal.Error, null, errorMessage)),
      react_default.createElement(Info, null, react_default.createElement(Label4, { "data-short-label": "Unsaved changes" }, "You modified this story. Do you want to save your changes?"))
    ));
  }, clean = (obj) => Object.entries(obj).reduce(
    (acc, [key, value2]) => value2 !== void 0 ? Object.assign(acc, { [key]: value2 }) : acc,
    {}
  ), AddonWrapper = styled.div(({ showSaveFromUI, theme: theme3 }) => ({
    height: "100%",
    maxHeight: "100vh",
    paddingBottom: showSaveFromUI ? 41 : 0,
    backgroundColor: theme3.background.content,
    table: {
      backgroundColor: theme3.background.app
    }
  })), ControlsPanel = ({ saveStory, createStory }) => {
    let api = useStorybookApi(), [isLoading, setIsLoading] = useState(!0), [args, updateArgs, resetArgs, initialArgs] = useArgs(), [globals] = useGlobals(), rows = useArgTypes(), {
      expanded,
      sort,
      presetColors,
      disableSaveFromUI = !1
    } = useParameter(PARAM_KEY52, {}), { path, previewInitialized } = useStorybookState(), storyData = api.getCurrentStoryData();
    useEffect(() => {
      previewInitialized && setIsLoading(!1);
    }, [previewInitialized]);
    let hasControls = Object.values(rows).some((arg) => arg?.control), withPresetColors = Object.entries(rows).reduce((acc, [key, arg]) => {
      let control = arg?.control;
      return typeof control != "object" || control?.type !== "color" || control?.presetColors ? acc[key] = arg : acc[key] = { ...arg, control: { ...control, presetColors } }, acc;
    }, {}), hasUpdatedArgs = useMemo(
      () => !!args && !!initialArgs && !dequal(clean(args), clean(initialArgs)),
      [args, initialArgs]
    ), showSaveFromUI = hasControls && storyData.type === "story" && storyData.subtype !== "test" && hasUpdatedArgs && scope.CONFIG_TYPE === "DEVELOPMENT" && disableSaveFromUI !== !0;
    return react_default.createElement(AddonWrapper, { showSaveFromUI }, react_default.createElement(
      ArgsTable,
      {
        key: path,
        compact: !expanded && hasControls,
        rows: withPresetColors,
        args,
        globals,
        updateArgs,
        resetArgs,
        inAddonPanel: !0,
        sort,
        isLoading
      }
    ), showSaveFromUI && react_default.createElement(SaveStory, { resetArgs, saveStory, createStory }));
  };
  function Title() {
    let selectedPanel = useStorybookApi().getSelectedPanel(), rows = useArgTypes(), controlsCount = Object.values(rows).filter(
      (argType) => argType?.control && !argType?.table?.disable
    ).length, suffix = controlsCount === 0 ? null : react_default.createElement(Badge, { compact: !0, status: selectedPanel === ADDON_ID62 ? "active" : "neutral" }, controlsCount);
    return react_default.createElement("div", { style: { display: "flex", alignItems: "center", gap: 6 } }, react_default.createElement("span", null, "Controls"), suffix);
  }
  var stringifyArgs = (args) => JSON.stringify(args, (_22, value2) => typeof value2 == "function" ? "__sb_empty_function_arg__" : value2), manager_default = addons.register(ADDON_ID62, (api) => {
    if (globalThis?.FEATURES?.controls) {
      let channel = addons.getChannel(), saveStory = async () => {
        let data = api.getCurrentStoryData();
        if (data.type !== "story")
          throw new Error("Not a story");
        try {
          let response = await experimental_requestResponse(channel, SAVE_STORY_REQUEST, SAVE_STORY_RESPONSE, {
            // Only send updated args
            args: stringifyArgs(
              Object.entries(data.args || {}).reduce((acc, [key, value2]) => (dequal(value2, data.initialArgs?.[key]) || (acc[key] = value2), acc), {})
            ),
            csfId: data.id,
            importPath: data.importPath
          });
          api.addNotification({
            id: "save-story-success",
            icon: react_default.createElement(PassedIcon, { color: color.positive }),
            content: {
              headline: "Story saved",
              subHeadline: react_default.createElement(react_default.Fragment, null, "Updated story ", react_default.createElement("b", null, response.sourceStoryName), ".")
            },
            duration: 8e3
          });
        } catch (error) {
          throw api.addNotification({
            id: "save-story-error",
            icon: react_default.createElement(FailedIcon, { color: color.negative }),
            content: {
              headline: "Failed to save story",
              subHeadline: error?.message || "Check the Storybook process on the command line for more details."
            },
            duration: 8e3
          }), error;
        }
      }, createStory = async (name) => {
        let data = api.getCurrentStoryData();
        if (data.type !== "story")
          throw new Error("Not a story");
        let response = await experimental_requestResponse(channel, SAVE_STORY_REQUEST, SAVE_STORY_RESPONSE, {
          args: data.args && stringifyArgs(data.args),
          csfId: data.id,
          importPath: data.importPath,
          name
        });
        api.addNotification({
          id: "save-story-success",
          icon: react_default.createElement(PassedIcon, { color: color.positive }),
          content: {
            headline: "Story created",
            subHeadline: react_default.createElement(react_default.Fragment, null, "Added story ", react_default.createElement("b", null, response.newStoryName), " based on ", react_default.createElement("b", null, response.sourceStoryName), ".")
          },
          duration: 8e3,
          onClick: ({ onDismiss }) => {
            onDismiss(), api.selectStory(response.newStoryId);
          }
        });
      };
      addons.add(ADDON_ID62, {
        title: Title,
        type: types.PANEL,
        paramKey: PARAM_KEY52,
        render: ({ active }) => !active || !api.getCurrentStoryData() ? null : react_default.createElement(AddonPanel, { active }, react_default.createElement(ControlsPanel, { saveStory, createStory }))
      }), channel.on(SAVE_STORY_RESPONSE, (data) => {
        if (!data.success)
          return;
        let story = api.getCurrentStoryData();
        story.type === "story" && (api.resetStoryArgs(story), data.payload.newStoryId && api.selectStory(data.payload.newStoryId));
      });
    }
  });
  function Title2() {
    let selectedPanel = useStorybookApi().getSelectedPanel(), [{ count: count2 }, setCount] = useAddonState(ADDON_ID4, { count: 0 });
    useChannel({
      [EVENT_ID]: () => {
        setCount((c22) => ({ ...c22, count: c22.count + 1 }));
      },
      [STORY_CHANGED]: () => {
        setCount((c22) => ({ ...c22, count: 0 }));
      },
      [CLEAR_ID]: () => {
        setCount((c22) => ({ ...c22, count: 0 }));
      }
    });
    let suffix = count2 === 0 ? null : react_default.createElement(Badge, { compact: !0, status: selectedPanel === PANEL_ID ? "active" : "neutral" }, count2);
    return react_default.createElement("div", { style: { display: "flex", alignItems: "center", gap: 6 } }, react_default.createElement("span", null, "Actions"), suffix);
  }
  var __create2 = Object.create, __defProp3 = Object.defineProperty, __getOwnPropDesc2 = Object.getOwnPropertyDescriptor, __getOwnPropNames3 = Object.getOwnPropertyNames, __getProtoOf2 = Object.getPrototypeOf, __hasOwnProp2 = Object.prototype.hasOwnProperty, __commonJS2 = (cb, mod) => function() {
    return mod || (0, cb[__getOwnPropNames3(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  }, __export3 = (target, all2) => {
    for (var name in all2)
      __defProp3(target, name, { get: all2[name], enumerable: !0 });
  }, __copyProps2 = (to, from, except, desc) => {
    if (from && typeof from == "object" || typeof from == "function")
      for (let key of __getOwnPropNames3(from))
        !__hasOwnProp2.call(to, key) && key !== except && __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    return to;
  }, __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(isNodeMode || !mod || !mod.__esModule ? __defProp3(target, "default", { value: mod, enumerable: !0 }) : target, mod)), require_is_object = __commonJS2({
    "node_modules/is-object/index.js"(exports, module) {
      "use strict";
      module.exports = function(x22) {
        return typeof x22 == "object" && x22 !== null;
      };
    }
  }), require_is_window = __commonJS2({
    "node_modules/is-window/index.js"(exports, module) {
      "use strict";
      module.exports = function(obj) {
        if (obj == null)
          return !1;
        var o2 = Object(obj);
        return o2 === o2.window;
      };
    }
  }), require_is_dom = __commonJS2({
    "node_modules/is-dom/index.js"(exports, module) {
      var isObject22 = require_is_object(), isWindow2 = require_is_window();
      function isNode(val) {
        return !isObject22(val) || !isWindow2(window) || typeof window.Node != "function" ? !1 : typeof val.nodeType == "number" && typeof val.nodeName == "string";
      }
      module.exports = isNode;
    }
  }), themes_exports = {};
  __export3(themes_exports, {
    chromeDark: () => theme,
    chromeLight: () => theme2
  });
  var theme = {
    BASE_FONT_FAMILY: "Menlo, monospace",
    BASE_FONT_SIZE: "11px",
    BASE_LINE_HEIGHT: 1.2,
    BASE_BACKGROUND_COLOR: "rgb(36, 36, 36)",
    BASE_COLOR: "rgb(213, 213, 213)",
    OBJECT_PREVIEW_ARRAY_MAX_PROPERTIES: 10,
    OBJECT_PREVIEW_OBJECT_MAX_PROPERTIES: 5,
    OBJECT_NAME_COLOR: "rgb(227, 110, 236)",
    OBJECT_VALUE_NULL_COLOR: "rgb(127, 127, 127)",
    OBJECT_VALUE_UNDEFINED_COLOR: "rgb(127, 127, 127)",
    OBJECT_VALUE_REGEXP_COLOR: "rgb(233, 63, 59)",
    OBJECT_VALUE_STRING_COLOR: "rgb(233, 63, 59)",
    OBJECT_VALUE_SYMBOL_COLOR: "rgb(233, 63, 59)",
    OBJECT_VALUE_NUMBER_COLOR: "hsl(252, 100%, 75%)",
    OBJECT_VALUE_BOOLEAN_COLOR: "hsl(252, 100%, 75%)",
    OBJECT_VALUE_FUNCTION_PREFIX_COLOR: "rgb(85, 106, 242)",
    HTML_TAG_COLOR: "rgb(93, 176, 215)",
    HTML_TAGNAME_COLOR: "rgb(93, 176, 215)",
    HTML_TAGNAME_TEXT_TRANSFORM: "lowercase",
    HTML_ATTRIBUTE_NAME_COLOR: "rgb(155, 187, 220)",
    HTML_ATTRIBUTE_VALUE_COLOR: "rgb(242, 151, 102)",
    HTML_COMMENT_COLOR: "rgb(137, 137, 137)",
    HTML_DOCTYPE_COLOR: "rgb(192, 192, 192)",
    ARROW_COLOR: "rgb(145, 145, 145)",
    ARROW_MARGIN_RIGHT: 3,
    ARROW_FONT_SIZE: 12,
    ARROW_ANIMATION_DURATION: "0",
    TREENODE_FONT_FAMILY: "Menlo, monospace",
    TREENODE_FONT_SIZE: "11px",
    TREENODE_LINE_HEIGHT: 1.2,
    TREENODE_PADDING_LEFT: 12,
    TABLE_BORDER_COLOR: "rgb(85, 85, 85)",
    TABLE_TH_BACKGROUND_COLOR: "rgb(44, 44, 44)",
    TABLE_TH_HOVER_COLOR: "rgb(48, 48, 48)",
    TABLE_SORT_ICON_COLOR: "black",
    TABLE_DATA_BACKGROUND_IMAGE: "linear-gradient(rgba(255, 255, 255, 0), rgba(255, 255, 255, 0) 50%, rgba(51, 139, 255, 0.0980392) 50%, rgba(51, 139, 255, 0.0980392))",
    TABLE_DATA_BACKGROUND_SIZE: "128px 32px"
  }, theme2 = {
    BASE_FONT_FAMILY: "Menlo, monospace",
    BASE_FONT_SIZE: "11px",
    BASE_LINE_HEIGHT: 1.2,
    BASE_BACKGROUND_COLOR: "white",
    BASE_COLOR: "black",
    OBJECT_PREVIEW_ARRAY_MAX_PROPERTIES: 10,
    OBJECT_PREVIEW_OBJECT_MAX_PROPERTIES: 5,
    OBJECT_NAME_COLOR: "rgb(136, 19, 145)",
    OBJECT_VALUE_NULL_COLOR: "rgb(128, 128, 128)",
    OBJECT_VALUE_UNDEFINED_COLOR: "rgb(128, 128, 128)",
    OBJECT_VALUE_REGEXP_COLOR: "rgb(196, 26, 22)",
    OBJECT_VALUE_STRING_COLOR: "rgb(196, 26, 22)",
    OBJECT_VALUE_SYMBOL_COLOR: "rgb(196, 26, 22)",
    OBJECT_VALUE_NUMBER_COLOR: "rgb(28, 0, 207)",
    OBJECT_VALUE_BOOLEAN_COLOR: "rgb(28, 0, 207)",
    OBJECT_VALUE_FUNCTION_PREFIX_COLOR: "rgb(13, 34, 170)",
    HTML_TAG_COLOR: "rgb(168, 148, 166)",
    HTML_TAGNAME_COLOR: "rgb(136, 18, 128)",
    HTML_TAGNAME_TEXT_TRANSFORM: "lowercase",
    HTML_ATTRIBUTE_NAME_COLOR: "rgb(153, 69, 0)",
    HTML_ATTRIBUTE_VALUE_COLOR: "rgb(26, 26, 166)",
    HTML_COMMENT_COLOR: "rgb(35, 110, 37)",
    HTML_DOCTYPE_COLOR: "rgb(192, 192, 192)",
    ARROW_COLOR: "#6e6e6e",
    ARROW_MARGIN_RIGHT: 3,
    ARROW_FONT_SIZE: 12,
    ARROW_ANIMATION_DURATION: "0",
    TREENODE_FONT_FAMILY: "Menlo, monospace",
    TREENODE_FONT_SIZE: "11px",
    TREENODE_LINE_HEIGHT: 1.2,
    TREENODE_PADDING_LEFT: 12,
    TABLE_BORDER_COLOR: "#aaa",
    TABLE_TH_BACKGROUND_COLOR: "#eee",
    TABLE_TH_HOVER_COLOR: "hsla(0, 0%, 90%, 1)",
    TABLE_SORT_ICON_COLOR: "#6e6e6e",
    TABLE_DATA_BACKGROUND_IMAGE: "linear-gradient(to bottom, white, white 50%, rgb(234, 243, 255) 50%, rgb(234, 243, 255))",
    TABLE_DATA_BACKGROUND_SIZE: "128px 32px"
  }, ExpandedPathsContext = createContext([{}, () => {
  }]), unselectable = {
    WebkitTouchCallout: "none",
    WebkitUserSelect: "none",
    KhtmlUserSelect: "none",
    MozUserSelect: "none",
    msUserSelect: "none",
    OUserSelect: "none",
    userSelect: "none"
  }, createTheme = (theme3) => ({
    DOMNodePreview: {
      htmlOpenTag: {
        base: {
          color: theme3.HTML_TAG_COLOR
        },
        tagName: {
          color: theme3.HTML_TAGNAME_COLOR,
          textTransform: theme3.HTML_TAGNAME_TEXT_TRANSFORM
        },
        htmlAttributeName: {
          color: theme3.HTML_ATTRIBUTE_NAME_COLOR
        },
        htmlAttributeValue: {
          color: theme3.HTML_ATTRIBUTE_VALUE_COLOR
        }
      },
      htmlCloseTag: {
        base: {
          color: theme3.HTML_TAG_COLOR
        },
        offsetLeft: {
          marginLeft: -theme3.TREENODE_PADDING_LEFT
        },
        tagName: {
          color: theme3.HTML_TAGNAME_COLOR,
          textTransform: theme3.HTML_TAGNAME_TEXT_TRANSFORM
        }
      },
      htmlComment: {
        color: theme3.HTML_COMMENT_COLOR
      },
      htmlDoctype: {
        color: theme3.HTML_DOCTYPE_COLOR
      }
    },
    ObjectPreview: {
      objectDescription: {
        fontStyle: "italic"
      },
      preview: {
        fontStyle: "italic"
      },
      arrayMaxProperties: theme3.OBJECT_PREVIEW_ARRAY_MAX_PROPERTIES,
      objectMaxProperties: theme3.OBJECT_PREVIEW_OBJECT_MAX_PROPERTIES
    },
    ObjectName: {
      base: {
        color: theme3.OBJECT_NAME_COLOR
      },
      dimmed: {
        opacity: 0.6
      }
    },
    ObjectValue: {
      objectValueNull: {
        color: theme3.OBJECT_VALUE_NULL_COLOR
      },
      objectValueUndefined: {
        color: theme3.OBJECT_VALUE_UNDEFINED_COLOR
      },
      objectValueRegExp: {
        color: theme3.OBJECT_VALUE_REGEXP_COLOR
      },
      objectValueString: {
        color: theme3.OBJECT_VALUE_STRING_COLOR
      },
      objectValueSymbol: {
        color: theme3.OBJECT_VALUE_SYMBOL_COLOR
      },
      objectValueNumber: {
        color: theme3.OBJECT_VALUE_NUMBER_COLOR
      },
      objectValueBoolean: {
        color: theme3.OBJECT_VALUE_BOOLEAN_COLOR
      },
      objectValueFunctionPrefix: {
        color: theme3.OBJECT_VALUE_FUNCTION_PREFIX_COLOR,
        fontStyle: "italic"
      },
      objectValueFunctionName: {
        fontStyle: "italic"
      }
    },
    TreeView: {
      treeViewOutline: {
        padding: 0,
        margin: 0,
        listStyleType: "none"
      }
    },
    TreeNode: {
      treeNodeBase: {
        color: theme3.BASE_COLOR,
        backgroundColor: theme3.BASE_BACKGROUND_COLOR,
        lineHeight: theme3.TREENODE_LINE_HEIGHT,
        cursor: "default",
        boxSizing: "border-box",
        listStyle: "none",
        fontFamily: theme3.TREENODE_FONT_FAMILY,
        fontSize: theme3.TREENODE_FONT_SIZE
      },
      treeNodePreviewContainer: {},
      treeNodePlaceholder: {
        whiteSpace: "pre",
        fontSize: theme3.ARROW_FONT_SIZE,
        marginRight: theme3.ARROW_MARGIN_RIGHT,
        ...unselectable
      },
      treeNodeArrow: {
        base: {
          color: theme3.ARROW_COLOR,
          display: "inline-block",
          fontSize: theme3.ARROW_FONT_SIZE,
          marginRight: theme3.ARROW_MARGIN_RIGHT,
          ...parseFloat(theme3.ARROW_ANIMATION_DURATION) > 0 ? {
            transition: `transform ${theme3.ARROW_ANIMATION_DURATION} ease 0s`
          } : {},
          ...unselectable
        },
        expanded: {
          WebkitTransform: "rotateZ(90deg)",
          MozTransform: "rotateZ(90deg)",
          transform: "rotateZ(90deg)"
        },
        collapsed: {
          WebkitTransform: "rotateZ(0deg)",
          MozTransform: "rotateZ(0deg)",
          transform: "rotateZ(0deg)"
        }
      },
      treeNodeChildNodesContainer: {
        margin: 0,
        paddingLeft: theme3.TREENODE_PADDING_LEFT
      }
    },
    TableInspector: {
      base: {
        color: theme3.BASE_COLOR,
        position: "relative",
        border: `1px solid ${theme3.TABLE_BORDER_COLOR}`,
        fontFamily: theme3.BASE_FONT_FAMILY,
        fontSize: theme3.BASE_FONT_SIZE,
        lineHeight: "120%",
        boxSizing: "border-box",
        cursor: "default"
      }
    },
    TableInspectorHeaderContainer: {
      base: {
        top: 0,
        height: "17px",
        left: 0,
        right: 0,
        overflowX: "hidden"
      },
      table: {
        tableLayout: "fixed",
        borderSpacing: 0,
        borderCollapse: "separate",
        height: "100%",
        width: "100%",
        margin: 0
      }
    },
    TableInspectorDataContainer: {
      tr: {
        display: "table-row"
      },
      td: {
        boxSizing: "border-box",
        border: "none",
        height: "16px",
        verticalAlign: "top",
        padding: "1px 4px",
        WebkitUserSelect: "text",
        whiteSpace: "nowrap",
        textOverflow: "ellipsis",
        overflow: "hidden",
        lineHeight: "14px"
      },
      div: {
        position: "static",
        top: "17px",
        bottom: 0,
        overflowY: "overlay",
        transform: "translateZ(0)",
        left: 0,
        right: 0,
        overflowX: "hidden"
      },
      table: {
        positon: "static",
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        borderTop: "0 none transparent",
        margin: 0,
        backgroundImage: theme3.TABLE_DATA_BACKGROUND_IMAGE,
        backgroundSize: theme3.TABLE_DATA_BACKGROUND_SIZE,
        tableLayout: "fixed",
        borderSpacing: 0,
        borderCollapse: "separate",
        width: "100%",
        fontSize: theme3.BASE_FONT_SIZE,
        lineHeight: "120%"
      }
    },
    TableInspectorTH: {
      base: {
        position: "relative",
        height: "auto",
        textAlign: "left",
        backgroundColor: theme3.TABLE_TH_BACKGROUND_COLOR,
        borderBottom: `1px solid ${theme3.TABLE_BORDER_COLOR}`,
        fontWeight: "normal",
        verticalAlign: "middle",
        padding: "0 4px",
        whiteSpace: "nowrap",
        textOverflow: "ellipsis",
        overflow: "hidden",
        lineHeight: "14px",
        ":hover": {
          backgroundColor: theme3.TABLE_TH_HOVER_COLOR
        }
      },
      div: {
        whiteSpace: "nowrap",
        textOverflow: "ellipsis",
        overflow: "hidden",
        fontSize: theme3.BASE_FONT_SIZE,
        lineHeight: "120%"
      }
    },
    TableInspectorLeftBorder: {
      none: {
        borderLeft: "none"
      },
      solid: {
        borderLeft: `1px solid ${theme3.TABLE_BORDER_COLOR}`
      }
    },
    TableInspectorSortIcon: {
      display: "block",
      marginRight: 3,
      width: 8,
      height: 7,
      marginTop: -7,
      color: theme3.TABLE_SORT_ICON_COLOR,
      fontSize: 12,
      ...unselectable
    }
  }), DEFAULT_THEME_NAME = "chromeLight", ThemeContext = createContext(createTheme(themes_exports[DEFAULT_THEME_NAME])), useStyles = (baseStylesKey) => useContext(ThemeContext)[baseStylesKey], themeAcceptor = (WrappedComponent) => ({ theme: theme3 = DEFAULT_THEME_NAME, ...restProps }) => {
    let themeStyles = useMemo(() => {
      switch (Object.prototype.toString.call(theme3)) {
        case "[object String]":
          return createTheme(themes_exports[theme3]);
        case "[object Object]":
          return createTheme(theme3);
        default:
          return createTheme(themes_exports[DEFAULT_THEME_NAME]);
      }
    }, [theme3]);
    return react_default.createElement(ThemeContext.Provider, {
      value: themeStyles
    }, react_default.createElement(WrappedComponent, {
      ...restProps
    }));
  }, Arrow = ({ expanded, styles: styles2 }) => react_default.createElement("span", {
    style: {
      ...styles2.base,
      ...expanded ? styles2.expanded : styles2.collapsed
    }
  }, "\u25B6"), TreeNode = memo((props) => {
    props = {
      expanded: !0,
      nodeRenderer: ({ name }) => react_default.createElement("span", null, name),
      onClick: () => {
      },
      shouldShowArrow: !1,
      shouldShowPlaceholder: !0,
      ...props
    };
    let { expanded, onClick, children, nodeRenderer, title, shouldShowArrow, shouldShowPlaceholder } = props, styles2 = useStyles("TreeNode"), NodeRenderer = nodeRenderer;
    return react_default.createElement("li", {
      "aria-expanded": expanded,
      role: "treeitem",
      style: styles2.treeNodeBase,
      title
    }, react_default.createElement("div", {
      style: styles2.treeNodePreviewContainer,
      onClick
    }, shouldShowArrow || Children.count(children) > 0 ? react_default.createElement(Arrow, {
      expanded,
      styles: styles2.treeNodeArrow
    }) : shouldShowPlaceholder && react_default.createElement("span", {
      style: styles2.treeNodePlaceholder
    }, "\xA0"), react_default.createElement(NodeRenderer, {
      ...props
    })), react_default.createElement("ol", {
      role: "group",
      style: styles2.treeNodeChildNodesContainer
    }, expanded ? children : void 0));
  }), DEFAULT_ROOT_PATH = "$", WILDCARD = "*";
  function hasChildNodes(data, dataIterator) {
    return !dataIterator(data).next().done;
  }
  var wildcardPathsFromLevel = (level) => Array.from({ length: level }, (_22, i22) => [DEFAULT_ROOT_PATH].concat(Array.from({ length: i22 }, () => "*")).join(".")), getExpandedPaths = (data, dataIterator, expandPaths, expandLevel, prevExpandedPaths) => {
    let wildcardPaths = [].concat(wildcardPathsFromLevel(expandLevel)).concat(expandPaths).filter((path) => typeof path == "string"), expandedPaths = [];
    return wildcardPaths.forEach((wildcardPath) => {
      let keyPaths = wildcardPath.split("."), populatePaths = (curData, curPath, depth) => {
        if (depth === keyPaths.length) {
          expandedPaths.push(curPath);
          return;
        }
        let key = keyPaths[depth];
        if (depth === 0)
          hasChildNodes(curData, dataIterator) && (key === DEFAULT_ROOT_PATH || key === WILDCARD) && populatePaths(curData, DEFAULT_ROOT_PATH, depth + 1);
        else if (key === WILDCARD)
          for (let { name, data: data2 } of dataIterator(curData))
            hasChildNodes(data2, dataIterator) && populatePaths(data2, `${curPath}.${name}`, depth + 1);
        else {
          let value2 = curData[key];
          hasChildNodes(value2, dataIterator) && populatePaths(value2, `${curPath}.${key}`, depth + 1);
        }
      };
      populatePaths(data, "", 0);
    }), expandedPaths.reduce((obj, path) => (obj[path] = !0, obj), { ...prevExpandedPaths });
  }, ConnectedTreeNode = memo((props) => {
    let { data, dataIterator, path, depth, nodeRenderer } = props, [expandedPaths, setExpandedPaths] = useContext(ExpandedPathsContext), nodeHasChildNodes = hasChildNodes(data, dataIterator), expanded = !!expandedPaths[path], handleClick = useCallback(() => nodeHasChildNodes && setExpandedPaths((prevExpandedPaths) => ({
      ...prevExpandedPaths,
      [path]: !expanded
    })), [nodeHasChildNodes, setExpandedPaths, path, expanded]);
    return react_default.createElement(TreeNode, {
      expanded,
      onClick: handleClick,
      shouldShowArrow: nodeHasChildNodes,
      shouldShowPlaceholder: depth > 0,
      nodeRenderer,
      ...props
    }, expanded ? [...dataIterator(data)].map(({ name, data: data2, ...renderNodeProps }) => react_default.createElement(ConnectedTreeNode, {
      name,
      data: data2,
      depth: depth + 1,
      path: `${path}.${name}`,
      key: name,
      dataIterator,
      nodeRenderer,
      ...renderNodeProps
    })) : null);
  }), TreeView = memo(({ name, data, dataIterator, nodeRenderer, expandPaths, expandLevel }) => {
    let styles2 = useStyles("TreeView"), stateAndSetter = useState({}), [, setExpandedPaths] = stateAndSetter;
    return useLayoutEffect(() => setExpandedPaths((prevExpandedPaths) => getExpandedPaths(data, dataIterator, expandPaths, expandLevel, prevExpandedPaths)), [data, dataIterator, expandPaths, expandLevel]), react_default.createElement(ExpandedPathsContext.Provider, {
      value: stateAndSetter
    }, react_default.createElement("ol", {
      role: "tree",
      style: styles2.treeViewOutline
    }, react_default.createElement(ConnectedTreeNode, {
      name,
      data,
      dataIterator,
      depth: 0,
      path: DEFAULT_ROOT_PATH,
      nodeRenderer
    })));
  }), ObjectName = ({ name, dimmed = !1, styles: styles2 = {} }) => {
    let themeStyles = useStyles("ObjectName"), appliedStyles = {
      ...themeStyles.base,
      ...dimmed ? themeStyles.dimmed : {},
      ...styles2
    };
    return react_default.createElement("span", {
      style: appliedStyles
    }, name);
  }, ObjectValue = ({ object: object2, styles: styles2 }) => {
    let themeStyles = useStyles("ObjectValue"), mkStyle = (key) => ({ ...themeStyles[key], ...styles2 });
    switch (typeof object2) {
      case "bigint":
        return react_default.createElement("span", {
          style: mkStyle("objectValueNumber")
        }, String(object2), "n");
      case "number":
        return react_default.createElement("span", {
          style: mkStyle("objectValueNumber")
        }, String(object2));
      case "string":
        return react_default.createElement("span", {
          style: mkStyle("objectValueString")
        }, '"', object2, '"');
      case "boolean":
        return react_default.createElement("span", {
          style: mkStyle("objectValueBoolean")
        }, String(object2));
      case "undefined":
        return react_default.createElement("span", {
          style: mkStyle("objectValueUndefined")
        }, "undefined");
      case "object":
        return object2 === null ? react_default.createElement("span", {
          style: mkStyle("objectValueNull")
        }, "null") : object2 instanceof Date ? react_default.createElement("span", null, object2.toString()) : object2 instanceof RegExp ? react_default.createElement("span", {
          style: mkStyle("objectValueRegExp")
        }, object2.toString()) : Array.isArray(object2) ? react_default.createElement("span", null, `Array(${object2.length})`) : object2.constructor ? typeof object2.constructor.isBuffer == "function" && object2.constructor.isBuffer(object2) ? react_default.createElement("span", null, `Buffer[${object2.length}]`) : react_default.createElement("span", null, object2.constructor.name) : react_default.createElement("span", null, "Object");
      case "function":
        return react_default.createElement("span", null, react_default.createElement("span", {
          style: mkStyle("objectValueFunctionPrefix")
        }, "\u0192\xA0"), react_default.createElement("span", {
          style: mkStyle("objectValueFunctionName")
        }, object2.name, "()"));
      case "symbol":
        return react_default.createElement("span", {
          style: mkStyle("objectValueSymbol")
        }, object2.toString());
      default:
        return react_default.createElement("span", null);
    }
  }, hasOwnProperty = Object.prototype.hasOwnProperty, propertyIsEnumerable = Object.prototype.propertyIsEnumerable;
  function getPropertyValue(object2, propertyName) {
    let propertyDescriptor = Object.getOwnPropertyDescriptor(object2, propertyName);
    if (propertyDescriptor.get)
      try {
        return propertyDescriptor.get();
      } catch {
        return propertyDescriptor.get;
      }
    return object2[propertyName];
  }
  function intersperse(arr, sep) {
    return arr.length === 0 ? [] : arr.slice(1).reduce((xs, x22) => xs.concat([sep, x22]), [arr[0]]);
  }
  var ObjectPreview = ({ data }) => {
    let styles2 = useStyles("ObjectPreview"), object2 = data;
    if (typeof object2 != "object" || object2 === null || object2 instanceof Date || object2 instanceof RegExp)
      return react_default.createElement(ObjectValue, {
        object: object2
      });
    if (Array.isArray(object2)) {
      let maxProperties = styles2.arrayMaxProperties, previewArray = object2.slice(0, maxProperties).map((element, index2) => react_default.createElement(ObjectValue, {
        key: index2,
        object: element
      }));
      object2.length > maxProperties && previewArray.push(react_default.createElement("span", {
        key: "ellipsis"
      }, "\u2026"));
      let arrayLength = object2.length;
      return react_default.createElement(react_default.Fragment, null, react_default.createElement("span", {
        style: styles2.objectDescription
      }, arrayLength === 0 ? "" : `(${arrayLength})\xA0`), react_default.createElement("span", {
        style: styles2.preview
      }, "[", intersperse(previewArray, ", "), "]"));
    } else {
      let maxProperties = styles2.objectMaxProperties, propertyNodes = [];
      for (let propertyName in object2)
        if (hasOwnProperty.call(object2, propertyName)) {
          let ellipsis;
          propertyNodes.length === maxProperties - 1 && Object.keys(object2).length > maxProperties && (ellipsis = react_default.createElement("span", {
            key: "ellipsis"
          }, "\u2026"));
          let propertyValue = getPropertyValue(object2, propertyName);
          if (propertyNodes.push(react_default.createElement("span", {
            key: propertyName
          }, react_default.createElement(ObjectName, {
            name: propertyName || '""'
          }), ":\xA0", react_default.createElement(ObjectValue, {
            object: propertyValue
          }), ellipsis)), ellipsis)
            break;
        }
      let objectConstructorName = object2.constructor ? object2.constructor.name : "Object";
      return react_default.createElement(react_default.Fragment, null, react_default.createElement("span", {
        style: styles2.objectDescription
      }, objectConstructorName === "Object" ? "" : `${objectConstructorName} `), react_default.createElement("span", {
        style: styles2.preview
      }, "{", intersperse(propertyNodes, ", "), "}"));
    }
  }, ObjectRootLabel = ({ name, data }) => typeof name == "string" ? react_default.createElement("span", null, react_default.createElement(ObjectName, {
    name
  }), react_default.createElement("span", null, ": "), react_default.createElement(ObjectPreview, {
    data
  })) : react_default.createElement(ObjectPreview, {
    data
  }), ObjectLabel = ({ name, data, isNonenumerable = !1 }) => {
    let object2 = data;
    return react_default.createElement("span", null, typeof name == "string" ? react_default.createElement(ObjectName, {
      name,
      dimmed: isNonenumerable
    }) : react_default.createElement(ObjectPreview, {
      data: name
    }), react_default.createElement("span", null, ": "), react_default.createElement(ObjectValue, {
      object: object2
    }));
  }, createIterator = (showNonenumerable, sortObjectKeys) => function* (data) {
    if (!(typeof data == "object" && data !== null || typeof data == "function"))
      return;
    let dataIsArray = Array.isArray(data);
    if (!dataIsArray && data[Symbol.iterator]) {
      let i22 = 0;
      for (let entry of data) {
        if (Array.isArray(entry) && entry.length === 2) {
          let [k22, v22] = entry;
          yield {
            name: k22,
            data: v22
          };
        } else
          yield {
            name: i22.toString(),
            data: entry
          };
        i22++;
      }
    } else {
      let keys = Object.getOwnPropertyNames(data);
      sortObjectKeys === !0 && !dataIsArray ? keys.sort() : typeof sortObjectKeys == "function" && keys.sort(sortObjectKeys);
      for (let propertyName of keys)
        if (propertyIsEnumerable.call(data, propertyName)) {
          let propertyValue = getPropertyValue(data, propertyName);
          yield {
            name: propertyName || '""',
            data: propertyValue
          };
        } else if (showNonenumerable) {
          let propertyValue;
          try {
            propertyValue = getPropertyValue(data, propertyName);
          } catch {
          }
          propertyValue !== void 0 && (yield {
            name: propertyName,
            data: propertyValue,
            isNonenumerable: !0
          });
        }
      showNonenumerable && data !== Object.prototype && (yield {
        name: "__proto__",
        data: Object.getPrototypeOf(data),
        isNonenumerable: !0
      });
    }
  }, defaultNodeRenderer = ({ depth, name, data, isNonenumerable }) => depth === 0 ? react_default.createElement(ObjectRootLabel, {
    name,
    data
  }) : react_default.createElement(ObjectLabel, {
    name,
    data,
    isNonenumerable
  }), ObjectInspector = ({ showNonenumerable = !1, sortObjectKeys, nodeRenderer, ...treeViewProps }) => {
    let dataIterator = createIterator(showNonenumerable, sortObjectKeys), renderer = nodeRenderer || defaultNodeRenderer;
    return react_default.createElement(TreeView, {
      nodeRenderer: renderer,
      dataIterator,
      ...treeViewProps
    });
  }, themedObjectInspector = themeAcceptor(ObjectInspector);
  function getHeaders(data) {
    if (typeof data == "object") {
      let rowHeaders = [];
      if (Array.isArray(data)) {
        let nRows = data.length;
        rowHeaders = [...Array(nRows).keys()];
      } else data !== null && (rowHeaders = Object.keys(data));
      let colHeaders = rowHeaders.reduce((colHeaders2, rowHeader) => {
        let row = data[rowHeader];
        return typeof row == "object" && row !== null && Object.keys(row).reduce((xs, x22) => (xs.includes(x22) || xs.push(x22), xs), colHeaders2), colHeaders2;
      }, []);
      return {
        rowHeaders,
        colHeaders
      };
    }
  }
  var DataContainer = ({ rows, columns, rowsData }) => {
    let styles2 = useStyles("TableInspectorDataContainer"), borderStyles = useStyles("TableInspectorLeftBorder");
    return react_default.createElement("div", {
      style: styles2.div
    }, react_default.createElement("table", {
      style: styles2.table
    }, react_default.createElement("colgroup", null), react_default.createElement("tbody", null, rows.map((row, i22) => react_default.createElement("tr", {
      key: row,
      style: styles2.tr
    }, react_default.createElement("td", {
      style: { ...styles2.td, ...borderStyles.none }
    }, row), columns.map((column) => {
      let rowData = rowsData[i22];
      return typeof rowData == "object" && rowData !== null && hasOwnProperty.call(rowData, column) ? react_default.createElement("td", {
        key: column,
        style: { ...styles2.td, ...borderStyles.solid }
      }, react_default.createElement(ObjectValue, {
        object: rowData[column]
      })) : react_default.createElement("td", {
        key: column,
        style: { ...styles2.td, ...borderStyles.solid }
      });
    }))))));
  }, SortIconContainer = (props) => react_default.createElement("div", {
    style: {
      position: "absolute",
      top: 1,
      right: 0,
      bottom: 1,
      display: "flex",
      alignItems: "center"
    }
  }, props.children), SortIcon = ({ sortAscending }) => {
    let styles2 = useStyles("TableInspectorSortIcon"), glyph = sortAscending ? "\u25B2" : "\u25BC";
    return react_default.createElement("div", {
      style: styles2
    }, glyph);
  }, TH = ({
    sortAscending = !1,
    sorted = !1,
    onClick = void 0,
    borderStyle = {},
    children,
    ...thProps
  }) => {
    let styles2 = useStyles("TableInspectorTH"), [hovered, setHovered] = useState(!1), handleMouseEnter = useCallback(() => setHovered(!0), []), handleMouseLeave = useCallback(() => setHovered(!1), []);
    return react_default.createElement("th", {
      ...thProps,
      style: {
        ...styles2.base,
        ...borderStyle,
        ...hovered ? styles2.base[":hover"] : {}
      },
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      onClick
    }, react_default.createElement("div", {
      style: styles2.div
    }, children), sorted && react_default.createElement(SortIconContainer, null, react_default.createElement(SortIcon, {
      sortAscending
    })));
  }, HeaderContainer = ({
    indexColumnText = "(index)",
    columns = [],
    sorted,
    sortIndexColumn,
    sortColumn,
    sortAscending,
    onTHClick,
    onIndexTHClick
  }) => {
    let styles2 = useStyles("TableInspectorHeaderContainer"), borderStyles = useStyles("TableInspectorLeftBorder");
    return react_default.createElement("div", {
      style: styles2.base
    }, react_default.createElement("table", {
      style: styles2.table
    }, react_default.createElement("tbody", null, react_default.createElement("tr", null, react_default.createElement(TH, {
      borderStyle: borderStyles.none,
      sorted: sorted && sortIndexColumn,
      sortAscending,
      onClick: onIndexTHClick
    }, indexColumnText), columns.map((column) => react_default.createElement(TH, {
      borderStyle: borderStyles.solid,
      key: column,
      sorted: sorted && sortColumn === column,
      sortAscending,
      onClick: onTHClick.bind(null, column)
    }, column))))));
  }, TableInspector = ({
    data,
    columns
  }) => {
    let styles2 = useStyles("TableInspector"), [{ sorted, sortIndexColumn, sortColumn, sortAscending }, setState] = useState({
      sorted: !1,
      sortIndexColumn: !1,
      sortColumn: void 0,
      sortAscending: !1
    }), handleIndexTHClick = useCallback(() => {
      setState(({ sortIndexColumn: sortIndexColumn2, sortAscending: sortAscending2 }) => ({
        sorted: !0,
        sortIndexColumn: !0,
        sortColumn: void 0,
        sortAscending: sortIndexColumn2 ? !sortAscending2 : !0
      }));
    }, []), handleTHClick = useCallback((col) => {
      setState(({ sortColumn: sortColumn2, sortAscending: sortAscending2 }) => ({
        sorted: !0,
        sortIndexColumn: !1,
        sortColumn: col,
        sortAscending: col === sortColumn2 ? !sortAscending2 : !0
      }));
    }, []);
    if (typeof data != "object" || data === null)
      return react_default.createElement("div", null);
    let { rowHeaders, colHeaders } = getHeaders(data);
    columns !== void 0 && (colHeaders = columns);
    let rowsData = rowHeaders.map((rowHeader) => data[rowHeader]), columnDataWithRowIndexes;
    if (sortColumn !== void 0 ? columnDataWithRowIndexes = rowsData.map((rowData, index2) => typeof rowData == "object" && rowData !== null ? [rowData[sortColumn], index2] : [void 0, index2]) : sortIndexColumn && (columnDataWithRowIndexes = rowHeaders.map((rowData, index2) => [rowHeaders[index2], index2])), columnDataWithRowIndexes !== void 0) {
      let comparator = (mapper, ascending) => (a22, b22) => {
        let v1 = mapper(a22), v22 = mapper(b22), type1 = typeof v1, type2 = typeof v22, lt = (v12, v222) => v12 < v222 ? -1 : v12 > v222 ? 1 : 0, result;
        if (type1 === type2)
          result = lt(v1, v22);
        else {
          let order = {
            string: 0,
            number: 1,
            object: 2,
            symbol: 3,
            boolean: 4,
            undefined: 5,
            function: 6
          };
          result = lt(order[type1], order[type2]);
        }
        return ascending || (result = -result), result;
      }, sortedRowIndexes = columnDataWithRowIndexes.sort(comparator((item) => item[0], sortAscending)).map((item) => item[1]);
      rowHeaders = sortedRowIndexes.map((i22) => rowHeaders[i22]), rowsData = sortedRowIndexes.map((i22) => rowsData[i22]);
    }
    return react_default.createElement("div", {
      style: styles2.base
    }, react_default.createElement(HeaderContainer, {
      columns: colHeaders,
      sorted,
      sortIndexColumn,
      sortColumn,
      sortAscending,
      onTHClick: handleTHClick,
      onIndexTHClick: handleIndexTHClick
    }), react_default.createElement(DataContainer, {
      rows: rowHeaders,
      columns: colHeaders,
      rowsData
    }));
  }, themedTableInspector = themeAcceptor(TableInspector), TEXT_NODE_MAX_INLINE_CHARS = 80, shouldInline = (data) => data.childNodes.length === 0 || data.childNodes.length === 1 && data.childNodes[0].nodeType === Node.TEXT_NODE && data.textContent.length < TEXT_NODE_MAX_INLINE_CHARS, OpenTag = ({ tagName, attributes, styles: styles2 }) => react_default.createElement("span", {
    style: styles2.base
  }, "<", react_default.createElement("span", {
    style: styles2.tagName
  }, tagName), (() => {
    if (attributes) {
      let attributeNodes = [];
      for (let i22 = 0; i22 < attributes.length; i22++) {
        let attribute = attributes[i22];
        attributeNodes.push(react_default.createElement("span", {
          key: i22
        }, " ", react_default.createElement("span", {
          style: styles2.htmlAttributeName
        }, attribute.name), '="', react_default.createElement("span", {
          style: styles2.htmlAttributeValue
        }, attribute.value), '"'));
      }
      return attributeNodes;
    }
  })(), ">"), CloseTag = ({ tagName, isChildNode = !1, styles: styles2 }) => react_default.createElement("span", {
    style: Object.assign({}, styles2.base, isChildNode && styles2.offsetLeft)
  }, "</", react_default.createElement("span", {
    style: styles2.tagName
  }, tagName), ">"), nameByNodeType = {
    1: "ELEMENT_NODE",
    3: "TEXT_NODE",
    7: "PROCESSING_INSTRUCTION_NODE",
    8: "COMMENT_NODE",
    9: "DOCUMENT_NODE",
    10: "DOCUMENT_TYPE_NODE",
    11: "DOCUMENT_FRAGMENT_NODE"
  }, DOMNodePreview = ({ isCloseTag, data, expanded }) => {
    let styles2 = useStyles("DOMNodePreview");
    if (isCloseTag)
      return react_default.createElement(CloseTag, {
        styles: styles2.htmlCloseTag,
        isChildNode: !0,
        tagName: data.tagName
      });
    switch (data.nodeType) {
      case Node.ELEMENT_NODE:
        return react_default.createElement("span", null, react_default.createElement(OpenTag, {
          tagName: data.tagName,
          attributes: data.attributes,
          styles: styles2.htmlOpenTag
        }), shouldInline(data) ? data.textContent : !expanded && "\u2026", !expanded && react_default.createElement(CloseTag, {
          tagName: data.tagName,
          styles: styles2.htmlCloseTag
        }));
      case Node.TEXT_NODE:
        return react_default.createElement("span", null, data.textContent);
      case Node.CDATA_SECTION_NODE:
        return react_default.createElement("span", null, "<![CDATA[" + data.textContent + "]]>");
      case Node.COMMENT_NODE:
        return react_default.createElement("span", {
          style: styles2.htmlComment
        }, "<!--", data.textContent, "-->");
      case Node.PROCESSING_INSTRUCTION_NODE:
        return react_default.createElement("span", null, data.nodeName);
      case Node.DOCUMENT_TYPE_NODE:
        return react_default.createElement("span", {
          style: styles2.htmlDoctype
        }, "<!DOCTYPE ", data.name, data.publicId ? ` PUBLIC "${data.publicId}"` : "", !data.publicId && data.systemId ? " SYSTEM" : "", data.systemId ? ` "${data.systemId}"` : "", ">");
      case Node.DOCUMENT_NODE:
        return react_default.createElement("span", null, data.nodeName);
      case Node.DOCUMENT_FRAGMENT_NODE:
        return react_default.createElement("span", null, data.nodeName);
      default:
        return react_default.createElement("span", null, nameByNodeType[data.nodeType]);
    }
  }, domIterator = function* (data) {
    if (data && data.childNodes) {
      if (shouldInline(data))
        return;
      for (let i22 = 0; i22 < data.childNodes.length; i22++) {
        let node = data.childNodes[i22];
        node.nodeType === Node.TEXT_NODE && node.textContent.trim().length === 0 || (yield {
          name: `${node.tagName}[${i22}]`,
          data: node
        });
      }
      data.tagName && (yield {
        name: "CLOSE_TAG",
        data: {
          tagName: data.tagName
        },
        isCloseTag: !0
      });
    }
  }, DOMInspector = (props) => react_default.createElement(TreeView, {
    nodeRenderer: DOMNodePreview,
    dataIterator: domIterator,
    ...props
  }), themedDOMInspector = themeAcceptor(DOMInspector), import_is_dom = __toESM2(require_is_dom()), Inspector = ({ table = !1, data, ...rest }) => table ? react_default.createElement(themedTableInspector, {
    data,
    ...rest
  }) : (0, import_is_dom.default)(data) ? react_default.createElement(themedDOMInspector, {
    data,
    ...rest
  }) : react_default.createElement(themedObjectInspector, {
    data,
    ...rest
  }), Action = styled.div({
    display: "flex",
    padding: 0,
    borderLeft: "5px solid transparent",
    borderBottom: "1px solid transparent",
    transition: "all 0.1s",
    alignItems: "flex-start",
    whiteSpace: "pre"
  }), Counter = styled.div(({ theme: theme3 }) => ({
    backgroundColor: curriedOpacify$1(0.5, theme3.appBorderColor),
    color: theme3.color.inverseText,
    fontSize: theme3.typography.size.s1,
    fontWeight: theme3.typography.weight.bold,
    lineHeight: 1,
    padding: "1px 5px",
    borderRadius: 20,
    margin: "2px 0px"
  })), InspectorContainer = styled.div({
    flex: 1,
    padding: "0 0 0 5px"
  }), UnstyledWrapped = forwardRef(
    ({ children, className }, ref) => react_default.createElement(ScrollArea, { ref, horizontal: !0, vertical: !0, className }, children)
  );
  UnstyledWrapped.displayName = "UnstyledWrapped";
  var Wrapper8 = styled(UnstyledWrapped)({
    margin: 0,
    padding: "10px 5px 20px"
  }), ThemedInspector = withTheme(({ theme: theme3, ...props }) => react_default.createElement(Inspector, { theme: theme3.addonActionsTheme || "chromeLight", table: !1, ...props })), ActionLogger = ({ actions, onClear }) => {
    let wrapperRef = useRef(null), wrapper = wrapperRef.current, wasAtBottom = wrapper && wrapper.scrollHeight - wrapper.scrollTop === wrapper.clientHeight;
    return useEffect(() => {
      wasAtBottom && (wrapperRef.current.scrollTop = wrapperRef.current.scrollHeight);
    }, [wasAtBottom, actions.length]), react_default.createElement(Fragment, null, react_default.createElement(Wrapper8, { ref: wrapperRef }, actions.map((action2) => react_default.createElement(Action, { key: action2.id }, action2.count > 1 && react_default.createElement(Counter, null, action2.count), react_default.createElement(InspectorContainer, null, react_default.createElement(
      ThemedInspector,
      {
        sortObjectKeys: !0,
        showNonenumerable: !1,
        name: action2.data.name,
        data: action2.data.args ?? action2.data
      }
    ))))), react_default.createElement(ActionBar, { actionItems: [{ title: "Clear", onClick: onClear }] }));
  }, safeDeepEqual = (a22, b22) => {
    try {
      return dequal(a22, b22);
    } catch {
      return !1;
    }
  }, ActionLogger2 = class extends Component {
    constructor(props) {
      super(props), this.handleStoryChange = () => {
        let { actions } = this.state;
        actions.length > 0 && actions[0].options.clearOnStoryChange && this.clearActions();
      }, this.addAction = (action2) => {
        this.setState((prevState) => {
          let actions = [...prevState.actions], previous = actions.length && actions[actions.length - 1];
          return previous && safeDeepEqual(previous.data, action2.data) ? previous.count++ : (action2.count = 1, actions.push(action2)), { actions: actions.slice(0, action2.options.limit) };
        });
      }, this.clearActions = () => {
        let { api } = this.props;
        api.emit(CLEAR_ID), this.setState({ actions: [] });
      }, this.mounted = !1, this.state = { actions: [] };
    }
    componentDidMount() {
      this.mounted = !0;
      let { api } = this.props;
      api.on(EVENT_ID, this.addAction), api.on(STORY_CHANGED, this.handleStoryChange);
    }
    componentWillUnmount() {
      this.mounted = !1;
      let { api } = this.props;
      api.off(STORY_CHANGED, this.handleStoryChange), api.off(EVENT_ID, this.addAction);
    }
    render() {
      let { actions = [] } = this.state, { active } = this.props, props = {
        actions,
        onClear: this.clearActions
      };
      return active ? react_default.createElement(ActionLogger, { ...props }) : null;
    }
  }, manager_default2 = addons.register(ADDON_ID4, (api) => {
    globalThis?.FEATURES?.actions && addons.add(PANEL_ID, {
      title: Title2,
      type: types.PANEL,
      render: ({ active }) => react_default.createElement(ActionLogger2, { api, active: !!active }),
      paramKey: PARAM_KEY4
    });
  }), ADDON_ID72 = "storybook/interactions", PANEL_ID22 = `${ADDON_ID72}/panel`, PARAM_KEY6 = "interactions", DOCUMENTATION_LINK = "writing-tests/integrations/vitest-addon", DOCUMENTATION_DISCREPANCY_LINK = `${DOCUMENTATION_LINK}#what-happens-when-there-are-different-test-results-in-multiple-environments`, DOCUMENTATION_PLAY_FUNCTION_LINK = "writing-stories/play-function#writing-stories-with-the-play-function", INTERNAL_RENDER_CALL_ID = "internal_render_call", ADDON_ID8 = "storybook/a11y", PANEL_ID32 = `${ADDON_ID8}/panel`, UI_STATE_ID = `${ADDON_ID8}/ui`, RESULT = `${ADDON_ID8}/result`, REQUEST = `${ADDON_ID8}/request`, RUNNING = `${ADDON_ID8}/running`, ERROR2 = `${ADDON_ID8}/error`, MANUAL = `${ADDON_ID8}/manual`, SELECT = `${ADDON_ID8}/select`, DOCUMENTATION_LINK2 = "writing-tests/accessibility-testing", DOCUMENTATION_DISCREPANCY_LINK2 = `${DOCUMENTATION_LINK2}#why-are-my-tests-failing-in-different-environments`, ADDON_ID9 = "storybook/test", TEST_PROVIDER_ID = `${ADDON_ID9}/test-provider`, STORYBOOK_ADDON_TEST_CHANNEL = `${ADDON_ID9}/channel`, DOCUMENTATION_LINK3 = "writing-tests/integrations/vitest-addon", DOCUMENTATION_FATAL_ERROR_LINK = `${DOCUMENTATION_LINK3}#what-happens-if-vitest-itself-has-an-error`, storeOptions = {
    id: ADDON_ID9,
    initialState: {
      config: {
        coverage: !1,
        a11y: !1
      },
      watching: !1,
      cancelling: !1,
      fatalError: void 0,
      indexUrl: void 0,
      previewAnnotations: [],
      currentRun: {
        triggeredBy: void 0,
        config: {
          coverage: !1,
          a11y: !1
        },
        componentTestCount: {
          success: 0,
          error: 0
        },
        a11yCount: {
          success: 0,
          warning: 0,
          error: 0
        },
        storyIds: void 0,
        totalTestCount: void 0,
        startedAt: void 0,
        finishedAt: void 0,
        unhandledErrors: [],
        coverageSummary: void 0
      }
    }
  }, STORE_CHANNEL_EVENT_NAME = `UNIVERSAL_STORE:${storeOptions.id}`, STATUS_TYPE_ID_COMPONENT_TEST = "storybook/component-test", import_ansi_to_html2 = __toESM(require_ansi_to_html(), 1);
  function ansiRegex({ onlyFirst = !1 } = {}) {
    let pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? void 0 : "g");
  }
  var regex = ansiRegex();
  function stripAnsi(string) {
    if (typeof string != "string")
      throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
    return string.replace(regex, "");
  }
  function isInteractionsDisabled(parameters2) {
    return !!parameters2?.[PARAM_KEY6]?.disable;
  }
  function isTestAssertionError(error) {
    return isChaiError(error) || isJestError(error);
  }
  function isChaiError(error) {
    return error && typeof error == "object" && "name" in error && typeof error.name == "string" && error.name === "AssertionError";
  }
  function isJestError(error) {
    return error && typeof error == "object" && "message" in error && typeof error.message == "string" && stripAnsi(error.message).startsWith("expect(");
  }
  function createAnsiToHtmlFilter(theme3) {
    return new import_ansi_to_html2.default({
      escapeXML: !0,
      fg: theme3.color.defaultText,
      bg: theme3.background.content
    });
  }
  function useAnsiToHtmlFilter() {
    let theme3 = useTheme();
    return createAnsiToHtmlFilter(theme3);
  }
  var Wrapper9 = styled.div(({ theme: { color: color2, typography: typography4, background: background2 } }) => ({
    textAlign: "start",
    padding: "11px 15px",
    fontSize: `${typography4.size.s2 - 1}px`,
    fontWeight: typography4.weight.regular,
    lineHeight: "1rem",
    background: background2.app,
    borderBottom: `1px solid ${color2.border}`,
    color: color2.defaultText,
    backgroundClip: "padding-box",
    position: "relative"
  })), DetachedDebuggerMessage = ({ storyUrl }) => react_default.createElement(Wrapper9, null, "Debugger controls are not available on composed Storybooks.", " ", react_default.createElement(
    Link,
    {
      href: `${storyUrl}&addonPanel=${PANEL_ID22}`,
      target: "_blank",
      rel: "noopener noreferrer",
      withArrow: !0
    },
    "Open in external Storybook"
  )), Links2 = styled.div(({ theme: theme3 }) => ({
    display: "flex",
    fontSize: theme3.typography.size.s2 - 1,
    gap: 25
  })), Empty2 = () => {
    let [isLoading, setIsLoading] = useState(!0), docsUrl = useStorybookApi().getDocsUrl({
      subpath: DOCUMENTATION_PLAY_FUNCTION_LINK,
      versioned: !0,
      renderer: !0
    });
    return useEffect(() => {
      let load = setTimeout(() => {
        setIsLoading(!1);
      }, 100);
      return () => clearTimeout(load);
    }, []), isLoading ? null : react_default.createElement("div", null, react_default.createElement(
      EmptyTabContent,
      {
        title: "Interactions",
        description: react_default.createElement(react_default.Fragment, null, "Interactions allow you to verify the functional aspects of UIs. Write a play function for your story and you'll see it run here."),
        footer: react_default.createElement(Links2, null, react_default.createElement(Link, { href: docsUrl, target: "_blank", withArrow: !0 }, react_default.createElement(DocumentIcon, null), " Read docs"))
      }
    ));
  };
  function toVal(mix2) {
    var k22, y22, str = "";
    if (mix2)
      if (typeof mix2 == "object")
        if (Array.isArray(mix2))
          for (k22 = 0; k22 < mix2.length; k22++)
            mix2[k22] && (y22 = toVal(mix2[k22])) && (str && (str += " "), str += y22);
        else
          for (k22 in mix2)
            mix2[k22] && (y22 = toVal(k22)) && (str && (str += " "), str += y22);
      else typeof mix2 != "boolean" && !mix2.call && (str && (str += " "), str += mix2);
    return str;
  }
  function clsx_m_default() {
    for (var i22 = 0, x22, str = ""; i22 < arguments.length; )
      (x22 = toVal(arguments[i22++])) && (str && (str += " "), str += x22);
    return str;
  }
  var isArray = (val) => Array.isArray(val) || // Detect https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays
  ArrayBuffer.isView(val) && !(val instanceof DataView), isObject2 = (val) => val !== null && typeof val == "object" && !isArray(val) && !(val instanceof Date) && !(val instanceof RegExp) && !(val instanceof Error) && !(val instanceof WeakMap) && !(val instanceof WeakSet), isKnownObject = (val) => isObject2(val) || isArray(val) || typeof val == "function" || val instanceof Promise, getPromiseState = (promise) => {
    let unique = /unique/;
    return Promise.race([promise, unique]).then((result) => result === unique ? ["pending"] : ["fulfilled", result], (e2) => ["rejected", e2]);
  }, buildAST = async (key, value2, depth, sortKeys, isPrototype, showPrototype) => {
    let astNode = {
      key,
      depth,
      value: value2,
      type: "value",
      parent: void 0
    };
    if (value2 && isKnownObject(value2) && depth < 100) {
      let children = [], t = "object";
      if (isArray(value2)) {
        for (let i22 = 0; i22 < value2.length; i22++)
          children.push(async () => {
            let child = await buildAST(i22.toString(), value2[i22], depth + 1, sortKeys);
            return child.parent = astNode, child;
          });
        t = "array";
      } else {
        let keys = Object.getOwnPropertyNames(value2);
        sortKeys && keys.sort();
        for (let i22 = 0; i22 < keys.length; i22++) {
          let safeValue;
          try {
            safeValue = value2[keys[i22]];
          } catch {
          }
          children.push(async () => {
            let child = await buildAST(keys[i22], safeValue, depth + 1, sortKeys);
            return child.parent = astNode, child;
          });
        }
        if (typeof value2 == "function" && (t = "function"), value2 instanceof Promise) {
          let [status, result] = await getPromiseState(value2);
          children.push(async () => {
            let child = await buildAST("<state>", status, depth + 1, sortKeys);
            return child.parent = astNode, child;
          }), status !== "pending" && children.push(async () => {
            let child = await buildAST("<value>", result, depth + 1, sortKeys);
            return child.parent = astNode, child;
          }), t = "promise";
        }
        if (value2 instanceof Map) {
          let parsedEntries = Array.from(value2.entries()).map((entry) => {
            let [entryKey, entryValue] = entry;
            return {
              "<key>": entryKey,
              "<value>": entryValue
            };
          });
          children.push(async () => {
            let child = await buildAST("<entries>", parsedEntries, depth + 1, sortKeys);
            return child.parent = astNode, child;
          }), children.push(async () => {
            let child = await buildAST("size", value2.size, depth + 1, sortKeys);
            return child.parent = astNode, child;
          }), t = "map";
        }
        if (value2 instanceof Set) {
          let parsedEntries = Array.from(value2.entries()).map((entry) => entry[1]);
          children.push(async () => {
            let child = await buildAST("<entries>", parsedEntries, depth + 1, sortKeys);
            return child.parent = astNode, child;
          }), children.push(async () => {
            let child = await buildAST("size", value2.size, depth + 1, sortKeys);
            return child.parent = astNode, child;
          }), t = "set";
        }
      }
      value2 !== Object.prototype && showPrototype && children.push(async () => {
        let child = await buildAST("<prototype>", Object.getPrototypeOf(value2), depth + 1, sortKeys, !0);
        return child.parent = astNode, child;
      }), astNode.type = t, astNode.children = children, astNode.isPrototype = isPrototype;
    }
    return astNode;
  }, parse4 = (data, sortKeys, includePrototypes) => buildAST("root", data, 0, sortKeys === !1 ? sortKeys : !0, void 0, includePrototypes === !1 ? includePrototypes : !0);
  function ownKeys(e2, r2) {
    var t = Object.keys(e2);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e2);
      r2 && (o2 = o2.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
      })), t.push.apply(t, o2);
    }
    return t;
  }
  function _objectSpread2(e2) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = arguments[r2] != null ? arguments[r2] : {};
      r2 % 2 ? ownKeys(Object(t), !0).forEach(function(r3) {
        _defineProperty(e2, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r3) {
        Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e2;
  }
  function toVal2(mix2) {
    var k22, y22, str = "";
    if (mix2)
      if (typeof mix2 == "object")
        if (Array.isArray(mix2))
          for (k22 = 0; k22 < mix2.length; k22++)
            mix2[k22] && (y22 = toVal2(mix2[k22])) && (str && (str += " "), str += y22);
        else
          for (k22 in mix2)
            mix2[k22] && (y22 = toVal2(k22)) && (str && (str += " "), str += y22);
      else typeof mix2 != "boolean" && !mix2.call && (str && (str += " "), str += mix2);
    return str;
  }
  function clsx_m_default2() {
    for (var i22 = 0, x22, str = ""; i22 < arguments.length; )
      (x22 = toVal2(arguments[i22++])) && (str && (str += " "), str += x22);
    return str;
  }
  var _excluded = ["children"], ThemeContext2 = react_default.createContext({
    theme: "chrome",
    colorScheme: "light"
  }), ThemeProvider2 = (_ref) => {
    let {
      children
    } = _ref, value2 = _objectWithoutProperties(_ref, _excluded), wrappedTheme = react_default.useContext(ThemeContext2);
    return react_default.createElement(ThemeContext2.Provider, {
      value: _objectSpread2(_objectSpread2({}, wrappedTheme), value2)
    }, children);
  }, useTheme3 = (props, styles2 = {}) => {
    let themeContext = react_default.useContext(ThemeContext2), currentTheme = props.theme || themeContext.theme || "chrome", currentColorScheme = props.colorScheme || themeContext.colorScheme || "light", themeClass = clsx_m_default2(styles2[currentTheme], styles2[currentColorScheme]);
    return {
      currentColorScheme,
      currentTheme,
      themeClass
    };
  };
  function toVal3(mix2) {
    var k22, y22, str = "";
    if (mix2)
      if (typeof mix2 == "object")
        if (Array.isArray(mix2))
          for (k22 = 0; k22 < mix2.length; k22++)
            mix2[k22] && (y22 = toVal3(mix2[k22])) && (str && (str += " "), str += y22);
        else
          for (k22 in mix2)
            mix2[k22] && (y22 = toVal3(k22)) && (str && (str += " "), str += y22);
      else typeof mix2 != "boolean" && !mix2.call && (str && (str += " "), str += mix2);
    return str;
  }
  function clsx_m_default3() {
    for (var i22 = 0, x22, str = ""; i22 < arguments.length; )
      (x22 = toVal3(arguments[i22++])) && (str && (str += " "), str += x22);
    return str;
  }
  var TreeContext = react_default.createContext({
    isChild: !1,
    depth: 0,
    hasHover: !0
  }), TreeContext_default = TreeContext, Tree_css_default = { tree: "Tree-tree-fbbbe38", item: "Tree-item-353d6f3", group: "Tree-group-d3c3d8a", label: "Tree-label-d819155", focusWhite: "Tree-focusWhite-f1e00c2", arrow: "Tree-arrow-03ab2e7", hover: "Tree-hover-3cc4e5d", open: "Tree-open-3f1a336", dark: "Tree-dark-1b4aa00", chrome: "Tree-chrome-bcbcac6", light: "Tree-light-09174ee" }, _excluded2 = ["theme", "hover", "colorScheme", "children", "label", "className", "onUpdate", "onSelect", "open"], Tree = (props) => {
    let {
      theme: theme3,
      hover,
      colorScheme,
      children,
      label,
      className,
      onUpdate,
      onSelect,
      open
    } = props, html = _objectWithoutProperties(props, _excluded2), {
      themeClass,
      currentTheme
    } = useTheme3({
      theme: theme3,
      colorScheme
    }, Tree_css_default), [isOpen, setOpen] = useState(open);
    useEffect(() => {
      setOpen(open);
    }, [open]);
    let updateState = (value2) => {
      setOpen(value2), onUpdate && onUpdate(value2);
    }, hasChildren = react_default.Children.count(children) > 0, updateFocus = (newNode, previousNode) => {
      if (newNode.isSameNode(previousNode || null)) return;
      newNode.querySelector('[tabindex="-1"]')?.focus(), newNode.setAttribute("aria-selected", "true"), previousNode?.removeAttribute("aria-selected");
    }, getParent = (node, role) => {
      let parent = node;
      for (; parent && parent.parentElement; ) {
        if (parent.getAttribute("role") === role)
          return parent;
        parent = parent.parentElement;
      }
      return null;
    }, getListElements = (node) => {
      let tree = getParent(node, "tree");
      return tree ? Array.from(tree.querySelectorAll("li")) : [];
    }, moveBack = (node) => {
      let group = getParent(node, "group"), toggle = group?.previousElementSibling;
      if (toggle && toggle.getAttribute("tabindex") === "-1") {
        let toggleParent = toggle.parentElement, nodeParent = node.parentElement;
        updateFocus(toggleParent, nodeParent);
      }
    }, moveHome = (node, direction) => {
      let elements = getListElements(node);
      elements.forEach((element) => {
        element.removeAttribute("aria-selected");
      }), direction === "start" && elements[0] && updateFocus(elements[0]), direction === "end" && elements[elements.length - 1] && updateFocus(elements[elements.length - 1]);
    }, moveFocusAdjacent = (node, direction) => {
      let elements = getListElements(node) || [];
      for (let i22 = 0; i22 < elements.length; i22++) {
        let currentNode = elements[i22];
        if (currentNode.getAttribute("aria-selected") === "true") {
          direction === "up" && elements[i22 - 1] ? updateFocus(elements[i22 - 1], currentNode) : direction === "down" && elements[i22 + 1] && updateFocus(elements[i22 + 1], currentNode);
          return;
        }
      }
      updateFocus(elements[0]);
    }, handleKeypress = (event, isChild2) => {
      let node = event.target;
      (event.key === "Enter" || event.key === " ") && updateState(!isOpen), event.key === "ArrowRight" && isOpen && !isChild2 ? moveFocusAdjacent(node, "down") : event.key === "ArrowRight" && updateState(!0), event.key === "ArrowLeft" && (!isOpen || isChild2) ? moveBack(node) : event.key === "ArrowLeft" && updateState(!1), event.key === "ArrowDown" && moveFocusAdjacent(node, "down"), event.key === "ArrowUp" && moveFocusAdjacent(node, "up"), event.key === "Home" && moveHome(node, "start"), event.key === "End" && moveHome(node, "end");
    }, handleClick = (event, isChild2) => {
      let node = event.target, parent = getParent(node, "treeitem"), elements = getListElements(node) || [], found = !1;
      for (let i22 = 0; i22 < elements.length; i22++) {
        let currentNode = elements[i22];
        if (currentNode.getAttribute("aria-selected") === "true") {
          parent && (found = !0, updateFocus(parent, currentNode));
          break;
        }
      }
      !found && parent && updateFocus(parent), isChild2 || updateState(!isOpen);
    }, handleBlur = (event) => {
      let node = event.currentTarget;
      !node.contains(document.activeElement) && node.getAttribute("role") === "tree" && node.setAttribute("tabindex", "0");
    }, handleFocus = (event) => {
      let node = event.target;
      if (node.getAttribute("role") === "tree") {
        let selected = node.querySelector('[aria-selected="true"]');
        selected ? updateFocus(selected) : moveFocusAdjacent(node, "down"), node.setAttribute("tabindex", "-1");
      }
    }, handleButtonFocus = () => {
      onSelect?.();
    }, getPaddingStyles = (depth2) => {
      let space = depth2 * 0.9 + 0.3;
      return {
        paddingLeft: `${space}em`,
        width: `calc(100% - ${space}em)`
      };
    }, {
      isChild,
      depth,
      hasHover
    } = react_default.useContext(TreeContext_default), showHover = hasHover ? hover : !1;
    if (!isChild)
      return react_default.createElement("ul", _extends({
        role: "tree",
        tabIndex: 0,
        className: clsx_m_default3(Tree_css_default.tree, Tree_css_default.group, themeClass, className),
        onFocus: handleFocus,
        onBlur: handleBlur
      }, html), react_default.createElement(TreeContext_default.Provider, {
        value: {
          isChild: !0,
          depth: 0,
          hasHover: showHover
        }
      }, react_default.createElement(Tree, props)));
    if (!hasChildren)
      return react_default.createElement("li", _extends({
        role: "treeitem",
        className: Tree_css_default.item
      }, html), react_default.createElement("div", {
        role: "button",
        className: clsx_m_default3(Tree_css_default.label, {
          [Tree_css_default.hover]: showHover,
          [Tree_css_default.focusWhite]: currentTheme === "firefox"
        }),
        tabIndex: -1,
        style: getPaddingStyles(depth),
        onKeyDown: (e2) => {
          handleKeypress(e2, isChild);
        },
        onClick: (e2) => handleClick(e2, !0),
        onFocus: handleButtonFocus
      }, react_default.createElement("span", null, label)));
    let arrowClass = clsx_m_default3(Tree_css_default.arrow, {
      [Tree_css_default.open]: isOpen
    });
    return react_default.createElement("li", {
      role: "treeitem",
      "aria-expanded": isOpen,
      className: Tree_css_default.item
    }, react_default.createElement("div", {
      role: "button",
      tabIndex: -1,
      className: clsx_m_default3(Tree_css_default.label, {
        [Tree_css_default.hover]: showHover,
        [Tree_css_default.focusWhite]: currentTheme === "firefox"
      }),
      style: getPaddingStyles(depth),
      onClick: (e2) => handleClick(e2),
      onKeyDown: (e2) => handleKeypress(e2),
      onFocus: handleButtonFocus
    }, react_default.createElement("span", null, react_default.createElement("span", {
      "aria-hidden": !0,
      className: arrowClass
    }), react_default.createElement("span", null, label))), react_default.createElement("ul", _extends({
      role: "group",
      className: clsx_m_default3(className, Tree_css_default.group)
    }, html), isOpen && react_default.Children.map(children, (child) => react_default.createElement(TreeContext_default.Provider, {
      value: {
        isChild: !0,
        depth: depth + 1,
        hasHover: showHover
      }
    }, child))));
  };
  Tree.defaultProps = {
    open: !1,
    hover: !0
  };
  var ObjectInspector_css_default = { "object-inspector": "ObjectInspector-object-inspector-0c33e82", objectInspector: "ObjectInspector-object-inspector-0c33e82", "object-label": "ObjectInspector-object-label-b81482b", objectLabel: "ObjectInspector-object-label-b81482b", text: "ObjectInspector-text-25f57f3", key: "ObjectInspector-key-4f712bb", value: "ObjectInspector-value-f7ec2e5", string: "ObjectInspector-string-c496000", regex: "ObjectInspector-regex-59d45a3", error: "ObjectInspector-error-b818698", boolean: "ObjectInspector-boolean-2dd1642", number: "ObjectInspector-number-a6daabb", undefined: "ObjectInspector-undefined-3a68263", null: "ObjectInspector-null-74acb50", function: "ObjectInspector-function-07bbdcd", "function-decorator": "ObjectInspector-function-decorator-3d22c24", functionDecorator: "ObjectInspector-function-decorator-3d22c24", prototype: "ObjectInspector-prototype-f2449ee", dark: "ObjectInspector-dark-0c96c97", chrome: "ObjectInspector-chrome-2f3ca98", light: "ObjectInspector-light-78bef54" }, _excluded3 = ["ast", "theme", "showKey", "colorScheme", "className"], buildValue = (key, value2, valueClass, showKey, depth) => {
    let computedKey = key.includes("-") ? `"${key}"` : key, isRoot = depth <= 0;
    return react_default.createElement("span", {
      className: ObjectInspector_css_default.text
    }, !isRoot && showKey && react_default.createElement(react_default.Fragment, null, react_default.createElement("span", {
      className: ObjectInspector_css_default.key
    }, computedKey), react_default.createElement("span", null, ":\xA0")), react_default.createElement("span", {
      className: valueClass
    }, value2));
  }, ObjectValue2 = (props) => {
    let {
      ast,
      theme: theme3,
      showKey,
      colorScheme,
      className
    } = props, html = _objectWithoutProperties(props, _excluded3), {
      themeClass
    } = useTheme3({
      theme: theme3,
      colorScheme
    }, ObjectInspector_css_default), [asyncValue, setAsyncValue] = useState(react_default.createElement("span", null)), value2 = react_default.createElement("span", null);
    return useEffect(() => {
      ast.value instanceof Promise && (async (promise) => {
        setAsyncValue(buildValue(ast.key, `Promise { "${await getPromiseState(promise)}" }`, ObjectInspector_css_default.key, showKey, ast.depth));
      })(ast.value);
    }, [ast, showKey]), typeof ast.value == "number" || typeof ast.value == "bigint" ? value2 = buildValue(ast.key, String(ast.value), ObjectInspector_css_default.number, showKey, ast.depth) : typeof ast.value == "boolean" ? value2 = buildValue(ast.key, String(ast.value), ObjectInspector_css_default.boolean, showKey, ast.depth) : typeof ast.value == "string" ? value2 = buildValue(ast.key, `"${ast.value}"`, ObjectInspector_css_default.string, showKey, ast.depth) : typeof ast.value > "u" ? value2 = buildValue(ast.key, "undefined", ObjectInspector_css_default.undefined, showKey, ast.depth) : typeof ast.value == "symbol" ? value2 = buildValue(ast.key, ast.value.toString(), ObjectInspector_css_default.string, showKey, ast.depth) : typeof ast.value == "function" ? value2 = buildValue(ast.key, `${ast.value.name}()`, ObjectInspector_css_default.key, showKey, ast.depth) : typeof ast.value == "object" && (ast.value === null ? value2 = buildValue(ast.key, "null", ObjectInspector_css_default.null, showKey, ast.depth) : Array.isArray(ast.value) ? value2 = buildValue(ast.key, `Array(${ast.value.length})`, ObjectInspector_css_default.key, showKey, ast.depth) : ast.value instanceof Date ? value2 = buildValue(ast.key, `Date ${ast.value.toString()}`, ObjectInspector_css_default.value, showKey, ast.depth) : ast.value instanceof RegExp ? value2 = buildValue(ast.key, ast.value.toString(), ObjectInspector_css_default.regex, showKey, ast.depth) : ast.value instanceof Error ? value2 = buildValue(ast.key, ast.value.toString(), ObjectInspector_css_default.error, showKey, ast.depth) : isObject2(ast.value) ? value2 = buildValue(ast.key, "{\u2026}", ObjectInspector_css_default.key, showKey, ast.depth) : value2 = buildValue(ast.key, ast.value.constructor.name, ObjectInspector_css_default.key, showKey, ast.depth)), react_default.createElement("span", _extends({
      className: clsx_m_default(themeClass, className)
    }, html), asyncValue, value2);
  };
  ObjectValue2.defaultProps = {
    showKey: !0
  };
  var ObjectValue_default = ObjectValue2, _excluded4 = ["ast", "theme", "previewMax", "open", "colorScheme", "className"], buildPreview = (children, previewMax, showKey) => {
    let previews = [];
    for (let i22 = 0; i22 < children.length; i22++) {
      let child = children[i22];
      if (child.isPrototype || (previews.push(react_default.createElement(ObjectValue_default, {
        key: child.key,
        ast: child,
        showKey
      })), i22 < children.length - 1 ? previews.push(", ") : previews.push(" ")), child.isPrototype && i22 === children.length - 1 && (previews.pop(), previews.push(" ")), i22 === previewMax - 1 && children.length > previewMax) {
        previews.push("\u2026 ");
        break;
      }
    }
    return previews;
  }, getArrayLabel = (ast, open, previewMax, theme3) => {
    let l2 = ast.value.length;
    return open ? react_default.createElement("span", null, "Array(", l2, ")") : react_default.createElement(react_default.Fragment, null, react_default.createElement("span", null, `${theme3 === "firefox" ? "Array" : ""}(${l2}) [ `), buildPreview(ast.children, previewMax, !1), react_default.createElement("span", null, "]"));
  }, getObjectLabel = (ast, open, previewMax, theme3) => ast.isPrototype ? react_default.createElement("span", null, `Object ${theme3 === "firefox" ? "{ \u2026 }" : ""}`) : open ? react_default.createElement("span", null, "{\u2026}") : react_default.createElement(react_default.Fragment, null, react_default.createElement("span", null, `${theme3 === "firefox" ? "Object " : ""}{ `), buildPreview(ast.children, previewMax, !0), react_default.createElement("span", null, "}")), getPromiseLabel = (ast, open, previewMax) => open ? react_default.createElement("span", null, `Promise { "${String(ast.children[0].value)}" }`) : react_default.createElement(react_default.Fragment, null, react_default.createElement("span", null, "Promise { "), buildPreview(ast.children, previewMax, !0), react_default.createElement("span", null, "}")), getMapLabel = (ast, open, previewMax, theme3) => {
    let {
      size
    } = ast.value;
    return open ? react_default.createElement("span", null, `Map(${size})`) : react_default.createElement(react_default.Fragment, null, react_default.createElement("span", null, `Map${theme3 === "chrome" ? `(${size})` : ""} { `), buildPreview(ast.children, previewMax, !0), react_default.createElement("span", null, "}"));
  }, getSetLabel = (ast, open, previewMax) => {
    let {
      size
    } = ast.value;
    return open ? react_default.createElement("span", null, "Set(", size, ")") : react_default.createElement(react_default.Fragment, null, react_default.createElement("span", null, `Set(${ast.value.size}) {`), buildPreview(ast.children, previewMax, !0), react_default.createElement("span", null, "}"));
  }, ObjectLabel2 = (props) => {
    let {
      ast,
      theme: theme3,
      previewMax,
      open,
      colorScheme,
      className
    } = props, html = _objectWithoutProperties(props, _excluded4), {
      themeClass,
      currentTheme
    } = useTheme3({
      theme: theme3,
      colorScheme
    }, ObjectInspector_css_default), isPrototype = ast.isPrototype || !1, classes = clsx_m_default(ObjectInspector_css_default.objectLabel, themeClass, className, {
      [ObjectInspector_css_default.prototype]: isPrototype
    }), isRoot = ast.depth <= 0, Key = () => react_default.createElement("span", {
      className: isPrototype ? ObjectInspector_css_default.prototype : ObjectInspector_css_default.key
    }, isRoot ? "" : `${ast.key}: `);
    return ast.type === "array" ? react_default.createElement("span", _extends({
      className: classes
    }, html), react_default.createElement(Key, null), getArrayLabel(ast, open, previewMax, currentTheme)) : ast.type === "function" ? react_default.createElement("span", _extends({
      className: classes
    }, html), react_default.createElement(Key, null), currentTheme === "chrome" && react_default.createElement("span", {
      className: ObjectInspector_css_default.functionDecorator
    }, "\u0192 "), react_default.createElement("span", {
      className: clsx_m_default({
        [ObjectInspector_css_default.function]: !isPrototype
      })
    }, `${ast.value.name}()`)) : ast.type === "promise" ? react_default.createElement("span", _extends({
      className: classes
    }, html), react_default.createElement(Key, null), getPromiseLabel(ast, open, previewMax)) : ast.type === "map" ? react_default.createElement("span", _extends({
      className: classes
    }, html), react_default.createElement(Key, null), getMapLabel(ast, open, previewMax, currentTheme)) : ast.type === "set" ? react_default.createElement("span", _extends({
      className: classes
    }, html), react_default.createElement(Key, null), getSetLabel(ast, open, previewMax)) : react_default.createElement("span", _extends({
      className: classes
    }, html), react_default.createElement(Key, null), getObjectLabel(ast, open, previewMax, currentTheme));
  };
  ObjectLabel2.defaultProps = {
    previewMax: 8,
    open: !1
  };
  var ObjectLabel_default = ObjectLabel2, ObjectInspectorItem = (props) => {
    let {
      ast,
      expandLevel,
      depth
    } = props, [resolved, setResolved] = useState(), [open, setOpen] = useState(depth < expandLevel);
    return useEffect(() => {
      (async () => {
        if (ast.type !== "value") {
          let promises = ast.children.map((f22) => f22()), children = await Promise.all(promises), r2 = _objectSpread2(_objectSpread2({}, ast), {}, {
            children
          });
          setResolved(r2);
        }
      })();
    }, [ast]), resolved ? react_default.createElement(Tree, {
      hover: !1,
      open,
      label: react_default.createElement(ObjectLabel_default, {
        open,
        ast: resolved
      }),
      onSelect: () => {
        var _props$onSelect;
        (_props$onSelect = props.onSelect) === null || _props$onSelect === void 0 || _props$onSelect.call(props, ast);
      },
      onUpdate: (value2) => {
        setOpen(value2);
      }
    }, resolved.children.map((child) => react_default.createElement(ObjectInspectorItem, {
      key: child.key,
      ast: child,
      depth: depth + 1,
      expandLevel,
      onSelect: props.onSelect
    }))) : react_default.createElement(Tree, {
      hover: !1,
      label: react_default.createElement(ObjectValue_default, {
        ast
      }),
      onSelect: () => {
        var _props$onSelect2;
        (_props$onSelect2 = props.onSelect) === null || _props$onSelect2 === void 0 || _props$onSelect2.call(props, ast);
      }
    });
  };
  ObjectInspectorItem.defaultProps = {
    expandLevel: 0,
    depth: 0
  };
  var ObjectInspectorItem_default = ObjectInspectorItem, _excluded5 = ["data", "expandLevel", "sortKeys", "includePrototypes", "className", "theme", "colorScheme", "onSelect"], ObjectInspector2 = (props) => {
    let {
      data,
      expandLevel,
      sortKeys,
      includePrototypes,
      className,
      theme: theme3,
      colorScheme,
      onSelect
    } = props, html = _objectWithoutProperties(props, _excluded5), [ast, setAST] = useState(void 0), {
      themeClass,
      currentTheme,
      currentColorScheme
    } = useTheme3({
      theme: theme3,
      colorScheme
    }, ObjectInspector_css_default);
    return useEffect(() => {
      (async () => setAST(await parse4(data, sortKeys, includePrototypes)))();
    }, [data, sortKeys, includePrototypes]), react_default.createElement("div", _extends({
      className: clsx_m_default(ObjectInspector_css_default.objectInspector, className, themeClass)
    }, html), ast && react_default.createElement(ThemeProvider2, {
      theme: currentTheme,
      colorScheme: currentColorScheme
    }, react_default.createElement(ObjectInspectorItem_default, {
      ast,
      expandLevel,
      onSelect
    })));
  };
  ObjectInspector2.defaultProps = {
    expandLevel: 0,
    sortKeys: !0,
    includePrototypes: !0
  };
  var colorsLight = {
    base: "#444",
    nullish: "#7D99AA",
    string: "#16B242",
    number: "#5D40D0",
    boolean: "#f41840",
    objectkey: "#698394",
    instance: "#A15C20",
    function: "#EA7509",
    muted: "#7D99AA",
    tag: {
      name: "#6F2CAC",
      suffix: "#1F99E5"
    },
    date: "#459D9C",
    error: {
      name: "#D43900",
      message: "#444"
    },
    regex: {
      source: "#A15C20",
      flags: "#EA7509"
    },
    meta: "#EA7509",
    method: "#0271B6"
  }, colorsDark = {
    base: "#eee",
    nullish: "#aaa",
    string: "#5FE584",
    number: "#6ba5ff",
    boolean: "#ff4191",
    objectkey: "#accfe6",
    instance: "#E3B551",
    function: "#E3B551",
    muted: "#aaa",
    tag: {
      name: "#f57bff",
      suffix: "#8EB5FF"
    },
    date: "#70D4D3",
    error: {
      name: "#f40",
      message: "#eee"
    },
    regex: {
      source: "#FAD483",
      flags: "#E3B551"
    },
    meta: "#FAD483",
    method: "#5EC1FF"
  }, useThemeColors = () => {
    let { base } = useTheme();
    return base === "dark" ? colorsDark : colorsLight;
  }, special = /[^A-Z0-9]/i, trimEnd = /[\s.,]+$/gm, ellipsize = (string, maxlength) => {
    if (string.length <= maxlength)
      return string;
    for (let i22 = maxlength - 1; i22 >= 0; i22 -= 1)
      if (special.test(string[i22]) && i22 > 10)
        return `${string.slice(0, i22).replace(trimEnd, "")}\u2026`;
    return `${string.slice(0, maxlength).replace(trimEnd, "")}\u2026`;
  }, stringify3 = (value2) => {
    try {
      return JSON.stringify(value2, null, 1);
    } catch {
      return String(value2);
    }
  }, interleave = (nodes, separator) => nodes.flatMap(
    (node, index2) => index2 === nodes.length - 1 ? [node] : [node, react_default.cloneElement(separator, { key: `sep${index2}` })]
  ), Node2 = ({
    value: value2,
    nested,
    showObjectInspector,
    callsById,
    ...props
  }) => {
    switch (!0) {
      case value2 === null:
        return react_default.createElement(NullNode, { ...props });
      case value2 === void 0:
        return react_default.createElement(UndefinedNode, { ...props });
      case Array.isArray(value2):
        return react_default.createElement(ArrayNode, { ...props, value: value2, callsById });
      case typeof value2 == "string":
        return react_default.createElement(StringNode, { ...props, value: value2 });
      case typeof value2 == "number":
        return react_default.createElement(NumberNode, { ...props, value: value2 });
      case typeof value2 == "boolean":
        return react_default.createElement(BooleanNode, { ...props, value: value2 });
      case Object.prototype.hasOwnProperty.call(value2, "__date__"):
        return react_default.createElement(DateNode, { ...props, ...value2.__date__ });
      case Object.prototype.hasOwnProperty.call(value2, "__error__"):
        return react_default.createElement(ErrorNode, { ...props, ...value2.__error__ });
      case Object.prototype.hasOwnProperty.call(value2, "__regexp__"):
        return react_default.createElement(RegExpNode, { ...props, ...value2.__regexp__ });
      case Object.prototype.hasOwnProperty.call(value2, "__function__"):
        return react_default.createElement(FunctionNode, { ...props, ...value2.__function__ });
      case Object.prototype.hasOwnProperty.call(value2, "__symbol__"):
        return react_default.createElement(SymbolNode, { ...props, ...value2.__symbol__ });
      case Object.prototype.hasOwnProperty.call(value2, "__element__"):
        return react_default.createElement(ElementNode, { ...props, ...value2.__element__ });
      case Object.prototype.hasOwnProperty.call(value2, "__class__"):
        return react_default.createElement(ClassNode, { ...props, ...value2.__class__ });
      case Object.prototype.hasOwnProperty.call(value2, "__callId__"):
        return react_default.createElement(MethodCall, { call: callsById?.get(value2.__callId__), callsById });
      case Object.prototype.toString.call(value2) === "[object Object]":
        return react_default.createElement(
          ObjectNode,
          {
            value: value2,
            showInspector: showObjectInspector,
            callsById,
            ...props
          }
        );
      default:
        return react_default.createElement(OtherNode, { value: value2, ...props });
    }
  }, NullNode = (props) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.nullish }, ...props }, "null");
  }, UndefinedNode = (props) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.nullish }, ...props }, "undefined");
  }, StringNode = ({ value: value2, ...props }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.string }, ...props }, JSON.stringify(ellipsize(value2, 50)));
  }, NumberNode = ({ value: value2, ...props }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.number }, ...props }, value2);
  }, BooleanNode = ({ value: value2, ...props }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.boolean }, ...props }, String(value2));
  }, ArrayNode = ({
    value: value2,
    nested = !1,
    callsById
  }) => {
    let colors3 = useThemeColors();
    if (nested)
      return react_default.createElement("span", { style: { color: colors3.base } }, "[\u2026]");
    let nodes = value2.slice(0, 3).map((v22, index2) => react_default.createElement(Node2, { key: `${index2}--${JSON.stringify(v22)}`, value: v22, nested: !0, callsById })), nodelist = interleave(nodes, react_default.createElement("span", null, ", "));
    return value2.length <= 3 ? react_default.createElement("span", { style: { color: colors3.base } }, "[", nodelist, "]") : react_default.createElement("span", { style: { color: colors3.base } }, "(", value2.length, ") [", nodelist, ", \u2026]");
  }, ObjectNode = ({
    showInspector,
    value: value2,
    callsById,
    nested = !1
  }) => {
    let isDarkMode = useTheme().base === "dark", colors3 = useThemeColors();
    if (showInspector)
      return react_default.createElement(react_default.Fragment, null, react_default.createElement(
        ObjectInspector2,
        {
          id: "interactions-object-inspector",
          data: value2,
          includePrototypes: !1,
          colorScheme: isDarkMode ? "dark" : "light"
        }
      ));
    if (nested)
      return react_default.createElement("span", { style: { color: colors3.base } }, "{\u2026}");
    let nodelist = interleave(
      Object.entries(value2).slice(0, 2).map(([k22, v22]) => react_default.createElement(Fragment, { key: k22 }, react_default.createElement("span", { style: { color: colors3.objectkey } }, k22, ": "), react_default.createElement(Node2, { value: v22, callsById, nested: !0 }))),
      react_default.createElement("span", null, ", ")
    );
    return Object.keys(value2).length <= 2 ? react_default.createElement("span", { style: { color: colors3.base } }, "{ ", nodelist, " }") : react_default.createElement("span", { style: { color: colors3.base } }, "(", Object.keys(value2).length, ") ", "{ ", nodelist, ", \u2026 }");
  }, ClassNode = ({ name }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.instance } }, name);
  }, FunctionNode = ({ name }) => {
    let colors3 = useThemeColors();
    return name ? react_default.createElement("span", { style: { color: colors3.function } }, name) : react_default.createElement("span", { style: { color: colors3.nullish, fontStyle: "italic" } }, "anonymous");
  }, ElementNode = ({
    prefix: prefix2,
    localName,
    id: id2,
    classNames = [],
    innerText
  }) => {
    let name = prefix2 ? `${prefix2}:${localName}` : localName, colors3 = useThemeColors();
    return react_default.createElement("span", { style: { wordBreak: "keep-all" } }, react_default.createElement("span", { key: `${name}_lt`, style: { color: colors3.muted } }, "<"), react_default.createElement("span", { key: `${name}_tag`, style: { color: colors3.tag.name } }, name), react_default.createElement("span", { key: `${name}_suffix`, style: { color: colors3.tag.suffix } }, id2 ? `#${id2}` : classNames.reduce((acc, className) => `${acc}.${className}`, "")), react_default.createElement("span", { key: `${name}_gt`, style: { color: colors3.muted } }, ">"), !id2 && classNames.length === 0 && innerText && react_default.createElement(react_default.Fragment, null, react_default.createElement("span", { key: `${name}_text` }, innerText), react_default.createElement("span", { key: `${name}_close_lt`, style: { color: colors3.muted } }, "<"), react_default.createElement("span", { key: `${name}_close_tag`, style: { color: colors3.tag.name } }, "/", name), react_default.createElement("span", { key: `${name}_close_gt`, style: { color: colors3.muted } }, ">")));
  }, DateNode = ({ value: value2 }) => {
    let parsed = new Date(value2);
    isNaN(Number(parsed)) && (logger.warn("Invalid date value:", value2), parsed = null);
    let colors3 = useThemeColors();
    if (!parsed)
      return react_default.createElement("span", { style: { whiteSpace: "nowrap", color: colors3.date } }, "Invalid date");
    let [date, time, ms] = parsed.toISOString().split(/[T.Z]/);
    return react_default.createElement("span", { style: { whiteSpace: "nowrap", color: colors3.date } }, date, react_default.createElement("span", { style: { opacity: 0.7 } }, "T"), time === "00:00:00" ? react_default.createElement("span", { style: { opacity: 0.7 } }, time) : time, ms === "000" ? react_default.createElement("span", { style: { opacity: 0.7 } }, ".", ms) : `.${ms}`, react_default.createElement("span", { style: { opacity: 0.7 } }, "Z"));
  }, ErrorNode = ({ name, message }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.error.name } }, name, message && ": ", message && react_default.createElement("span", { style: { color: colors3.error.message }, title: message.length > 50 ? message : "" }, ellipsize(message, 50)));
  }, RegExpNode = ({ flags, source }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { whiteSpace: "nowrap", color: colors3.regex.flags } }, "/", react_default.createElement("span", { style: { color: colors3.regex.source } }, source), "/", flags);
  }, SymbolNode = ({ description }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { whiteSpace: "nowrap", color: colors3.instance } }, "Symbol(", description && react_default.createElement("span", { style: { color: colors3.meta } }, '"', description, '"'), ")");
  }, OtherNode = ({ value: value2 }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.meta } }, stringify3(value2));
  }, StepNode = ({ label }) => {
    let colors3 = useThemeColors(), { typography: typography4 } = useTheme();
    return react_default.createElement(
      "span",
      {
        style: {
          color: colors3.base,
          fontFamily: typography4.fonts.base,
          fontSize: typography4.size.s2 - 1
        }
      },
      label
    );
  }, MethodCall = ({
    call,
    callsById
  }) => {
    if (!call)
      return null;
    if (call.method === "step" && call.path?.length === 0)
      return react_default.createElement(StepNode, { label: call.args[0] });
    let path = call.path?.flatMap((elem, index2) => {
      let callId = elem.__callId__;
      return [
        callId ? react_default.createElement(MethodCall, { key: `elem${index2}`, call: callsById?.get(callId), callsById }) : react_default.createElement("span", { key: `elem${index2}` }, elem),
        react_default.createElement("wbr", { key: `wbr${index2}` }),
        react_default.createElement("span", { key: `dot${index2}` }, ".")
      ];
    }), args = call.args?.flatMap((arg, index2, array2) => {
      let node = react_default.createElement(Node2, { key: `node${index2}`, value: arg, callsById });
      return index2 < array2.length - 1 ? [node, react_default.createElement("span", { key: `comma${index2}` }, ",\xA0"), react_default.createElement("wbr", { key: `wbr${index2}` })] : [node];
    }), colors3 = useThemeColors();
    return react_default.createElement(react_default.Fragment, null, react_default.createElement("span", { style: { color: colors3.base } }, path), react_default.createElement("span", { style: { color: colors3.method } }, call.method), react_default.createElement("span", { style: { color: colors3.base } }, "(", react_default.createElement("wbr", null), args, react_default.createElement("wbr", null), ")"));
  }, getParams = (line, fromIndex = 0) => {
    for (let i22 = fromIndex, depth = 1; i22 < line.length; i22 += 1)
      if (line[i22] === "(" ? depth += 1 : line[i22] === ")" && (depth -= 1), depth === 0)
        return line.slice(fromIndex, i22);
    return "";
  }, parseValue2 = (value2) => {
    try {
      return value2 === "undefined" ? void 0 : JSON.parse(value2);
    } catch {
      return value2;
    }
  }, StyledExpected = styled.span(({ theme: theme3 }) => ({
    color: theme3.base === "light" ? theme3.color.positiveText : theme3.color.positive
  })), StyledReceived = styled.span(({ theme: theme3 }) => ({
    color: theme3.base === "light" ? theme3.color.negativeText : theme3.color.negative
  })), Received = ({ value: value2, parsed }) => parsed ? react_default.createElement(Node2, { showObjectInspector: !0, value: value2, style: { color: "#D43900" } }) : react_default.createElement(StyledReceived, null, value2), Expected = ({ value: value2, parsed }) => parsed ? typeof value2 == "string" && value2.startsWith("called with") ? react_default.createElement(react_default.Fragment, null, value2) : react_default.createElement(Node2, { showObjectInspector: !0, value: value2, style: { color: "#16B242" } }) : react_default.createElement(StyledExpected, null, value2), MatcherResult = ({
    message,
    style = {}
  }) => {
    let filter = useAnsiToHtmlFilter(), lines = message.split(`
`);
    return react_default.createElement(
      "pre",
      {
        style: {
          margin: 0,
          padding: "8px 10px 8px 36px",
          fontSize: typography.size.s1,
          ...style
        }
      },
      lines.flatMap((line, index2) => {
        if (line.startsWith("expect(")) {
          let received = getParams(line, 7), remainderIndex = received ? 7 + received.length : 0, matcher = received && line.slice(remainderIndex).match(/\.(to|last|nth)[A-Z]\w+\(/);
          if (matcher) {
            let expectedIndex = remainderIndex + (matcher.index ?? 0) + matcher[0].length, expected = getParams(line, expectedIndex);
            if (expected)
              return [
                "expect(",
                react_default.createElement(Received, { key: `received_${received}`, value: received }),
                line.slice(remainderIndex, expectedIndex),
                react_default.createElement(Expected, { key: `expected_${expected}`, value: expected }),
                line.slice(expectedIndex + expected.length),
                react_default.createElement("br", { key: `br${index2}` })
              ];
          }
        }
        if (line.match(/^\s*- /))
          return [react_default.createElement(Expected, { key: line + index2, value: line }), react_default.createElement("br", { key: `br${index2}` })];
        if (line.match(/^\s*\+ /) || line.match(/^Received: $/))
          return [react_default.createElement(Received, { key: line + index2, value: line }), react_default.createElement("br", { key: `br${index2}` })];
        let [, assertionLabel, assertionValue] = line.match(/^(Expected|Received): (.*)$/) || [];
        if (assertionLabel && assertionValue)
          return assertionLabel === "Expected" ? [
            "Expected: ",
            react_default.createElement(Expected, { key: line + index2, value: parseValue2(assertionValue), parsed: !0 }),
            react_default.createElement("br", { key: `br${index2}` })
          ] : [
            "Received: ",
            react_default.createElement(Received, { key: line + index2, value: parseValue2(assertionValue), parsed: !0 }),
            react_default.createElement("br", { key: `br${index2}` })
          ];
        let [, prefix2, numberOfCalls] = line.match(/(Expected number|Received number|Number) of calls: (\d+)$/i) || [];
        if (prefix2 && numberOfCalls)
          return [
            `${prefix2} of calls: `,
            react_default.createElement(Node2, { key: line + index2, value: Number(numberOfCalls) }),
            react_default.createElement("br", { key: `br${index2}` })
          ];
        let [, receivedValue] = line.match(/^Received has value: (.+)$/) || [];
        return receivedValue ? [
          "Received has value: ",
          react_default.createElement(Node2, { key: line + index2, value: parseValue2(receivedValue) }),
          react_default.createElement("br", { key: `br${index2}` })
        ] : [
          react_default.createElement(
            "span",
            {
              key: line + index2,
              dangerouslySetInnerHTML: { __html: filter.toHtml(line) }
            }
          ),
          react_default.createElement("br", { key: `br${index2}` })
        ];
      })
    );
  }, WarningContainer = styled.div({
    width: 14,
    height: 14,
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  }), StatusIcon2 = ({ status }) => {
    let theme3 = useTheme();
    switch (status) {
      case "done":
        return react_default.createElement(CheckIcon, { color: theme3.color.positive, "data-testid": "icon-done" });
      case "error":
        return react_default.createElement(StopAltIcon, { color: theme3.color.negative, "data-testid": "icon-error" });
      case "active":
        return react_default.createElement(PlayIcon, { color: theme3.color.secondary, "data-testid": "icon-active" });
      case "waiting":
        return react_default.createElement(WarningContainer, { "data-testid": "icon-waiting" }, react_default.createElement(CircleIcon, { color: curriedTransparentize$1(0.5, "#CCCCCC"), size: 6 }));
      default:
        return null;
    }
  }, MethodCallWrapper = styled.div({
    fontFamily: typography.fonts.mono,
    fontSize: typography.size.s1,
    overflowWrap: "break-word",
    inlineSize: "calc( 100% - 40px )"
  }), RowContainer = styled("div", {
    shouldForwardProp: (prop) => !["call", "pausedAt"].includes(prop.toString())
  })(
    ({ theme: theme3, call }) => ({
      position: "relative",
      display: "flex",
      flexDirection: "column",
      borderBottom: `1px solid ${theme3.appBorderColor}`,
      fontFamily: typography.fonts.base,
      fontSize: 13,
      ...call.status === "error" && {
        backgroundColor: theme3.base === "dark" ? curriedTransparentize$1(0.93, theme3.color.negative) : theme3.background.warning
      },
      paddingLeft: (call.ancestors?.length ?? 0) * 20
    }),
    ({ theme: theme3, call, pausedAt }) => pausedAt === call.id && {
      "&::before": {
        content: '""',
        position: "absolute",
        top: -5,
        zIndex: 1,
        borderTop: "4.5px solid transparent",
        borderLeft: `7px solid ${theme3.color.warning}`,
        borderBottom: "4.5px solid transparent"
      },
      "&::after": {
        content: '""',
        position: "absolute",
        top: -1,
        zIndex: 1,
        width: "100%",
        borderTop: `1.5px solid ${theme3.color.warning}`
      }
    }
  ), RowHeader = styled.div(({ theme: theme3, isInteractive }) => ({
    display: "flex",
    "&:hover": isInteractive ? {} : { background: theme3.background.hoverable }
  })), RowLabel = styled("button", {
    shouldForwardProp: (prop) => !["call"].includes(prop.toString())
  })(({ theme: theme3, disabled, call }) => ({
    flex: 1,
    display: "grid",
    background: "none",
    border: 0,
    gridTemplateColumns: "15px 1fr",
    alignItems: "center",
    minHeight: 40,
    margin: 0,
    padding: "8px 15px",
    textAlign: "start",
    cursor: disabled || call.status === "error" ? "default" : "pointer",
    "&:focus-visible": {
      outline: 0,
      boxShadow: `inset 3px 0 0 0 ${call.status === "error" ? theme3.color.warning : theme3.color.secondary}`,
      background: call.status === "error" ? "transparent" : theme3.background.hoverable
    },
    "& > div": {
      opacity: call.status === "waiting" ? 0.5 : 1
    }
  })), RowActions = styled.div({
    display: "flex",
    alignItems: "center",
    padding: 6
  }), StyledButton2 = styled(Button)(({ theme: theme3 }) => ({
    color: theme3.textMutedColor,
    margin: "0 3px"
  })), RowMessage = styled("div")(({ theme: theme3 }) => ({
    padding: "8px 10px 8px 36px",
    fontSize: typography.size.s1,
    color: theme3.color.defaultText,
    pre: {
      margin: 0,
      padding: 0
    }
  })), ErrorName = styled.span(({ theme: theme3 }) => ({
    color: theme3.base === "dark" ? "#5EC1FF" : "#0271B6"
  })), ErrorMessage = styled.span(({ theme: theme3 }) => ({
    color: theme3.base === "dark" ? "#eee" : "#444"
  })), ErrorExplainer = styled.p(({ theme: theme3 }) => ({
    color: theme3.base === "dark" ? theme3.color.negative : theme3.color.negativeText,
    fontSize: theme3.typography.size.s2,
    maxWidth: 500,
    textWrap: "balance"
  })), Exception = ({ exception }) => {
    let filter = useAnsiToHtmlFilter();
    if (!exception)
      return null;
    if (exception.callId === INTERNAL_RENDER_CALL_ID)
      return createElement(RowMessage, null, createElement("pre", null, createElement(ErrorName, null, exception.name, ":"), " ", createElement(ErrorMessage, null, exception.message)), createElement(ErrorExplainer, null, "The component failed to render properly. Automated component tests will not run until this is resolved. Check the full error message in Storybook\u2019s canvas to debug."));
    if (isJestError(exception))
      return createElement(MatcherResult, { ...exception });
    if (isChaiError(exception))
      return createElement(RowMessage, null, createElement(
        MatcherResult,
        {
          message: `${exception.message}${exception.diff ? `

${exception.diff}` : ""}`,
          style: { padding: 0 }
        }
      ), createElement("p", null, "See the full stack trace in the browser console."));
    let paragraphs = exception.message.split(`

`), more = paragraphs.length > 1;
    return createElement(RowMessage, null, createElement("pre", { dangerouslySetInnerHTML: { __html: filter.toHtml(paragraphs[0]) } }), more && createElement("p", null, "See the full stack trace in the browser console."));
  }, Interaction = ({
    call,
    callsById,
    controls,
    controlStates,
    childCallIds,
    isHidden,
    isCollapsed,
    toggleCollapsed,
    pausedAt
  }) => {
    let [isHovered, setIsHovered] = useState(!1), isInteractive = !controlStates.goto || !call.interceptable || !!call.ancestors?.length;
    return isHidden || call.id === INTERNAL_RENDER_CALL_ID ? null : createElement(RowContainer, { call, pausedAt }, createElement(RowHeader, { isInteractive }, createElement(
      RowLabel,
      {
        "aria-label": "Interaction step",
        call,
        onClick: () => controls.goto(call.id),
        disabled: isInteractive,
        onMouseEnter: () => controlStates.goto && setIsHovered(!0),
        onMouseLeave: () => controlStates.goto && setIsHovered(!1)
      },
      createElement(StatusIcon2, { status: isHovered ? "active" : call.status }),
      createElement(MethodCallWrapper, { style: { marginLeft: 6, marginBottom: 1 } }, createElement(MethodCall, { call, callsById }))
    ), createElement(RowActions, null, (childCallIds?.length ?? 0) > 0 && createElement(
      StyledButton2,
      {
        padding: "small",
        variant: "ghost",
        onClick: toggleCollapsed,
        ariaLabel: `${isCollapsed ? "Show" : "Hide"} steps`
      },
      isCollapsed ? createElement(ChevronDownIcon, null) : createElement(ChevronUpIcon, null)
    ))), call.status === "error" && call.exception?.callId === call.id && createElement(Exception, { exception: call.exception }));
  }, Wrapper10 = styled.div(({ theme: { color: color2, typography: typography4, background: background2 } }) => ({
    textAlign: "start",
    padding: "11px 15px",
    fontSize: `${typography4.size.s2 - 1}px`,
    fontWeight: typography4.weight.regular,
    lineHeight: "1rem",
    background: background2.app,
    borderBottom: `1px solid ${color2.border}`,
    color: color2.defaultText,
    backgroundClip: "padding-box",
    position: "relative",
    code: {
      fontSize: `${typography4.size.s1 - 1}px`,
      color: "inherit",
      margin: "0 0.2em",
      padding: "0 0.2em",
      background: "rgba(255, 255, 255, 0.8)",
      borderRadius: "2px",
      boxShadow: "0 0 0 1px rgba(0, 0, 0, 0.1)"
    }
  })), TestDiscrepancyMessage = ({ browserTestStatus }) => {
    let docsUrl = useStorybookApi().getDocsUrl({
      subpath: DOCUMENTATION_DISCREPANCY_LINK,
      versioned: !0,
      renderer: !0
    }), [passed, failed] = browserTestStatus === "error" ? ["the CLI", "this browser"] : ["this browser", "the CLI"];
    return react_default.createElement(Wrapper10, null, "This interaction test passed in ", passed, ", but the tests failed in ", failed, ".", " ", react_default.createElement(Link, { href: docsUrl, target: "_blank", withArrow: !0 }, "Learn what could cause this"));
  }, StatusColorMapping = {
    rendering: "mediumdark",
    playing: "warning",
    completed: "positive",
    errored: "negative",
    aborted: "purple"
  }, StatusTextMapping = {
    rendering: "Wait",
    playing: "Runs",
    completed: "Pass",
    errored: "Fail",
    aborted: "Bail"
  }, StatusNoteMapping = {
    rendering: "Story is rendering",
    playing: "Interactions are running",
    completed: "Story ran successfully",
    errored: "Story failed to complete",
    aborted: "Interactions aborted due to file changes"
  }, StyledBadge = styled.div(({ theme: theme3, status }) => ({
    display: "inline-block",
    padding: "4px 6px 4px 8px",
    borderRadius: "4px",
    backgroundColor: theme3.color[StatusColorMapping[status]],
    color: "white",
    fontFamily: typography.fonts.base,
    textTransform: "uppercase",
    fontSize: typography.size.s1,
    letterSpacing: 3,
    fontWeight: typography.weight.bold,
    minWidth: 65,
    textAlign: "center"
  })), StatusBadge = ({ status }) => {
    let badgeText = StatusTextMapping[status], badgeNote = StatusNoteMapping[status];
    return react_default.createElement(
      WithTooltip,
      {
        hasChrome: !1,
        placement: "top",
        trigger: "hover",
        tooltip: react_default.createElement(TooltipNote, { note: badgeNote })
      },
      react_default.createElement(StyledBadge, { "aria-label": `Story status: ${badgeText}`, status }, badgeText)
    );
  }, ToolbarWrapper = styled.div(({ theme: theme3 }) => ({
    boxShadow: `${theme3.appBorderColor} 0 -1px 0 0 inset`,
    background: theme3.background.app,
    position: "sticky",
    top: 0,
    zIndex: 1
  })), StyledButton3 = styled(Button)(({ theme: theme3 }) => ({
    borderRadius: 4,
    padding: 6,
    color: theme3.textMutedColor,
    "&:not(:disabled)": {
      "&:hover,&:focus-visible": {
        color: theme3.color.secondary
      }
    }
  })), StyledIconButton = styled(Button)(({ theme: theme3 }) => ({
    color: theme3.textMutedColor
  })), OpenInEditorButton = styled(Button)(({ theme: theme3 }) => ({
    color: theme3.color.secondary,
    fontWeight: theme3.typography.weight.bold,
    justifyContent: "flex-end",
    textAlign: "right",
    whiteSpace: "nowrap",
    fontSize: 13,
    lineHeight: 24
  })), StyledLocation = styled(P)(({ theme: theme3 }) => ({
    color: theme3.textMutedColor,
    cursor: "default",
    fontWeight: theme3.typography.weight.regular,
    justifyContent: "flex-end",
    textAlign: "right",
    whiteSpace: "nowrap",
    margin: 0,
    fontSize: 13
  })), ControlsGroup = styled.div({
    display: "flex",
    alignItems: "center",
    flex: 1,
    gap: 6
  }), RewindButton = styled(StyledIconButton)({
    marginInlineStart: 3
  }), JumpToEndButton = styled(StyledButton3)({
    marginInline: 3,
    lineHeight: "12px"
  }), RerunButton = styled(StyledIconButton)(({ theme: theme3, animating, disabled }) => ({
    opacity: disabled ? 0.5 : 1,
    svg: {
      animation: animating ? `${theme3.animation.rotate360} 200ms ease-out` : void 0
    }
  })), Toolbar2 = ({
    controls,
    controlStates,
    status,
    storyFileName,
    onScrollToEnd,
    importPath,
    canOpenInEditor,
    api
  }) => {
    let buttonText = status === "errored" ? "Scroll to error" : "Scroll to end", theme3 = useTheme();
    return react_default.createElement(ToolbarWrapper, null, react_default.createElement(
      Toolbar,
      {
        backgroundColor: theme3.background.app,
        innerStyle: { gap: 6, paddingInline: 15 },
        "aria-label": "Component test playback controls"
      },
      react_default.createElement(ControlsGroup, null, react_default.createElement(StatusBadge, { status }), react_default.createElement(JumpToEndButton, { ariaLabel: !1, onClick: onScrollToEnd, disabled: !onScrollToEnd }, buttonText), react_default.createElement(Separator, null), react_default.createElement(
        RewindButton,
        {
          padding: "small",
          variant: "ghost",
          ariaLabel: "Go to start",
          onClick: controls.start,
          disabled: !controlStates.start
        },
        react_default.createElement(RewindIcon, null)
      ), react_default.createElement(
        StyledIconButton,
        {
          padding: "small",
          variant: "ghost",
          ariaLabel: "Go back",
          onClick: controls.back,
          disabled: !controlStates.back
        },
        react_default.createElement(PlayBackIcon, null)
      ), react_default.createElement(
        StyledIconButton,
        {
          padding: "small",
          variant: "ghost",
          ariaLabel: "Go forward",
          onClick: controls.next,
          disabled: !controlStates.next
        },
        react_default.createElement(PlayNextIcon, null)
      ), react_default.createElement(
        StyledIconButton,
        {
          padding: "small",
          variant: "ghost",
          ariaLabel: "Go to end",
          onClick: controls.end,
          disabled: !controlStates.end
        },
        react_default.createElement(FastForwardIcon, null)
      ), react_default.createElement(RerunButton, { padding: "small", variant: "ghost", ariaLabel: "Rerun", onClick: controls.rerun }, react_default.createElement(SyncIcon, null))),
      (importPath || storyFileName) && (canOpenInEditor ? react_default.createElement(
        OpenInEditorButton,
        {
          padding: "small",
          size: "small",
          variant: "ghost",
          ariaLabel: "Open in editor",
          onClick: () => {
            api.openInEditor({
              file: importPath
            });
          }
        },
        storyFileName
      ) : react_default.createElement(StyledLocation, null, storyFileName))
    ));
  }, Container3 = styled.div(({ theme: theme3 }) => ({
    height: "100%",
    background: theme3.background.content
  })), CaughtException = styled.div(({ theme: theme3 }) => ({
    borderBottom: `1px solid ${theme3.appBorderColor}`,
    backgroundColor: theme3.base === "dark" ? curriedTransparentize$1(0.93, theme3.color.negative) : theme3.background.warning,
    padding: 15,
    fontSize: theme3.typography.size.s2 - 1,
    lineHeight: "19px"
  })), CaughtExceptionCode = styled.code(({ theme: theme3 }) => ({
    margin: "0 1px",
    padding: 3,
    fontSize: theme3.typography.size.s1 - 1,
    lineHeight: 1,
    verticalAlign: "top",
    background: "rgba(0, 0, 0, 0.05)",
    border: `1px solid ${theme3.appBorderColor}`,
    borderRadius: 3
  })), CaughtExceptionTitle = styled.div({
    paddingBottom: 4,
    fontWeight: "bold"
  }), CaughtExceptionDescription = styled.p({
    margin: 0,
    padding: "0 0 20px"
  }), CaughtExceptionStack = styled.pre(({ theme: theme3 }) => ({
    margin: 0,
    padding: 0,
    "&:not(:last-child)": {
      paddingBottom: 16
    },
    fontSize: theme3.typography.size.s1 - 1
  })), InteractionsPanel = memo(
    function({
      storyUrl,
      status,
      calls,
      controls,
      controlStates,
      interactions,
      fileName,
      hasException,
      caughtException,
      unhandledErrors,
      pausedAt,
      onScrollToEnd,
      endRef,
      hasResultMismatch,
      browserTestStatus,
      importPath,
      canOpenInEditor,
      api
    }) {
      let filter = useAnsiToHtmlFilter(), hasRealInteractions = interactions.some((i22) => i22.id !== INTERNAL_RENDER_CALL_ID);
      return createElement(Container3, null, hasResultMismatch && createElement(TestDiscrepancyMessage, { browserTestStatus }), controlStates.detached && (hasRealInteractions || hasException) && createElement(DetachedDebuggerMessage, { storyUrl }), createElement(
        Toolbar2,
        {
          controls,
          controlStates,
          status,
          storyFileName: fileName,
          onScrollToEnd,
          importPath,
          canOpenInEditor,
          api
        }
      ), createElement("div", { "aria-label": "Interactions list" }, interactions.map((call) => createElement(
        Interaction,
        {
          key: call.id,
          call,
          callsById: calls,
          controls,
          controlStates,
          childCallIds: call.childCallIds,
          isHidden: call.isHidden,
          isCollapsed: call.isCollapsed,
          toggleCollapsed: call.toggleCollapsed,
          pausedAt
        }
      ))), caughtException && !isTestAssertionError(caughtException) && createElement(CaughtException, null, createElement(CaughtExceptionTitle, null, "Caught exception in ", createElement(CaughtExceptionCode, null, "play"), " function"), createElement(
        CaughtExceptionStack,
        {
          "data-chromatic": "ignore",
          dangerouslySetInnerHTML: {
            __html: filter.toHtml(printSerializedError(caughtException))
          }
        }
      )), unhandledErrors && createElement(CaughtException, null, createElement(CaughtExceptionTitle, null, "Unhandled Errors"), createElement(CaughtExceptionDescription, null, "Found ", unhandledErrors.length, " unhandled error", unhandledErrors.length > 1 ? "s" : "", " ", "while running the play function. This might cause false positive assertions. Resolve unhandled errors or ignore unhandled errors with setting the", createElement(CaughtExceptionCode, null, "test.dangerouslyIgnoreUnhandledErrors"), " ", "parameter to ", createElement(CaughtExceptionCode, null, "true"), "."), unhandledErrors.map((error, i22) => createElement(CaughtExceptionStack, { key: i22, "data-chromatic": "ignore" }, printSerializedError(error)))), createElement("div", { ref: endRef }), status === "completed" && !caughtException && !hasRealInteractions && createElement(Empty2, null));
    }
  );
  function printSerializedError(error) {
    return error.stack || `${error.name}: ${error.message}`;
  }
  var INITIAL_CONTROL_STATES = {
    detached: !1,
    start: !1,
    back: !1,
    goto: !1,
    next: !1,
    end: !1
  }, playStatusMap = {
    rendering: "rendering",
    playing: "playing",
    completed: "completed",
    errored: "errored",
    aborted: "aborted"
  }, terminalStatuses = ["completed", "errored", "aborted"], storyStatusMap = {
    done: "status-value:success",
    error: "status-value:error",
    active: "status-value:pending",
    waiting: "status-value:pending"
  }, getInteractions = ({
    log,
    calls,
    collapsed,
    setCollapsed
  }) => {
    let callsById = /* @__PURE__ */ new Map(), childCallMap = /* @__PURE__ */ new Map();
    return log.map(({ callId, ancestors, status }) => {
      let isHidden = !1;
      return ancestors.forEach((ancestor) => {
        collapsed.has(ancestor) && (isHidden = !0), childCallMap.set(ancestor, (childCallMap.get(ancestor) || []).concat(callId));
      }), { ...calls.get(callId), status, isHidden };
    }).map((call) => {
      let status = call.status === "error" && call.ancestors && callsById.get(call.ancestors.slice(-1)[0])?.status === "active" ? "active" : call.status;
      return callsById.set(call.id, { ...call, status }), {
        ...call,
        status,
        childCallIds: childCallMap.get(call.id),
        isCollapsed: collapsed.has(call.id),
        toggleCollapsed: () => setCollapsed((ids) => (ids.has(call.id) ? ids.delete(call.id) : ids.add(call.id), new Set(ids)))
      };
    });
  }, getPanelState = (state3, {
    log,
    calls,
    collapsed,
    setCollapsed
  }) => getInteractions({ log, calls, collapsed, setCollapsed }).reduce(
    (acc, interaction) => (interaction.id === INTERNAL_RENDER_CALL_ID ? acc.interactions.push(interaction) : state3.status !== "rendering" && (acc.controlStates = state3.controlStates, acc.interactions.push(interaction), interaction.method !== "step" && acc.interactionsCount++), acc),
    {
      ...state3,
      controlStates: INITIAL_CONTROL_STATES,
      interactions: [],
      interactionsCount: 0
    }
  ), getInternalRenderCall = (storyId, exception) => ({
    id: INTERNAL_RENDER_CALL_ID,
    method: "render",
    args: [],
    cursor: 0,
    storyId,
    ancestors: [],
    path: [],
    interceptable: !0,
    retain: !1,
    exception
  }), getInternalRenderLogItem = (status) => ({
    callId: INTERNAL_RENDER_CALL_ID,
    status,
    ancestors: []
  }), Panel = memo(
    function({ refId, storyId, storyUrl }) {
      let { statusValue, testRunId } = experimental_useStatusStore((state22) => {
        let storyStatus = refId ? void 0 : state22[storyId]?.[STATUS_TYPE_ID_COMPONENT_TEST];
        return {
          statusValue: storyStatus?.value,
          testRunId: storyStatus?.data?.testRunId
        };
      }), state3 = useStorybookState(), api = useStorybookApi(), importPath = api.getData(state3.storyId, state3.refId)?.importPath, canOpenInEditor = scope.CONFIG_TYPE === "DEVELOPMENT" && !state3.refId, [panelState, set] = useAddonState(ADDON_ID72, {
        status: "rendering",
        controlStates: INITIAL_CONTROL_STATES,
        interactions: [],
        interactionsCount: 0,
        hasException: !1,
        pausedAt: void 0,
        caughtException: void 0,
        unhandledErrors: void 0
      }), [scrollTarget, setScrollTarget] = useState(void 0), [collapsed, setCollapsed] = useState(/* @__PURE__ */ new Set()), [hasResultMismatch, setResultMismatch] = useState(!1), {
        status = "rendering",
        controlStates = INITIAL_CONTROL_STATES,
        interactions = [],
        pausedAt = void 0,
        caughtException = void 0,
        unhandledErrors = void 0
      } = panelState, log = useRef([getInternalRenderLogItem(
        "active"
        /* ACTIVE */
      )]), calls = useRef(
        /* @__PURE__ */ new Map([[INTERNAL_RENDER_CALL_ID, getInternalRenderCall(storyId)]])
      ), setCall = ({ status: status2, ...call }) => calls.current.set(call.id, call), endRef = useRef();
      useEffect(() => {
        let observer;
        return scope.IntersectionObserver && (observer = new scope.IntersectionObserver(
          ([end]) => setScrollTarget(end.isIntersecting ? void 0 : end.target),
          { root: scope.document.querySelector('#storybook-panel-root [role="tabpanel"]') }
        ), endRef.current && observer.observe(endRef.current)), () => observer?.disconnect();
      }, []);
      let lastStoryId = useRef(void 0), latestRenderId = useRef(0), emit = useChannel(
        {
          [EVENTS3.CALL]: setCall,
          [EVENTS3.SYNC]: (payload) => {
            log.current = [getInternalRenderLogItem(
              "done"
              /* DONE */
            ), ...payload.logItems], set(
              (state22) => getPanelState(
                { ...state22, controlStates: payload.controlStates, pausedAt: payload.pausedAt },
                { log: log.current, calls: calls.current, collapsed, setCollapsed }
              )
            );
          },
          [STORY_RENDER_PHASE_CHANGED]: (event) => {
            lastStoryId.current === event.storyId && ["preparing", "loading"].includes(event.newPhase) || (lastStoryId.current === event.storyId ? latestRenderId.current = Math.max(latestRenderId.current, event.renderId || 0) : (latestRenderId.current = event.renderId || 0, lastStoryId.current = event.storyId), latestRenderId.current === event.renderId && (event.newPhase === "rendering" ? (log.current = [getInternalRenderLogItem(
              "active"
              /* ACTIVE */
            )], calls.current.set(INTERNAL_RENDER_CALL_ID, getInternalRenderCall(storyId)), set({
              status: "rendering",
              controlStates: INITIAL_CONTROL_STATES,
              pausedAt: void 0,
              interactions: [],
              interactionsCount: 0,
              hasException: !1,
              caughtException: void 0,
              unhandledErrors: void 0
            })) : set((state22) => {
              let status2 = event.newPhase in playStatusMap && !terminalStatuses.includes(state22.status) ? playStatusMap[event.newPhase] : state22.status;
              return getPanelState(
                { ...state22, status: status2, pausedAt: void 0 },
                { log: log.current, calls: calls.current, collapsed, setCollapsed }
              );
            })));
          },
          [STORY_THREW_EXCEPTION]: (e2) => {
            log.current = [getInternalRenderLogItem(
              "error"
              /* ERROR */
            )], calls.current.set(
              INTERNAL_RENDER_CALL_ID,
              getInternalRenderCall(storyId, { ...e2, callId: INTERNAL_RENDER_CALL_ID })
            ), set(
              (state22) => getPanelState(
                {
                  ...state22,
                  hasException: !0,
                  caughtException: void 0,
                  controlStates: INITIAL_CONTROL_STATES,
                  pausedAt: void 0
                },
                { log: log.current, calls: calls.current, collapsed, setCollapsed }
              )
            );
          },
          [PLAY_FUNCTION_THREW_EXCEPTION]: (caughtException2) => {
            set((state22) => ({ ...state22, caughtException: caughtException2, hasException: !0 }));
          },
          [UNHANDLED_ERRORS_WHILE_PLAYING]: (unhandledErrors2) => {
            set((state22) => ({ ...state22, unhandledErrors: unhandledErrors2, hasException: !0 }));
          }
        },
        [collapsed]
      );
      useEffect(() => {
        set(
          (state22) => getPanelState(state22, { log: log.current, calls: calls.current, collapsed, setCollapsed })
        );
      }, [set, collapsed]);
      let controls = useMemo(
        () => ({
          start: () => emit(EVENTS3.START, { storyId }),
          back: () => emit(EVENTS3.BACK, { storyId }),
          goto: (callId) => emit(EVENTS3.GOTO, { storyId, callId }),
          next: () => emit(EVENTS3.NEXT, { storyId }),
          end: () => emit(EVENTS3.END, { storyId }),
          rerun: () => {
            emit(FORCE_REMOUNT, { storyId });
          }
        }),
        [emit, storyId]
      ), storyFilePath = useParameter("fileName", ""), [fileName] = storyFilePath.toString().split("/").slice(-1), scrollToTarget = () => scrollTarget?.scrollIntoView({ behavior: "smooth", block: "end" }), hasException = !!caughtException || !!unhandledErrors || interactions.some(
        (v22) => v22.status === "error"
        /* ERROR */
      ), browserTestStatus = useMemo(() => status !== "playing" && (interactions.length > 0 || hasException) ? hasException ? "error" : "done" : status === "playing" ? "active" : void 0, [status, interactions, hasException]);
      return useEffect(() => {
        if (browserTestStatus && statusValue && statusValue !== "status-value:pending" && statusValue !== storyStatusMap[browserTestStatus]) {
          let timeout = setTimeout(
            () => setResultMismatch((currentValue) => (currentValue || emit(STORYBOOK_ADDON_TEST_CHANNEL, {
              type: "test-discrepancy",
              payload: {
                browserStatus: browserTestStatus === "done" ? "PASS" : "FAIL",
                cliStatus: browserTestStatus === "done" ? "FAIL" : "PASS",
                storyId,
                testRunId
              }
            }), !0)),
            2e3
          );
          return () => clearTimeout(timeout);
        } else
          setResultMismatch(!1);
      }, [emit, browserTestStatus, statusValue, storyId, testRunId]), react_default.createElement(Fragment, { key: "component-tests" }, react_default.createElement(
        InteractionsPanel,
        {
          storyUrl,
          status,
          hasResultMismatch,
          browserTestStatus,
          calls: calls.current,
          controls,
          controlStates: { ...controlStates, detached: !!refId || controlStates.detached },
          interactions,
          fileName,
          hasException,
          caughtException,
          unhandledErrors,
          pausedAt,
          endRef,
          onScrollToEnd: scrollTarget && scrollToTarget,
          importPath,
          canOpenInEditor,
          api
        }
      ));
    }
  );
  function PanelTitle() {
    let selectedPanel = useStorybookApi().getSelectedPanel(), [addonState = {}] = useAddonState(ADDON_ID72), { status, hasException, interactionsCount } = addonState;
    return react_default.createElement("div", { style: { display: "flex", alignItems: "center", gap: 6 } }, react_default.createElement("span", null, "Interactions"), interactionsCount && status !== "errored" && !hasException ? react_default.createElement(Badge, { compact: !0, status: selectedPanel === PANEL_ID22 ? "active" : "neutral" }, interactionsCount) : null, status === "errored" || hasException ? react_default.createElement(StatusIcon2, {
      status: "error"
      /* ERROR */
    }) : null);
  }
  var manager_default3 = addons.register(ADDON_ID72, () => {
    if (globalThis?.FEATURES?.interactions) {
      let filter = ({ state: state3 }) => {
        let origin = state3.refId && state3.refs[state3.refId]?.url || document.location.origin, { pathname, search = "" } = state3.location, path = pathname + (state3.refId ? search.replace(`/${state3.refId}_`, "/") : search);
        return {
          refId: state3.refId,
          storyId: state3.storyId,
          storyUrl: origin + path
        };
      };
      addons.add(PANEL_ID22, {
        type: types.PANEL,
        title: () => react_default.createElement(PanelTitle, null),
        match: ({ viewMode }) => viewMode === "story",
        disabled: isInteractionsDisabled,
        render: ({ active }) => react_default.createElement(AddonPanel, { active: !!active }, react_default.createElement(Consumer, { filter }, (props) => react_default.createElement(Panel, { ...props })))
      });
    }
  }), BackgroundTool = memo(function() {
    let config2 = useParameter(PARAM_KEY), [globals, updateGlobals, storyGlobals] = useGlobals(), { options = DEFAULT_BACKGROUNDS, disable = !0 } = config2 || {};
    if (disable)
      return null;
    let data = globals[PARAM_KEY] || {}, backgroundName = data.value, isGridActive = data.grid || !1, item = options[backgroundName], isLocked = !!storyGlobals?.[PARAM_KEY], length = Object.keys(options).length;
    return react_default.createElement(
      Pure,
      {
        length,
        backgroundMap: options,
        item,
        updateGlobals,
        backgroundName,
        isLocked,
        isGridActive
      }
    );
  }), Pure = memo(function(props) {
    let {
      length,
      updateGlobals,
      backgroundMap,
      backgroundName,
      isLocked,
      isGridActive: isGrid
    } = props, update = useCallback(
      (input) => {
        updateGlobals({
          [PARAM_KEY]: input
        });
      },
      [updateGlobals]
    ), options = Object.entries(backgroundMap).map(([k22, value2]) => ({
      value: k22,
      title: value2.name,
      icon: react_default.createElement(CircleIcon, { color: value2?.value || "grey" })
    }));
    return react_default.createElement(Fragment, null, react_default.createElement(
      ToggleButton,
      {
        padding: "small",
        variant: "ghost",
        key: "grid",
        pressed: isGrid,
        disabled: isLocked,
        ariaLabel: isLocked ? "Grid set by story parameters" : "Grid visibility",
        tooltip: isLocked ? "Grid set by story parameters" : "Toggle grid visibility",
        onClick: () => update({ value: backgroundName, grid: !isGrid })
      },
      react_default.createElement(GridIcon, null)
    ), length > 0 ? react_default.createElement(
      Select,
      {
        resetLabel: "Reset background",
        onReset: () => update(void 0),
        disabled: isLocked,
        key: "background",
        icon: react_default.createElement(PhotoIcon, null),
        ariaLabel: isLocked ? "Background set by story parameters" : "Preview background",
        tooltip: isLocked ? "Background set by story parameters" : "Change background",
        defaultOptions: backgroundName,
        options,
        onSelect: (selected) => update({ value: selected, grid: isGrid })
      }
    ) : null);
  }), manager_default4 = addons.register(ADDON_ID, () => {
    globalThis?.FEATURES?.backgrounds && addons.add(ADDON_ID, {
      title: "Backgrounds",
      type: types.TOOL,
      match: ({ viewMode, tabId }) => !!(viewMode && viewMode.match(/^(story|docs)$/)) && !tabId,
      render: () => react_default.createElement(BackgroundTool, null)
    });
  }), Tool = () => {
    let [globals, updateGlobals] = useGlobals(), { measureEnabled } = globals || {}, api = useStorybookApi(), toggleMeasure = useCallback(
      () => updateGlobals({
        measureEnabled: !measureEnabled
      }),
      [updateGlobals, measureEnabled]
    );
    return useEffect(() => {
      api.setAddonShortcut(ADDON_ID2, {
        label: "Toggle Measure",
        defaultShortcut: ["M"],
        actionName: "measure",
        showInMenu: !1,
        action: toggleMeasure
      });
    }, [toggleMeasure, api]), react_default.createElement(
      ToggleButton,
      {
        key: TOOL_ID,
        pressed: measureEnabled,
        padding: "small",
        variant: "ghost",
        ariaLabel: "Measure tool",
        tooltip: "Toggle measure",
        ariaDescription: "When enabled, this tool shows dimensions and whitespace (margin, padding, border) for the currently hovered element in the preview area. Does not work with keyboard focus.",
        onClick: toggleMeasure
      },
      react_default.createElement(RulerIcon, null)
    );
  }, manager_default5 = addons.register(ADDON_ID2, () => {
    globalThis?.FEATURES?.measure && addons.add(TOOL_ID, {
      type: types.TOOL,
      title: "Measure",
      match: ({ viewMode, tabId }) => viewMode === "story" && !tabId,
      render: () => react_default.createElement(Tool, null)
    });
  }), OutlineSelector = memo(function() {
    let [globals, updateGlobals] = useGlobals(), api = useStorybookApi(), isActive = [!0, "true"].includes(globals[PARAM_KEY3]), toggleOutline = useCallback(
      () => updateGlobals({
        [PARAM_KEY3]: !isActive
      }),
      [isActive, updateGlobals]
    );
    return useEffect(() => {
      api.setAddonShortcut(ADDON_ID3, {
        label: "Toggle Outline",
        defaultShortcut: ["alt", "O"],
        actionName: "outline",
        showInMenu: !1,
        action: toggleOutline
      });
    }, [toggleOutline, api]), react_default.createElement(
      ToggleButton,
      {
        key: "outline",
        padding: "small",
        variant: "ghost",
        pressed: isActive,
        ariaLabel: "Outline tool",
        ariaDescription: "When enabled, this tool displays the outline of every element in the preview area, which helps understand their layout.",
        tooltip: "Toggle outline",
        onClick: toggleOutline
      },
      react_default.createElement(OutlineIcon, null)
    );
  }), manager_default6 = addons.register(ADDON_ID3, () => {
    globalThis?.FEATURES?.outline && addons.add(ADDON_ID3, {
      title: "Outline",
      type: types.TOOL,
      match: ({ viewMode, tabId }) => !!(viewMode && viewMode.match(/^(story|docs)$/)) && !tabId,
      render: () => react_default.createElement(OutlineSelector, null)
    });
  }), URL_VALUE_PATTERN = /^([0-9]{1,4})([a-z]{0,4})-([0-9]{1,4})([a-z]{0,4})$/, VIEWPORT_MIN_WIDTH = 40, VIEWPORT_MIN_HEIGHT = 40, cycle = (viewports, current, direction = 1) => {
    let keys = Object.keys(viewports), nextIndex = (current ? keys.indexOf(current) : -1) + direction;
    return nextIndex < 0 ? keys[keys.length - 1] : nextIndex >= keys.length ? keys[0] : keys[nextIndex];
  }, normalizeGlobal = (value2, defaultIsRotated) => typeof value2 == "string" ? { value: value2, isRotated: defaultIsRotated } : { value: value2?.value, isRotated: value2?.isRotated ?? defaultIsRotated }, parseGlobals = (globals, storyGlobals, userGlobals, options, lastSelectedOption, disable, viewMode) => {
    if (viewMode !== "story")
      return {
        name: "Responsive",
        type: "desktop",
        width: "100%",
        height: "100%",
        value: "100pct-100pct",
        option: void 0,
        isCustom: !1,
        isDefault: !0,
        isLocked: !0,
        isRotated: !1
      };
    let global4 = normalizeGlobal(globals?.[PARAM_KEY5]), userGlobal = normalizeGlobal(userGlobals?.[PARAM_KEY5]), storyGlobal = normalizeGlobal(storyGlobals?.[PARAM_KEY5]), value2 = userGlobal?.value ?? storyGlobal?.value ?? global4?.value, isRotated = userGlobal?.isRotated ?? storyGlobal?.isRotated ?? global4?.isRotated ?? !1, keys = Object.keys(options), isLocked = disable || PARAM_KEY5 in storyGlobals || !keys.length, [match, vx, ux, vy, uy] = value2?.match(URL_VALUE_PATTERN) || [];
    if (match) {
      let x22 = ux && ux !== "px" ? vx : Math.max(Number(vx), VIEWPORT_MIN_WIDTH), y22 = uy && uy !== "px" ? vy : Math.max(Number(vy), VIEWPORT_MIN_HEIGHT), width = `${x22}${ux === "pct" ? "%" : ux || "px"}`, height = `${y22}${uy === "pct" ? "%" : uy || "px"}`, selection = lastSelectedOption ? options[lastSelectedOption] : void 0;
      return {
        name: selection?.name ?? "Custom",
        type: selection?.type ?? "other",
        width: isRotated ? height : width,
        height: isRotated ? width : height,
        value: match,
        option: void 0,
        isCustom: !0,
        isDefault: !1,
        isLocked,
        isRotated
      };
    }
    if (value2 && keys.length) {
      let { name, styles: styles2, type = "other" } = options[value2] ?? options[keys[0]];
      return {
        name,
        type,
        width: isRotated ? styles2.height : styles2.width,
        height: isRotated ? styles2.width : styles2.height,
        value: value2,
        option: value2,
        isCustom: !1,
        isDefault: !1,
        isLocked,
        isRotated
      };
    }
    return {
      name: "Responsive",
      type: "desktop",
      width: "100%",
      height: "100%",
      value: "100pct-100pct",
      option: void 0,
      isCustom: !1,
      isDefault: !0,
      isLocked,
      isRotated: !1
    };
  }, useViewport = () => {
    let api = useStorybookApi(), { viewMode } = api.getUrlState(), lastSelectedOption = useRef(), parameter = useParameter(PARAM_KEY5), [globals, updateGlobals, storyGlobals, userGlobals] = useGlobals(), { options = MINIMAL_VIEWPORTS, disable = !1 } = parameter || {}, { name, type, width, height, value: value2, option, isCustom, isDefault, isLocked, isRotated } = parseGlobals(
      globals,
      storyGlobals,
      userGlobals,
      options,
      lastSelectedOption.current,
      disable,
      viewMode
    ), update = useCallback(
      (input) => updateGlobals({ [PARAM_KEY5]: normalizeGlobal(input, !1) }),
      [updateGlobals]
    ), resize = useCallback(
      (width2, height2) => {
        let w22 = width2.replace(/px$/, "").replace(/%$/, "pct"), h22 = height2.replace(/px$/, "").replace(/%$/, "pct"), value3 = isRotated ? `${h22}-${w22}` : `${w22}-${h22}`, [match, vx, ux, vy, uy] = value3.match(URL_VALUE_PATTERN) || [];
        match && (ux || Number(vx) >= 40) && (uy || Number(vy) >= 40) && update({ value: match, isRotated });
      },
      [update, isRotated]
    );
    return useEffect(() => {
      PARAM_KEY5 in storyGlobals && (update(normalizeGlobal(storyGlobals?.[PARAM_KEY5], !1)), lastSelectedOption.current = void 0);
    }, [storyGlobals, update]), useEffect(() => {
      option && (Object.hasOwn(options, option) ? lastSelectedOption.current = option : (lastSelectedOption.current = void 0, update(normalizeGlobal(storyGlobals?.[PARAM_KEY5], !1))));
    }, [storyGlobals, options, option, update]), useEffect(() => {
      api.setAddonShortcut(ADDON_ID5, {
        label: "Next viewport",
        defaultShortcut: ["alt", "V"],
        actionName: "next",
        action: () => update({ value: cycle(options, lastSelectedOption.current), isRotated })
      }), api.setAddonShortcut(ADDON_ID5, {
        label: "Previous viewport",
        defaultShortcut: ["alt", "shift", "V"],
        actionName: "previous",
        action: () => update({ value: cycle(options, lastSelectedOption.current, -1), isRotated })
      }), api.setAddonShortcut(ADDON_ID5, {
        label: "Reset viewport",
        defaultShortcut: ["alt", "control", "V"],
        actionName: "reset",
        action: () => update({ value: void 0, isRotated: !1 })
      });
    }, [api, update, options, isRotated]), useMemo(
      () => ({
        name,
        type,
        width,
        height,
        value: value2,
        option,
        isCustom,
        isDefault,
        isLocked,
        isRotated,
        options,
        lastSelectedOption: lastSelectedOption.current,
        resize,
        reset: () => update({ value: void 0, isRotated: !1 }),
        rotate: () => update({ value: value2, isRotated: !isRotated }),
        select: (value3) => update({ value: value3, isRotated })
      }),
      [
        name,
        type,
        width,
        height,
        value2,
        option,
        isCustom,
        isDefault,
        isRotated,
        isLocked,
        options,
        resize,
        update
      ]
    );
  }, iconsMap = {
    desktop: react_default.createElement(BrowserIcon, null),
    mobile: react_default.createElement(MobileIcon, null),
    tablet: react_default.createElement(TabletIcon, null),
    watch: react_default.createElement(WatchIcon, null),
    other: react_default.createElement(DiamondIcon, null)
  }, Dimensions = styled.div(({ theme: theme3 }) => ({
    display: "flex",
    gap: 2,
    marginLeft: 20,
    fontFamily: theme3.typography.fonts.mono,
    fontSize: theme3.typography.size.s1 - 1,
    fontWeight: theme3.typography.weight.regular,
    color: theme3.textMutedColor
  })), ViewportTool = () => {
    let { name, value: value2, isDefault, isLocked, options: viewportMap, reset, select } = useViewport(), options = useMemo(
      () => Object.entries(viewportMap).map(([k22, value3]) => ({
        value: k22,
        title: value3.name,
        icon: iconsMap[value3.type],
        right: react_default.createElement(Dimensions, null, react_default.createElement("span", null, value3.styles.width.replace("px", "")), react_default.createElement("span", null, "\xD7"), react_default.createElement("span", null, value3.styles.height.replace("px", "")))
      })),
      [viewportMap]
    );
    return react_default.createElement(
      Select,
      {
        resetLabel: "Reset viewport",
        onReset: reset,
        key: "viewport",
        disabled: isLocked,
        ariaLabel: isLocked ? "Viewport size set by story parameters" : "Viewport size",
        ariaDescription: "Select a viewport among predefined options for the preview area, or reset to the default viewport.",
        tooltip: isLocked ? "Viewport set by story parameters" : "Change viewport",
        defaultOptions: value2,
        options,
        onSelect: (selected) => select(selected),
        icon: react_default.createElement(GrowIcon, null)
      },
      isDefault ? null : name
    );
  }, manager_default7 = addons.register(ADDON_ID5, () => {
    globalThis?.FEATURES?.viewport && addons.add(TOOL_ID2, {
      title: "viewport / media-queries",
      type: types.TOOL,
      match: ({ viewMode, tabId }) => viewMode === "story" && !tabId,
      render: () => createElement(ViewportTool, null)
    });
  }), TAG_FILTERS = "tag-filters", STATIC_FILTER = "static-filter", tagFiltersManager = addons.register(TAG_FILTERS, (api) => {
    let staticExcludeTags = Object.entries(scope.TAGS_OPTIONS ?? {}).reduce(
      (acc, entry) => {
        let [tag, option] = entry;
        return option.excludeFromSidebar && (acc[tag] = !0), acc;
      },
      {}
    );
    api.experimental_setFilter(STATIC_FILTER, (item) => {
      let tags = item.tags ?? [];
      return (
        // we can filter out the primary story, but we still want to show autodocs
        (tags.includes(Tag.DEV) || item.type === "docs") && tags.filter((tag) => staticExcludeTags[tag]).length === 0
      );
    });
  });
})();
}catch(e){ console.error("[Storybook] One of your manager-entries failed: " + import.meta.url, e); }
